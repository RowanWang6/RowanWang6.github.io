<html>
<head>
  <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="robots" content="all,follow">
<meta name="googlebot" content="index,follow,snippet,archive">
<title>Vue.js | Rowan&#39;s Page</title>
<link rel="shortcut icon" href="https://rowanwang6.github.io/favicon.ico?v=1695113523701">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css" integrity="sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf" crossorigin="anonymous">
<link rel="stylesheet" href="https://rowanwang6.github.io/styles/main.css" type='text/css' media='all'>

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">



</head>
<body class="home blog ct-body standard">
<div id="overflow-container" class="overflow-container">
  <a class="skip-content" href="#main">Skip to content</a>
  <header id="site-header" class="site-header" role="banner">
    <div class='top-navigation top-navigation-important'>
        <div class='container'>
            <div id="menu-secondary" class="menu-container menu-secondary" role="navigation">
                <button id="toggle-secondary-navigation" class="toggle-secondary-navigation"><i class="fa fa-plus"></i></button>
                <div class="menu">
                    <ul id="menu-secondary-items" class="menu-secondary-items">
                        
                        
                            
                        <li id="menu-item" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item">
                            <a href="https://rowanwang6.github.io/tag/web/">web</a>
                        </li>
                            
                        
                            
                        <li id="menu-item" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item">
                            <a href="https://rowanwang6.github.io/tag/CV/">Computer Vison</a>
                        </li>
                            
                        
                            
                        <li id="menu-item" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item">
                            <a href="https://rowanwang6.github.io/tag/myself/">Myself</a>
                        </li>
                            
                        
                    </ul>
                </div>
            </div>
            <ul class="social-media-icons">
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        </div>
    </div>

    <div class="container">
        <div id="title-info" class="title-info">
            <div id='site-title' class='site-title'>
                <a href="https://rowanwang6.github.io">  Rowan&#39;s Page </a>
            </div>
        </div>
        <button id="toggle-navigation" class="toggle-navigation">
            <i class="fa fa-bars"></i>
        </button>
        <div id="menu-primary-tracks" class="menu-primary-tracks"></div>
        <div id="menu-primary" class="menu-container menu-primary" role="navigation">
            <p class="site-description"></p>
            <div class="menu">
                <ul id="menu-primary-items" class="menu-primary-items">
                     
                        
                            <li id="menu-item" class='menu-item menu-item-type-post_type menu-item-object-page current-menu-item current_page_item'>
                                <a href="/">Home Page</a>
                            </li>
                        
                    
                        
                            <li id="menu-item" class='menu-item menu-item-type-post_type menu-item-object-page current-menu-item current_page_item'>
                                <a href="/tags">Tags</a>
                            </li>
                        
                    
                        
                            <li id="menu-item" class='menu-item menu-item-type-post_type menu-item-object-page current-menu-item current_page_item'>
                                <a href="/archives">Archives</a>
                            </li>
                        
                    
                        
                            <li id="menu-item" class='menu-item menu-item-type-post_type menu-item-object-page current-menu-item current_page_item'>
                                <a href="/post/about">About</a>
                            </li>
                        
                    
                </ul>
            </div>
        </div>
    </div>


</header>


  <div id="main" class="main" role="main">
    <div id="loop-container" class="loop-container">
      <div class="post type-post status-publish format-standard has-post-thumbnail hentry category-design tag-design tag-standard-2 tag-tagalicious tag-travel entry full-without-featured odd excerpt-1">
        

        <div class="entry-meta">
          <span class="date">· 2022-07-20 ·</span> <span> / </span>
          <span class="author">
            <a href="https://rowanwang6.github.io" title="" rel="author"> xkwang7-c@my.cityu.edu.hk</a>
          </span>
          
            <span class="category">
                    <span> / </span>
                    <a href="https://rowanwang6.github.io/tag/web/">web</a>
                </span>
          
        </div>
        <div class='entry-header'>
          <h1 class='entry-title'>Vue.js</h1>
        </div>
        <div class="entry-container">
          <div class="entry-content">
            <article>
              <h1 id="基础">基础</h1>
<h2 id="1-第一个vue案例">1. 第一个Vue案例</h2>
<pre><code class="language-js">  &lt;div id=&quot;root&quot;&gt;
      &lt;h1&gt;Hello，{{name.toUpperCase()}}，{{address}}&lt;/h1&gt;
    &lt;/div&gt;
 
 new Vue({
        el: &quot;#root&quot;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。id选择器，也可以用类选择器。
        data: {
          //data中用于存储数据，数据供el所指定的容器去使用!!，值我们暂时先写成一个对象。
          name: &quot;rowanWang&quot;,
          address: &quot;Suizhou&quot;,
        },
      });
</code></pre>
<p>1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；<br>
2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；<br>
3.root容器里的代码被称为<strong>Vue模板</strong>；<br>
4.Vue实例和容器是一一对应的（类名相同的容器，vue只会接管第一个；多个vue尝试接管同一个容器，也只能第一个vue接管）；<br>
5.真实开发中只有<strong>一个Vue实例</strong>，会配合着组件一起使用；<br>
6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；<br>
7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p>
<blockquote>
<p>注意区分：js表达式 和 js代码(语句)<br>
1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：<br>
(1). a<br>
(2). a+b<br>
(3). demo(1)<br>
(4). x === y ? 'a' : 'b'<br>
2.js代码(语句)<br>
(1). if(){}<br>
(2). for(){}</p>
</blockquote>
<!-- more -->
<h2 id="2-模版语法">2. 模版语法</h2>
<p>Vue接管的容器的那一部分html代码叫做vue模版。<br>
模版语法分为插值语法和指令语法。<br>
Vue模板语法有2大类：<br>
<strong>1.插值语法</strong>：</p>
<ul>
<li>功能：用于解析标签体内容。</li>
<li>写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。<br>
<strong>2.指令语法</strong>：</li>
<li>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。</li>
<li>举例：v-bind:href=&quot;xxx&quot; 或  简写为 :href=&quot;xxx&quot;，xxx同样要写js表达式，<br>
且可以直接读取到data中的所有属性。</li>
<li>备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</li>
</ul>
<pre><code class="language-js">&lt;div id=&quot;main&quot;&gt;
      &lt;h1&gt;Rowan's Vue Project&lt;/h1&gt;
      &lt;hr /&gt;
      &lt;!-- 插值语法 --&gt;
      &lt;p&gt;My name is {{name.toUpperCase()}}, I'm {{age}} years old.&lt;/p&gt;
      &lt;hr /&gt;
      &lt;!-- 指令语法 --&gt;
      &lt;a v-bind:href=&quot;website.url&quot;
        &gt;Please visit my website : {{website.name}}&lt;/a
      &gt;
    &lt;/div&gt;
    &lt;script&gt;
      Vue.config.productionTip = false;
      new Vue({
        el: &quot;#main&quot;,
        data: {
          name: &quot;Rowan&quot;,
          age: 22,
          website: {
            url: &quot;http://rowanwang.tech&quot;,
            name: `Rowan's Page`, //有重名的key，使用多层数据
          },
        },
      });
    &lt;/script&gt;
</code></pre>
<h2 id="3-数据绑定">3. 数据绑定</h2>
<p>Vue中有2种数据绑定的方式：<br>
1.单向绑定(v-bind)：数据只能从data流向页面。<br>
2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。<br>
备注：<br>
并不是所有元素都可以使用v-model或者v-bind<br>
1.双向绑定一般都应用在表单类元素上（如：input、select等）<br>
2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p>
<h2 id="4-el和data的两种写法">4. el和data的两种写法</h2>
<p>data与el的2种写法<br>
1.el有2种写法<br>
(1).new Vue时候配置el属性。<br>
(2).先创建Vue实例，随后再通过vm.$mount('#root')指定el的值。<br>
2.data有2种写法<br>
(1).对象式<br>
(2).函数式<br>
如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。<br>
3.一个重要的原则：<br>
由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了，因为箭头函数没有自己的this。</p>
<pre><code class="language-js">//el的两种写法
/* const v = new Vue({
    //el:'#root', //第一种写法
    data:{
        name:'尚硅谷'
    }
})
console.log(v)
v.$mount('#root') //第二种写法 */

//data的两种写法
new Vue({
    el:'#root',
    //data的第一种写法：对象式
    /* data:{
        name:'尚硅谷'
    } */

    //data的第二种写法：函数式
    data(){  // 是从data:function(){简写而来
        console.log('@@@',this) //此处的this是Vue实例对象
        return{
            name:'尚硅谷'
        }
    }
})
</code></pre>
<h2 id="5-mvvm模型">5. MVVM模型</h2>
<p>Model-View-Viewmodel<br>
<img src="https://rowanwang6.github.io/post-images/1665448532687.png" alt="" loading="lazy"><br>
<img src="https://rowanwang6.github.io/post-images/1665448635904.png" alt="" loading="lazy"><br>
<img src="https://rowanwang6.github.io/post-images/1695113514117.png" alt="" loading="lazy"><br>
MVVM模型</p>
<ol>
<li>M：模型(Model) ：data中的数据</li>
<li>V：视图(View) ：模板代码</li>
<li>VM：视图模型(ViewModel)：Vue实例，一般用<code>vm</code>接收vue实例<br>
观察发现：<br>
1.data中所有的属性，最后都出现在了vm身上。<br>
2.vm身上所有的属性及Vue原型上所有属性，在Vue模板中都可以直接使用。(例如$emit, _isVue等等)</li>
</ol>
<h2 id="6-数据代理">6. 数据代理</h2>
<h3 id="61-回顾objectdefineproperty">6.1 回顾Object.defineProperty</h3>
<p>利用getter和setter实现。</p>
<pre><code class="language-js">let number = 18
let person = {
    name:'张三',
    sex:'男',
}

Object.defineProperty(person,'age',{
    // value:18,
    // enumerable:true, //控制属性是否可以枚举，默认值是false
    // writable:true, //控制属性是否可以被修改，默认值是false
    // configurable:true //控制属性是否可以被删除，默认值是false

    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
    get(){
        console.log('有人读取age属性了')
        return number
    },

    //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值
    set(value){
        console.log('有人修改了age属性，且值是',value)
        number = value
    }
})
// console.log(Object.keys(person))
console.log(person)
</code></pre>
<h3 id="62-数据代理">6.2 数据代理</h3>
<pre><code class="language-js">&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt;
let obj = {x:100}
let obj2 = {y:200}

Object.defineProperty(obj2,'x',{
    get(){
        return obj.x
    },
    set(value){
        obj.x = value
    }
})
</code></pre>
<h3 id="63-vue中的数据代理">6.3 Vue中的数据代理</h3>
<p>1.Vue中的数据代理：<br>
通过vm对象来代理data对象中属性的操作（读/写）<br>
2.Vue中数据代理的好处：<br>
更加方便的操作data中的数据<br>
3.基本原理：<br>
通过Object.defineProperty()把data对象中所有属性添加到vm上。<br>
为每一个添加到vm上的属性，都指定一个getter/setter。<br>
在getter/setter内部去操作（读/写）data中对应的属性。</p>
<h2 id="7-事件处理">7. 事件处理</h2>
<h3 id="71-基本事件处理">7.1 基本事件处理</h3>
<p>事件的基本使用：<br>
1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；<br>
2.事件的回调需要配置在methods对象中，最终会在vm上；<br>
3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；<br>
4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；<br>
5.@click=&quot;demo&quot; 和 @click=&quot;demo($event, args)&quot; 效果一致，但后者可以传参； event.target.innerHTML可以查看button的内容。<br>
6.函数不要写在data里，否则vue会给函数创建没有必要的数据代理；</p>
<h3 id="72-事件修饰符">7.2 事件修饰符</h3>
<pre><code class="language-js">&lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;
</code></pre>
<p>Vue中的事件修饰符：<br>
1.prevent：阻止默认事件（常用）；<br>
2.stop：阻止事件冒泡（常用）；<br>
3.once：事件只触发一次（常用）；<br>
4.capture：使用事件的捕获模式；<br>
5.self：只有event.target是当前操作的元素时才触发事件；<br>
6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p>
<h3 id="73-键盘事件">7.3 键盘事件</h3>
<p>1.Vue中常用的按键别名：<br>
回车 =&gt; enter<br>
删除 =&gt; delete (捕获“删除”和“退格”键)<br>
退出 =&gt; esc<br>
空格 =&gt; space<br>
换行 =&gt; tab (特殊，必须配合keydown去使用)<br>
上 =&gt; up<br>
下 =&gt; down<br>
左 =&gt; left<br>
右 =&gt; right<br>
2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）<br>
3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</p>
<ul>
<li>配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</li>
<li>配合keydown使用：正常触发事件。<br>
4.也可以使用keyCode去指定具体的按键（不推荐）<br>
5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名<br>
6.系统修饰键可以连用<code>@keydown.ctrl.y=&quot;showInfo&quot;</code></li>
</ul>
<h2 id="8-计算属性">8. 计算属性</h2>
<p>data数据内发生改变，vue会重新解析模板，重新调用函数。<br>
计算属性：<br>
1.定义：要用的属性不存在，要通过已有属性计算得来。<br>
2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。<br>
3.get函数什么时候执行？</p>
<ul>
<li>初次读取时会执行一次。</li>
<li>当依赖的数据发生改变时会被再次调用。</li>
</ul>
<p>4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。<br>
5.备注：</p>
<ul>
<li>计算属性最终会出现在vm上，直接读取使用即可。</li>
<li>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</li>
</ul>
<pre><code class="language-js">computed:{
        //完整写法
        /* fullName:{
            get(){
                console.log('get被调用了')
                return this.firstName + '-' + this.lastName
            },
            set(value){
                console.log('set',value)
                const arr = value.split('-')
                this.firstName = arr[0]
                this.lastName = arr[1]
            }
        } */
        //简写
        fullName(){// 并不是函数！ 还是计算出来的属性
            console.log('get被调用了')
            return this.firstName + '-' + this.lastName
        }
    }
</code></pre>
<h2 id="9-监视属性">9. 监视属性</h2>
<h3 id="91-监视属性">9.1 监视属性</h3>
<p>监视属性watch：<br>
1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作<br>
2.监视的属性必须存在，才能进行监视！！<br>
3.监视的两种写法：</p>
<ul>
<li>new Vue时传入watch配置</li>
<li>通过vm.$watch监视</li>
</ul>
<h3 id="92-深度监视">9.2 深度监视</h3>
<p>深度监视：</p>
<ul>
<li>Vue中的watch默认不监测对象内部值的改变（一层）。</li>
<li>配置deep:true可以监测对象内部值改变（多层）。<br>
备注：</li>
<li>Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</li>
<li>使用watch时根据数据的具体结构，决定是否采用深度监视。</li>
</ul>
<h3 id="93-监视属性简写">9.3 监视属性简写</h3>
<pre><code class="language-js">watch:{
//正常写法
/* isHot:{
    // immediate:true, //初始化时让handler调用一下
    // deep:true,//深度监视
    handler(newValue,oldValue){
        console.log('isHot被修改了',newValue,oldValue)
    }
}, */
//简写
/* isHot(newValue,oldValue){
    console.log('isHot被修改了',newValue,oldValue,this)
} */
}
})

//正常写法
/* vm.$watch('isHot',{
immediate:true, //初始化时让handler调用一下
deep:true,//深度监视
handler(newValue,oldValue){
console.log('isHot被修改了',newValue,oldValue)
}
}) */

//简写
/* vm.$watch('isHot',(newValue,oldValue)=&gt;{
console.log('isHot被修改了',newValue,oldValue,this)
}) */
</code></pre>
<h3 id="94-computed和watch的区别">9.4 computed和watch的区别</h3>
<p>computed和watch之间的区别：<br>
1.computed能完成的功能，watch都可以完成。<br>
2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。<br>
两个重要的小原则：<br>
1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。<br>
2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</p>
<h2 id="10-绑定样式">10. 绑定样式</h2>
<p>绑定样式：</p>
<ol>
<li>class样式<br>
写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。<br>
字符串写法适用于：类名不确定，要动态获取。<br>
对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。<br>
数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</li>
<li>style样式<br>
:style=&quot;{fontSize: xxx}&quot;其中xxx是动态值。<br>
:style=&quot;[a,b]&quot;其中a、b是样式对象。</li>
</ol>
<h2 id="11-条件渲染">11. 条件渲染</h2>
<p>条件渲染：<br>
1.v-if<br>
写法：<br>
(1).v-if=&quot;表达式&quot;<br>
(2).v-else-if=&quot;表达式&quot;<br>
(3).v-else=&quot;表达式&quot;<br>
适用于：切换频率较低的场景。<br>
特点：不展示的DOM元素直接被移除。<br>
注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p>
<p>2.v-show<br>
写法：v-show=&quot;表达式&quot;<br>
适用于：切换频率较高的场景。<br>
特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p>
<p>3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p>
<h2 id="12-列表渲染">12. 列表渲染</h2>
<h3 id="121-基本列表">12.1 基本列表</h3>
<p>v-for指令:<br>
1.用于展示列表数据<br>
2.语法：v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;<br>
3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p>
<h3 id="122-key的原理">12.2 key的原理</h3>
<p>面试题：react、vue中的key有什么作用？（key的内部原理）</p>
<ol>
<li>
<p>虚拟DOM中key的作用：<br>
key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br>
随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
</li>
<li>
<p>对比规则：<br>
(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>
①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>
②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。<br>
(2).旧虚拟DOM中未找到与新虚拟DOM相同的key<br>
创建新的真实DOM，随后渲染到到页面。</p>
</li>
<li>
<p>用index作为key可能会引发的问题：</p>
</li>
</ol>
<ul>
<li>若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>
会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</li>
<li>如果结构中还包含输入类的DOM：<br>
会产生错误DOM更新 ==&gt; 界面有问题。</li>
</ul>
<ol start="4">
<li>开发中如何选择key?<br>
1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>
2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>
使用index作为key是没有问题的。</li>
</ol>
<h3 id="123-列表过滤">12.3 列表过滤</h3>
<pre><code class="language-js">//用watch实现
//#region 
/* new Vue({
    el:'#root',
    data:{
        keyWord:'',
        persons:[
            {id:'001',name:'马冬梅',age:19,sex:'女'},
            {id:'002',name:'周冬雨',age:20,sex:'女'},
            {id:'003',name:'周杰伦',age:21,sex:'男'},
            {id:'004',name:'温兆伦',age:22,sex:'男'}
        ],
        filPerons:[]
    },
    watch:{
        keyWord:{
            immediate:true,
            handler(val){
                this.filPerons = this.persons.filter((p)=&gt;{
                    return p.name.indexOf(val) !== -1
                })
            }
        }
    }
}) */
//#endregion

//用computed实现
new Vue({
    el:'#root',
    data:{
        keyWord:'',
        persons:[
            {id:'001',name:'马冬梅',age:19,sex:'女'},
            {id:'002',name:'周冬雨',age:20,sex:'女'},
            {id:'003',name:'周杰伦',age:21,sex:'男'},
            {id:'004',name:'温兆伦',age:22,sex:'男'}
        ]
    },
    computed:{
        filPerons(){
            return this.persons.filter((p)=&gt;{
                return p.name.indexOf(this.keyWord) !== -1
            })
        }
    }
}) 
</code></pre>
<h3 id="124-列表排序">12.4 列表排序</h3>
<pre><code class="language-js">new Vue({
    el:'#root',
    data:{
        keyWord:'',
        sortType:0, //0原顺序 1降序 2升序
        persons:[
            {id:'001',name:'马冬梅',age:30,sex:'女'},
            {id:'002',name:'周冬雨',age:31,sex:'女'},
            {id:'003',name:'周杰伦',age:18,sex:'男'},
            {id:'004',name:'温兆伦',age:19,sex:'男'}
        ]
    },
    computed:{
        filPerons(){
            const arr = this.persons.filter((p)=&gt;{
                return p.name.indexOf(this.keyWord) !== -1
            })
            //判断一下是否需要排序
            if(this.sortType){
                arr.sort((p1,p2)=&gt;{
                    return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age
                })
            }
            return arr
        }
    }
}) 
</code></pre>
<h3 id="125-vue监视数据的总结">12.5 Vue监视数据的总结</h3>
<p>Vue监视数据的原理：</p>
<ol>
<li>
<p>vue会监视data中所有层次的数据。</p>
</li>
<li>
<p>如何监测对象中的数据？<br>
通过setter实现监视，且要在new Vue时就传入要监测的数据。<br>
(1).对象中后追加的属性，Vue默认不做响应式处理<br>
(2).如需给后添加的属性做响应式，请使用如下API：<br>
Vue.set(target，propertyName/index，value) 或<br>
vm.$set(target，propertyName/index，value)</p>
</li>
<li>
<p>如何监测数组中的数据？<br>
通过包裹数组更新元素的方法实现，本质就是做了两件事：<br>
(1).调用原生对应的方法对数组进行更新。<br>
(2).重新解析模板，进而更新页面。</p>
</li>
</ol>
<p>4.在Vue修改数组中的某个元素一定要用如下方法：<br>
1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>
2.Vue.set() 或 vm.$set()</p>
<p>数据劫持：给data分配getter和setter，当有人试图更改数据时，setter出面。// 待补充<br>
特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！</p>
<h2 id="13-收集表单数据">13. 收集表单数据</h2>
<p>收集表单数据：<br>
若：<code>&lt;input type=&quot;text&quot;/&gt;</code>，则v-model收集的是value值，用户输入的就是value值。<br>
若：<code>&lt;input type=&quot;radio&quot;/&gt;</code>，则v-model收集的是value值，且要给标签配置value值。<br>
若：<code>&lt;input type=&quot;checkbox&quot;/&gt;</code><br>
1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>
2.配置input的value属性:<br>
(1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>
(2)v-model的初始值是数组，那么收集的的就是value组成的数组<br>
备注：v-model的三个修饰符：<br>
lazy：失去焦点再收集数据<br>
number：输入字符串转为有效的数字<br>
trim：输入首尾空格过滤</p>
<h2 id="14-过滤器vue3中已移除">14. 过滤器（vue3中已移除）</h2>
<p>过滤器：<br>
定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。<br>
语法：<br>
1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}<br>
2.使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;<br>
备注：<br>
1.过滤器也可以接收额外参数、多个过滤器也可以串联<br>
2.并没有改变原本的数据, 是产生新的对应的数据</p>
<h2 id="15-vue常见的内置指令">15. vue常见的内置指令</h2>
<ul>
<li>v-bind	: 单向绑定解析表达式, 可简写为 <code>:xxx</code></li>
<li>v-model	: 双向数据绑定</li>
<li>v-for  	: 遍历数组/对象/字符串</li>
<li>v-on   	: 绑定事件监听, 可简写为@</li>
<li>v-if 	 	: 条件渲染（动态控制节点是否存存在）</li>
<li>v-else 	: 条件渲染（动态控制节点是否存存在）</li>
<li>v-show 	: 条件渲染 (动态控制节点是否展示)</li>
</ul>
<p>v-text指令：<br>
1.作用：向其所在的节点中渲染文本内容。<br>
2.与插值语法的区别：v-text会替换掉节点中的内容，插值语法{{xx}}则不会（用的更多）。</p>
<p>v-html指令：<br>
1.作用：向指定节点中渲染包含html结构的内容。<br>
2.与插值语法的区别：<br>
(1).v-html会替换掉节点中所有的内容，{{xx}}则不会。<br>
(2).v-html可以识别html结构。<br>
3.严重注意：v-html有安全性问题！！！！<br>
(1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p>
<p>v-cloak指令（没有值）：<br>
1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。<br>
2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。</p>
<p>v-once指令：<br>
1.v-once所在节点在初次动态渲染后，就视为静态内容了。<br>
2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p>
<p>v-pre指令：<br>
1.跳过其所在节点的编译过程。<br>
2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p>
<h2 id="16-vue的自定义指令">16. Vue的自定义指令</h2>
<p>element是绑定的元素，binding是绑定的信息</p>
<pre><code class="language-js">//big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。
big(element, binding) {//相当于只写了bind和update 
    // console.log(&quot;big&quot;, this); //注意此处的this是window
    // console.log('big')
    element.innerText = binding.value * 10;
}
</code></pre>
<pre><code class="language-js">fbind: {
//指令与元素成功绑定时（一上来）
bind(element, binding) {
    element.value = binding.value;
},
//指令所在元素被插入页面时
inserted(element, binding) {
    element.focus();
},
//指令所在的模板被重新解析时
update(element, binding) {
    element.value = binding.value;
},
},
</code></pre>
<p>自定义指令总结：<br>
一、定义语法：<br>
(1).局部指令：</p>
<pre><code class="language-js">new Vue({														
    directives:{指令名:配置对象} 
}) 								
或
new Vue({			
    directives{指令名:回调函数}
})
</code></pre>
<p>(2).全局指令：<br>
Vue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)</p>
<p>二、配置对象中常用的3个回调：<br>
(1).bind：指令与元素成功绑定时调用。<br>
(2).inserted：指令所在元素被插入页面时调用。<br>
(3).update：指令所在模板结构被重新解析时调用。</p>
<p>三、备注：<br>
1.指令定义时不加v-，但使用时要加v-；<br>
2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。大写读不出来，且如果是v-big-number，directives里key要加引号。</p>
<h2 id="17-生命周期">17. 生命周期</h2>
<p>生命周期：<br>
1.又名：生命周期回调函数、生命周期函数、生命周期钩子。<br>
2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。<br>
3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。<br>
4.生命周期函数中的this指向是vm 或 组件实例对象。<br>
<img src="https://rowanwang6.github.io/post-images/1665852600838.png" alt="" loading="lazy"></p>
<p>常用的生命周期钩子：<br>
1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。<br>
2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p>
<p>关于销毁Vue实例<br>
1.销毁后借助Vue开发者工具看不到任何信息。<br>
2.销毁后自定义事件会失效，但原生DOM事件依然有效。<br>
3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p>
<h2 id="18-非单文件组件">18. 非单文件组件：</h2>
<p>一个文件中包含有n个组件<br>
Vue中使用组件的三大步骤：<br>
一、定义组件(创建组件)<br>
二、注册组件<br>
三、使用组件(写组件标签)</p>
<p>一、如何定义一个组件？<br>
使用<code>Vue.extend(options)</code>创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；<br>
区别如下：<br>
1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。<br>
2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。<br>
备注：使用template可以配置组件结构。</p>
<p>二、如何注册组件？<br>
1.局部注册：靠new Vue的时候传入components选项<br>
2.全局注册：靠Vue.component('组件名',组件)</p>
<p>三、编写组件标签：<br>
<code>&lt;school&gt;&lt;/school&gt;</code></p>
<h3 id="181-几个注意点">18.1 几个注意点</h3>
<p>1.关于组件名:<br>
一个单词组成：<br>
第一种写法(首字母小写)：school<br>
第二种写法(首字母大写)：School<br>
多个单词组成：<br>
第一种写法(kebab-case命名)：my-school<br>
第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)<br>
备注：<br>
(1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。<br>
(2).可以使用name配置项指定组件在开发者工具中呈现的名字。</p>
<p>2.关于组件标签:<br>
第一种写法：<school></school><br>
第二种写法：<school/><br>
备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。</p>
<p>3.一个简写方式：<br>
const school = Vue.extend(options) 可简写为：const school = options</p>
<h3 id="182-vue的嵌套">18.2 Vue的嵌套</h3>
<pre><code class="language-js">	//定义student组件
		const student = Vue.extend({
			name:'student',
			template:`
				&lt;div&gt;
					&lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;	
					&lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;	
				&lt;/div&gt;
			`,
			data(){
				return {
					name:'尚硅谷',
					age:18
				}
			}
		})
		
		//定义school组件
		const school = Vue.extend({
			name:'school',
			template:`
				&lt;div&gt;
					&lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;	
					&lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;	
					&lt;student&gt;&lt;/student&gt;
				&lt;/div&gt;
			`,
			data(){
				return {
					name:'尚硅谷',
					address:'北京'
				}
			},
			//注册组件（局部）
			components:{
				student
			}
		})

		//定义hello组件
		const hello = Vue.extend({
			template:`&lt;h1&gt;{{msg}}&lt;/h1&gt;`,
			data(){
				return {
					msg:'欢迎来到尚硅谷学习！'
				}
			}
		})
		
		//定义app组件
		const app = Vue.extend({
			template:`
				&lt;div&gt;	
					&lt;hello&gt;&lt;/hello&gt;
					&lt;school&gt;&lt;/school&gt;
				&lt;/div&gt;
			`,
			components:{
				school,
				hello
			}
		})

		//创建vm
		new Vue({
			template:'&lt;app&gt;&lt;/app&gt;',
			el:'#root',
			//注册组件（局部）
			components:{app}
		})
</code></pre>
<h3 id="183-vuecomponent">18.3 VueComponent</h3>
<p>关于VueComponent：<br>
1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。</p>
<p>2.我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，<br>
即Vue帮我们执行的：new VueComponent(options)。</p>
<p>3.特别注意：每次调用Vue.extend，<strong>返回的都是一个全新的VueComponent！！！！</strong></p>
<p>4.关于this指向：<br>
(1).组件配置中：<br>
data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。<br>
(2).new Vue(options)配置中：<br>
data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</p>
<p>5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。<br>
Vue的实例对象，以后简称vm。</p>
<h3 id="184-内置关系">18.4 内置关系</h3>
<p>1.一个重要的内置关系：<code>VueComponent.prototype.__proto__ === Vue.prototype</code><br>
2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</p>
<p>显式原型属性<code>prototype</code>只有函数才可以拥有，new得到的实例只有<code>__proto__</code>隐式原型属性<br>
实例的隐式原型属性，永远指向自己的缔造者的原型对象。</p>
<pre><code class="language-js">	//定义一个构造函数
	 function Demo(){
			this.a = 1
			this.b = 2
		}
		//创建一个Demo的实例对象
		const d = new Demo()

		console.log(Demo.prototype) //显示原型属性

		console.log(d.__proto__) //隐式原型属性

		console.log(Demo.prototype === d.__proto__)

		//程序员通过显示原型属性操作原型对象，追加一个x属性，值为99
		Demo.prototype.x = 99

		console.log('@',d) 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://rowanwang6.github.io/post-images/1665901545808.png" alt="" loading="lazy"></figure>
<h2 id="19-单文件组件">19. 单文件组件</h2>
<p>非单文件样式不能跟着组件走</p>
<h2 id="20-vue脚手架">20. Vue脚手架</h2>
<p>render<br>
关于不同版本的Vue：</p>
<p>1.vue.js与vue.runtime.xxx.js的区别：<br>
(1).vue.js是完整版的Vue，包含：核心功能+模板解析器。<br>
(2).vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</p>
<p>2.因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用<br>
render函数接收到的createElement函数去指定具体内容。</p>
<h3 id="201-vueconfigjs配置文件">20.1 vue.config.js配置文件</h3>
<ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh</li>
</ol>
<h2 id="21-脚手架文件结构">21. 脚手架文件结构</h2>
<p>├── node_modules<br>
├── public<br>
│   ├── favicon.ico: 页签图标<br>
│   └── index.html: 主页面<br>
├── src<br>
│   ├── assets: 存放静态资源<br>
│   │   └── logo.png<br>
│   │── component: 存放组件<br>
│   │   └── HelloWorld.vue<br>
│   │── App.vue: 汇总所有组件<br>
│   │── main.js: 入口文件<br>
├── .gitignore: git版本管制忽略的配置<br>
├── babel.config.js: babel的配置文件<br>
├── package.json: 应用包配置文件<br>
├── README.md: 应用描述文件<br>
├── package-lock.json：包版本控制文件</p>
<h2 id="22-ref属性">22. ref属性</h2>
<ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：</li>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
<h2 id="23-props配置项">23.  props配置项</h2>
<ol>
<li>功能：让组件接收外部传过来的数据</li>
<li>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></li>
<li>接收数据：<br>
第一种方式（只接收）：<code>props:['name'] </code><br>
第二种方式（限制类型）：<code>props:{name:String}</code><br>
第三种方式（限制类型、限制必要性、指定默认值）：</li>
</ol>
<pre><code class="language-js">props:{
name:{
type:String, //类型
required:true, //必要性
default:'老王' //默认值
}
}
</code></pre>
<p>备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中一份，然后去修改 data 中的数据。</p>
<h2 id="24-mixin混合-复用">24. mixin混合 复用</h2>
<ol>
<li>功能：可以把多个组件共用的配置提取成一个混入对象</li>
<li>使用方式：<br>
第一步定义混合：</li>
</ol>
<pre><code>{
data(){....},
methods:{....}
....
}
</code></pre>
<p>第二步使用混入：<br>
​全局混入：<code>Vue.mixin(xxx)</code><br>
​局部混入：<code>mixins:['xxx'] </code></p>
<h2 id="25-插件">25. 插件</h2>
<ol>
<li>功能：用于增强 Vue</li>
<li>本质：包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据。</li>
<li>定义插件：</li>
</ol>
<pre><code class="language-js">对象.install = function (Vue, options) {
// 1. 添加全局过滤器
Vue.filter(....)

// 2. 添加全局指令
Vue.directive(....)

// 3. 配置全局混入(合)
Vue.mixin(....)

// 4. 添加实例方法
Vue.prototype.$myMethod = function () {...}
Vue.prototype.$myProperty = xxxx
}
</code></pre>
<ol start="4">
<li>使用插件：<code>Vue.use()</code></li>
</ol>
<h2 id="26-todolist-案例">26. toDoList 案例</h2>
<ol>
<li>组件化编码流程：<br>
(1).拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突。<br>
​(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</li>
</ol>
<ul>
<li>一个组件在用：放在组件自身即可。</li>
<li>一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。<br>
​(3).实现交互：从绑定事件开始。</li>
</ul>
<ol start="2">
<li>props 适用于：<br>
​(1).父组件 ==&gt; 子组件 通信<br>
(2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数），通过传参形式，将参数传给父</li>
<li>使用 v-model 时要切记：v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！</li>
<li>props 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做。</li>
</ol>
<h2 id="27-浏览器本地存储-webstoragelocalstorage-sessionstorage">27. 浏览器本地存储 webStorage(localStorage, sessionStorage)</h2>
<ol>
<li>存储内容大小一般支持 5MB 左右（不同浏览器可能还不一样）</li>
<li>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</li>
<li>相关 API：</li>
</ol>
<ul>
<li><code>xxxxxStorage.setItem('key', 'value');</code><br>
该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li>
<li><code>xxxxxStorage.getItem('person');</code><br>
​该方法接受一个键名作为参数，返回键名对应的值。</li>
<li><code>xxxxxStorage.removeItem('key');</code><br>
​该方法接受一个键名作为参数，并把该键名从存储中删除。</li>
<li><code> xxxxxStorage.clear()</code><br>
​该方法会清空存储中的所有数据。</li>
</ul>
<ol start="4">
<li>备注：</li>
</ol>
<ul>
<li>SessionStorage 存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage 存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null。</li>
<li><code>JSON.parse(null)</code>的结果依然是 null。</li>
</ul>
<h2 id="28-组件自定义事件">28. 组件自定义事件</h2>
<ol>
<li>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></li>
<li>使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（<span style="color:red">事件的回调在 A 中</span>）。</li>
<li>绑定自定义事件：</li>
</ol>
<ul>
<li>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code> 或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></li>
<li>第二种方式，在父组件中：</li>
</ul>
<pre><code class="language-js">&lt;Demo ref=&quot;demo&quot;/&gt;
......
mounted(){
    this.$refs.xxx.$on('atguigu',this.test)
}
</code></pre>
<ul>
<li>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</li>
</ul>
<ol start="4">
<li>
<p>触发自定义事件：<code>this.$emit('atguigu',数据)</code></p>
</li>
<li>
<p>解绑自定义事件<code>this.$off('atguigu')</code></p>
</li>
<li>
<p>组件上也可以绑定原生 DOM 事件，需要使用<code>native</code>修饰符。</p>
</li>
<li>
<p>注意：通过<code>this.$refs.xxx.$on('atguigu',回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在 methods 中</span>，<span style="color:red">要么用箭头函数</span>，否则 this 指向会出问题！</p>
</li>
</ol>
<h2 id="29-全局事件总线">29. 全局事件总线</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>安装全局事件总线：</p>
<pre><code class="language-js">new Vue({
	......
	beforeCreate() {
		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
	},
    ......
})
</code></pre>
</li>
<li>
<p>使用事件总线：</p>
<ol>
<li>
<p>接收数据：A 组件想接收数据，则在 A 组件中给$bus 绑定自定义事件，事件的<span style="color:red">回调留在 A 组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.$bus.$on('xxxx',this.demo)
}
</code></pre>
</li>
<li>
<p>提供数据：<code>this.$bus.$emit('xxxx',数据)</code></p>
</li>
</ol>
</li>
<li>
<p>最好在 beforeDestroy 钩子中，用$off 去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="30-消息订阅与发布pubsub">30. 消息订阅与发布（pubsub）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>使用步骤：</p>
<ol>
<li>
<p>安装 pubsub：<code>npm i pubsub-js</code></p>
</li>
<li>
<p>引入: <code>import pubsub from 'pubsub-js'</code></p>
</li>
<li>
<p>接收数据：A 组件想接收数据，则在 A 组件中订阅消息，订阅的<span style="color:red">回调留在 A 组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息
}
</code></pre>
</li>
<li>
<p>提供数据：<code>pubsub.publish('xxx',数据)</code></p>
</li>
<li>
<p>最好在 beforeDestroy 钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="31-nexttick">31. $nextTick</h2>
<ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行。</li>
</ol>
<h2 id="32-vue-封装的过度与动画">32. Vue 封装的过度与动画</h2>
<ol>
<li>
<p>作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li>
<p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" /></p>
</li>
<li>
<p>写法：</p>
<ol>
<li>
<p>准备好样式：</p>
<ul>
<li>元素进入的样式：
<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：
<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li>
<p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置 name 属性：</p>
<pre><code class="language-vue">&lt;transition name=&quot;hello&quot;&gt;
	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;
</code></pre>
</li>
<li>
<p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="33-vue-脚手架配置代理">33. vue 脚手架配置代理</h2>
<h3 id="方法一">方法一</h3>
<p>在 vue.config.js 中添加如下配置：</p>
<pre><code class="language-js">devServer: {
  proxy: &quot;http://localhost:5000&quot;;
}
</code></pre>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二">方法二</h3>
<p>编写 vue.config.js 配置具体代理规则：</p>
<pre><code class="language-js">module.exports = {
  devServer: {
    proxy: {
      &quot;/api1&quot;: {
        // 匹配所有以 '/api1'开头的请求路径
        target: &quot;http://localhost:5000&quot;, // 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: { &quot;^/api1&quot;: &quot;&quot; },
      },
      &quot;/api2&quot;: {
        // 匹配所有以 '/api2'开头的请求路径
        target: &quot;http://localhost:5001&quot;, // 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: { &quot;^/api2&quot;: &quot;&quot; },
      },
    },
  },
};
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
</code></pre>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="34-插槽">34. 插槽</h2>
<h3 id="插槽">插槽</h3>
<ol>
<li>作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。<br>
<img src="https://rowanwang6.github.io/post-images/1666246726348.png" alt="" loading="lazy"></li>
<li>分类：默认插槽、具名插槽、作用域插槽</li>
<li>使用方法</li>
</ol>
<ul>
<li>默认插槽：</li>
</ul>
<pre><code class="language-js">父组件中：
&lt;Category&gt;
            &lt;div&gt;html结构1&lt;/div&gt;
        &lt;/Category&gt;
子组件中：
&lt;template&gt;
&lt;div&gt;
    &lt;!-- 定义插槽 --&gt;
    &lt;slot&gt;插槽默认内容...&lt;/slot&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>具名插槽：</li>
</ul>
<pre><code class="language-js">父组件中：
&lt;Category&gt;
            &lt;template slot=&quot;center&quot;&gt;
            &lt;div&gt;html结构1&lt;/div&gt;
            &lt;/template&gt;

            &lt;template v-slot:footer&gt;
                &lt;div&gt;html结构2&lt;/div&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
&lt;template&gt;
&lt;div&gt;
    &lt;!-- 定义插槽 --&gt;
    &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;
    &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>作用域插槽：</li>
</ul>
<ol>
<li>
<p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定）</p>
</li>
<li>
<p>具体编码：</p>
</li>
</ol>
<pre><code class="language-js">父组件中：
&lt;Category&gt;
        &lt;template scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是ul列表 --&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/template&gt;
    &lt;/Category&gt;

&lt;Category&gt;
        &lt;template slot-scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是h4标题 --&gt;
            &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/h4&gt;
        &lt;/template&gt;
    &lt;/Category&gt;
子组件中：
&lt;template&gt;
&lt;div&gt;
    &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
name: &quot;Category&quot;,
props: [&quot;title&quot;],
//数据在子组件自身
data() {
    return {
    games: [&quot;红色警戒&quot;, &quot;穿越火线&quot;, &quot;劲舞团&quot;, &quot;超级玛丽&quot;],
    };
},
};
&lt;/script&gt;
</code></pre>
<h2 id="35-vuex">35. Vuex</h2>
<p>vuex里 <code>this.$store.commit</code> 调用mutations  <code>this.$store.dispatch</code> 调用actions</p>
<h3 id="1-概念">1. 概念</h3>
<p>在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。<br>
<img src="https://rowanwang6.github.io/post-images/1666407209354.png" alt="" loading="lazy"></p>
<h3 id="2-何时使用">2. 何时使用？</h3>
<p>多个组件需要共享数据时。</p>
<h3 id="3-搭建-vuex-环境">3. 搭建 vuex 环境</h3>
<ol>
<li>
<p>创建文件：<code>src/store/index.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from &quot;vue&quot;;
//引入Vuex
import Vuex from &quot;vuex&quot;;
//应用Vuex插件
Vue.use(Vuex);

//准备actions对象——响应组件中用户的动作 dispatch调用
const actions = {};
//准备mutations对象——修改state中的数据 commit调用
const mutations = {};
//准备state对象——保存具体的数据
const state = {};

//创建并暴露store
export default new Vuex.Store({
  actions,
  mutations,
  state,
});
</code></pre>
</li>
<li>
<p>在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p>
<pre><code class="language-js">......
//引入store
import store from './store'
......

//创建vm
new Vue({
	el:'#app',
	render: h =&gt; h(App),
	store
})
</code></pre>
</li>
</ol>
<h3 id="4-基本使用">4. 基本使用</h3>
<ol>
<li>
<p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from &quot;vue&quot;;
//引入Vuex
import Vuex from &quot;vuex&quot;;
//引用Vuex
Vue.use(Vuex);

const actions = {
  //响应组件中加的动作
  jia(context, value) {
    // console.log('actions中的jia被调用了',miniStore,value)
    context.commit(&quot;JIA&quot;, value);
  },
};

const mutations = {
  //执行加
  JIA(state, value) {
    // console.log('mutations中的JIA被调用了',state,value)
    state.sum += value;
  },
};

//初始化数据
const state = {
  sum: 0,
};

//创建并暴露store
export default new Vuex.Store({
  actions,
  mutations,
  state,
});
</code></pre>
</li>
<li>
<p>组件中读取 vuex 中的数据：<code>$store.state.sum</code></p>
</li>
<li>
<p>组件中修改 vuex 中的数据：<code>$store.dispatch('action中的方法名',数据)</code> 或 <code>$store.commit('mutations中的方法名',数据)</code></p>
<blockquote>
<p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters-的使用">5. getters 的使用</h3>
<ol>
<li>
<p>概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工。</p>
</li>
<li>
<p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<pre><code class="language-js">......

const getters = {
	bigSum(state){
		return state.sum * 10
	}
}

//创建并暴露store
export default new Vuex.Store({
	......
	getters
})
</code></pre>
</li>
<li>
<p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个-map-方法的使用">6. 四个 map 方法的使用</h3>
<ol>
<li>
<p><strong>mapState 方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapState生成计算属性：sum、school、subject（对象写法）
     ...mapState({sum:'sum',school:'school',subject:'subject'}),

    //借助mapState生成计算属性：sum、school、subject（数组写法）
    ...mapState(['sum','school','subject']),
},
</code></pre>
</li>
<li>
<p><strong>mapGetters 方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapGetters生成计算属性：bigSum（对象写法）
    ...mapGetters({bigSum:'bigSum'}),

    //借助mapGetters生成计算属性：bigSum（数组写法）
    ...mapGetters(['bigSum'])
},
</code></pre>
</li>
<li>
<p><strong>mapActions 方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：incrementOdd、incrementWait（对象形式）
    ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})

    //靠mapActions生成：incrementOdd、incrementWait（数组形式）
    ...mapActions(['jiaOdd','jiaWait'])
}
</code></pre>
</li>
<li>
<p><strong>mapMutations 方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：increment、decrement（对象形式）
    ...mapMutations({increment:'JIA',decrement:'JIAN'}),

    //靠mapMutations生成：JIA、JIAN（对象形式）
    ...mapMutations(['JIA','JIAN']),
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化命名空间">7. 模块化+命名空间</h3>
<ol>
<li>
<p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li>
<p>修改<code>store.js</code></p>
<pre><code class="language-javascript">const countAbout = {
  namespaced:true,//开启命名空间
  state:{x:1},
  mutations: { ... },
  actions: { ... },
  getters: {
    bigSum(state){
       return state.sum * 10
    }
  }
}

const personAbout = {
  namespaced:true,//开启命名空间
  state:{ ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    countAbout,
    personAbout
  }
})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取 state 数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState('countAbout',['sum','school','subject']),
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取 getters 数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.getters['personAbout/firstPersonName']
//方式二：借助mapGetters读取：
...mapGetters('countAbout',['bigSum'])
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用 dispatch</p>
<pre><code class="language-js">//方式一：自己直接dispatch
this.$store.dispatch('personAbout/addPersonWang',person)
//方式二：借助mapActions：
...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用 commit</p>
<pre><code class="language-js">//方式一：自己直接commit
this.$store.commit('personAbout/ADD_PERSON',person)
//方式二：借助mapMutations：
...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),
</code></pre>
</li>
</ol>
<h2 id="36-路由">36. 路由</h2>
<ol>
<li>
<p>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</p>
</li>
<li>
<p>前端路由：key 是路径，value 是组件。</p>
</li>
</ol>
<h3 id="1-基本使用">1. <strong>基本使用</strong></h3>
<h3 id="1基本使用">1.基本使用</h3>
<ol>
<li>
<p>安装 vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li>
<p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li>
<p>编写 router 配置项:</p>
<pre><code class="language-js">//引入VueRouter
import VueRouter from &quot;vue-router&quot;;
//引入Luyou 组件
import About from &quot;../components/About&quot;;
import Home from &quot;../components/Home&quot;;

//创建router实例对象，去管理一组一组的路由规则
const router = new VueRouter({
  routes: [
    {
      path: &quot;/about&quot;,
      component: About,
    },
    {
      path: &quot;/home&quot;,
      component: Home,
    },
  ],
});

//暴露router
export default router;
</code></pre>
</li>
<li>
<p>实现切换（active-class 可配置高亮样式）</p>
<pre><code class="language-vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>指定展示位置</p>
<pre><code class="language-vue">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<h3 id="2几个注意点">2.几个注意点</h3>
<ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个 router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3多级路由多级路由">3.多级路由（多级路由）</h3>
<ol>
<li>
<p>配置路由规则，使用 children 配置项：</p>
<pre><code class="language-js">routes: [
  {
    path: &quot;/about&quot;,
    component: About,
  },
  {
    path: &quot;/home&quot;,
    component: Home,
    children: [
      //通过children配置子级路由
      {
        path: &quot;news&quot;, //此处一定不要写：/news
        component: News,
      },
      {
        path: &quot;message&quot;, //此处一定不要写：/message
        component: Message,
      },
    ],
  },
];
</code></pre>
</li>
<li>
<p>跳转（要写完整路径）：</p>
<pre><code class="language-vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
</li>
</ol>
<h3 id="4路由的-query-参数">4.路由的 query 参数</h3>
<ol>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;

&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;
&lt;router-link
  :to=&quot;{
    path: '/home/message/detail',
    query: {
      id: 666,
      title: '你好',
    },
  }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.query.id;
$route.query.title;
</code></pre>
</li>
</ol>
<h3 id="5命名路由">5.命名路由</h3>
<ol>
<li>
<p>作用：可以简化路由的跳转。</p>
</li>
<li>
<p>如何使用</p>
<ol>
<li>
<p>给路由命名：</p>
<pre><code class="language-js">{
  path:'/demo',
  component:Demo,
  children:[
    {
      path:'test',
      component:Test,
      children:[
        {
                      name:'hello' //给路由命名
          path:'welcome',
          component:Hello,
        }
      ]
    }
  ]
}
</code></pre>
</li>
<li>
<p>简化跳转：</p>
<pre><code class="language-vue">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;{ name: 'hello' }&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link
  :to=&quot;{
    name: 'hello',
    query: {
      id: 666,
      title: '你好',
    },
  }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="6路由的-params-参数">6.路由的 params 参数</h3>
<ol>
<li>
<p>配置路由，声明接收 params 参数</p>
<pre><code class="language-js">{
 path:'/home',
 component:Home,
 children:[
   {
     path:'news',
     component:News
   },
   {
     component:Message,
     children:[
       {
         name:'xiangqing',
         path:'detail/:id/:title', //使用占位符声明接收params参数
         component:Detail
       }
     ]
   }
 ]
}
</code></pre>
</li>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;

&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link
  :to=&quot;{
    name: 'xiangqing',
    params: {
      id: 666,
      title: '你好',
    },
  }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
<blockquote>
<p>特别注意：路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置！</p>
</blockquote>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.params.id;
$route.params.title;
</code></pre>
</li>
</ol>
<h3 id="7路由的-props-配置">7.路由的 props 配置</h3>
<p>作用：让路由组件更方便的收到参数</p>
<pre><code class="language-js">{
  name:'xiangqing',
  path:'detail/:id',
  component:Detail,

  //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
  // props:{a:900}

  //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
  // props:true

  //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
  props(route){
    return {
      id:route.query.id,
      title:route.query.title
    }
  }
}
</code></pre>
<h3 id="8router-link的-replace-属性">8.<code>&lt;router-link&gt;</code>的 replace 属性</h3>
<ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9编程式路由导航">9.编程式路由导航</h3>
<ol>
<li>
<p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-js">//$router的两个API
this.$router.push({
  name: &quot;xiangqing&quot;,
  params: {
    id: xxx,
    title: xxx,
  },
});

this.$router.replace({
  name: &quot;xiangqing&quot;,
  params: {
    id: xxx,
    title: xxx,
  },
});
this.$router.forward(); //前进
this.$router.back(); //后退
this.$router.go(); //可前进也可后退
</code></pre>
</li>
</ol>
<h3 id="10缓存路由组件">10.缓存路由组件</h3>
<ol>
<li>
<p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-vue">&lt;keep-alive include=&quot;News&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
</li>
</ol>
<h3 id="11两个新的生命周期钩子">11.两个新的生命周期钩子</h3>
<ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：
<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12路由守卫">12.路由守卫</h3>
<ol>
<li>
<p>作用：对路由进行权限控制</p>
</li>
<li>
<p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li>
<p>全局守卫:</p>
<pre><code class="language-js">//全局前置守卫：初始化时执行、每次路由切换前执行
router.beforeEach((to, from, next) =&gt; {
  console.log(&quot;beforeEach&quot;, to, from);
  if (to.meta.isAuth) {
    //判断当前路由是否需要进行权限控制
    if (localStorage.getItem(&quot;school&quot;) === &quot;atguigu&quot;) {
      //权限控制的具体规则
      next(); //放行
    } else {
      alert(&quot;暂无权限查看&quot;);
      // next({name:'guanyu'})
    }
  } else {
    next(); //放行
  }
});

//全局后置守卫：初始化时执行、每次路由切换后执行
router.afterEach((to, from) =&gt; {
  console.log(&quot;afterEach&quot;, to, from);
  if (to.meta.title) {
    document.title = to.meta.title; //修改网页的title
  } else {
    document.title = &quot;vue_test&quot;;
  }
});
</code></pre>
</li>
<li>
<p>独享守卫:</p>
<pre><code class="language-js">beforeEnter(to,from,next){
 console.log('beforeEnter',to,from)
 if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
   if(localStorage.getItem('school') === 'atguigu'){
     next()
   }else{
     alert('暂无权限查看')
     // next({name:'guanyu'})
   }
 }else{
   next()
 }
}
</code></pre>
</li>
<li>
<p>组件内守卫：</p>
<pre><code class="language-js">//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) {
},
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) {
}
</code></pre>
</li>
</ol>
<h3 id="13路由器的两种工作模式">13.路由器的两种工作模式</h3>
<ol>
<li>对于一个 url 来说，什么是 hash 值？—— #及其后面的内容就是 hash 值。</li>
<li>hash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器。</li>
<li>hash 模式：
<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history 模式：
<ol>
<li>地址干净，美观 。</li>
<li>兼容性和 hash 模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题。</li>
</ol>
</li>
</ol>

            </article>
          </div>
          <div class='entry-meta-bottom'>
            <div class="entry-categories">
              <p>
                <span>Categories</span>
                
                  
                    
                  <a href="https://rowanwang6.github.io/tag/web/" title="View all posts in web">web</a>
                    
                    
                    
                  <a href="https://rowanwang6.github.io/tag/CV/" title="View all posts in Computer Vison">Computer Vison</a>
                    
                    
                    
                  <a href="https://rowanwang6.github.io/tag/myself/" title="View all posts in Myself">Myself</a>
                    
                    
              </p>
            </div>
            <div class="entry-tags">
              <p><span>Tags</span>
              </p>
            </div>
          </div>
          <div class="author-meta">
            <div class="author">
              <img alt='' src="https://rowanwang6.github.io/images/avatar.png?v=1695113523701" class='avatar avatar-72 photo' height='72' width='72'>
              <span>WRITTEN BY: &nbsp;&nbsp;&nbsp;<a href='https://rowanwang6.github.io'>Rowan</a> </span>
            </div>
            <div class="bio">
              <p>Hi! Hope you enjoy my sharing. If there is any error or advice, please inform me.</p>
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
            </div>
          </div>
        </div>
          
            <nav class="navigation pagination" role="navigation">
              <h2 class="screen-reader-text">Posts navigation</h2>
              <div class="nav-links">
                <a class="next page-numbers" href="https://rowanwang6.github.io/post/javascript/">下一篇->JavaScript</a>
              </div>
            </nav>
          
      </div>
      <section id="comments" class="comments">
        
      </section>
    </div>
  </div>
  <footer id="site-footer" class="site-footer" role="contentinfo">
    <h1>
        <a href="https://rowanwang6.github.io"> Rowan&#39;s Page </a>
    </h1>
    <p class="site-description"></p>
    <div id="menu-footer" class="menu-container menu-footer" role="navigation">
        <div class="menu">
            <ul id="menu-footer-items" class="menu-footer-items">
            </ul>
        </div>
    </div>
    <ul class="social-media-icons">
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
            
        
    </ul>
    <div class="design-credit">
        <p>xkwang7-c@my.cityu.edu.hk</p>
    </div>
</footer>
<script>
    hljs.initHighlightingOnLoad()
</script>
<script src="https://rowanwang6.github.io/media/scripts/lib/jquery.min.js"></script>
<script src="https://rowanwang6.github.io/media/scripts/lib/jquerymigrate.js"></script>
<script src="https://rowanwang6.github.io/media/scripts/lib/production.min.js"></script>

</div>
</body>
</html>

