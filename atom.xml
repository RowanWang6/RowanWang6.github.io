<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rowanwang6.github.io</id>
    <title>Rowan&apos;s Page</title>
    <updated>2023-09-19T08:52:21.575Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rowanwang6.github.io"/>
    <link rel="self" href="https://rowanwang6.github.io/atom.xml"/>
    <logo>https://rowanwang6.github.io/images/avatar.png</logo>
    <icon>https://rowanwang6.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Rowan&apos;s Page</rights>
    <entry>
        <title type="html"><![CDATA[BOC Training Camp]]></title>
        <id>https://rowanwang6.github.io/post/boc-training-camp/</id>
        <link href="https://rowanwang6.github.io/post/boc-training-camp/">
        </link>
        <updated>2023-09-15T03:22:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="html">HTML</h1>
<h2 id="1-html概览">1. HTML概览</h2>
<ul>
<li>
<p>我们常用的 HTML 标签有哪些？</p>
<p><code>div a p span img </code></p>
</li>
<li>
<p>不同的 HTML 标签代表了什么含义？</p>
<p>容器、超链接、段落等</p>
</li>
<li>
<p>常用的 HTML 标签属性都有哪些？</p>
<p><code>class id src href</code></p>
</li>
</ul>
<h2 id="2-结构标签">2. 结构标签</h2>
<h4 id="doctype-标签">DOCTYPE 标签</h4>
<p><code>&lt;!DOCTYPE html&gt;</code> 就是通过 html 来告知浏览器这是一个什么类型的文档，一般它里面会包含 head 标签和 body 标签，用来标识文档的头部和主体。另外，如果在 html 根元素上定义了 lang 属性，就表示要为当前文档设置语言，这个操作更加利于语音及翻译工具明确在工作时要遵循的规则。</p>
<h4 id="head">head</h4>
<p>HTML 头部标签，用来描述文档的各种属性和信息及其相关的应用资源，它里面一般会包含 meta、title、link 及 script 子标签。</p>
<h4 id="meta">meta</h4>
<p>元信息，多用来设置文档的编码或者针对搜素引擎的描述和关键词，再或者一些关于当前文档在手机端上如何显示的设置。</p>
<pre><code class="language-html">&lt;!-- 编码格式 --&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;

&lt;!-- 描述、关键字 --&gt;
&lt;meta name=&quot;Keywords&quot; content=&quot;关键字1,关键字2,关键字3,关键字4&quot; /&gt;
&lt;meta name=&quot;Description&quot; content=&quot;网页描述&quot; /&gt;

&lt;!-- 让浏览器优先选择指定内核渲染 --&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt;

&lt;!--设置在手机上按照1:1缩放 --&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;  

&lt;!-- 针对苹果手机的信息设置 --&gt;
&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; 

&lt;!-- 网站开启对 web app 程序支持 --&gt;  
&lt;!--在 web ap 应用下状态条（屏幕顶部）的颜色，默认值为default（白色）--&gt;       
&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt;

&lt;!--将网页内容中的手机号码显示为拨号的超链接--&gt;
&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;

</code></pre>
<h4 id="body">body</h4>
<p>文档内容标签，想在浏览器窗口中最终展示的内容就在这里书写。</p>
<h4 id="header-footer">header、footer</h4>
<p>header 标签用于定义文档或节的页眉；footer 标签用于定义文档或节的页脚。</p>
<h4 id="script">script</h4>
<p>script 标签用于在 HTML 文档中插入一段 JavaScript 代码，一般放置在 body 标签的底部，在 src 属性中写入具体的代码位置。</p>
<h2 id="3-文本标签">3. 文本标签</h2>
<h2 id="4-资源标签">4. 资源标签</h2>
<h2 id="5-表格标签">5. 表格标签</h2>
<h4 id="常用表格标签">常用表格标签</h4>
<table>
<thead>
<tr>
<th style="text-align:center">标签属性</th>
<th style="text-align:center">属性说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">定义表格元素</td>
</tr>
<tr>
<td style="text-align:center">tr</td>
<td style="text-align:center">定义表格中的行</td>
</tr>
<tr>
<td style="text-align:center">th</td>
<td style="text-align:center">定义表格中表头单元格</td>
</tr>
<tr>
<td style="text-align:center">td</td>
<td style="text-align:center">定义表格中标准单元格</td>
</tr>
</tbody>
</table>
<h2 id="6-表单标签">6. 表单标签</h2>
<h4 id="form">form</h4>
<p>form 就是表单标签，用于定义表单，其主要包含 action和 method 两个属性。</p>
<ul>
<li>action 用于指定提交到服务器上的URL</li>
<li>method 用于指定提交方式，一般为 POST</li>
</ul>
<h4 id="input">input</h4>
<p>input 为用户输入内容的标签，根据其 type 属性不同，其输入的形态也不一样，比如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">常用属性</th>
<th style="text-align:center">常用 type 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">type 输入类型</td>
<td style="text-align:center">text 文本输入</td>
</tr>
<tr>
<td style="text-align:center">name 输入名称</td>
<td style="text-align:center">number 数字输入</td>
</tr>
<tr>
<td style="text-align:center">value 输入值</td>
<td style="text-align:center">password 密码输入</td>
</tr>
<tr>
<td style="text-align:center">placeholder 预显示字段</td>
<td style="text-align:center">radio 单选</td>
</tr>
<tr>
<td style="text-align:center">disabled 是否被禁用</td>
<td style="text-align:center">checkbox 多选</td>
</tr>
<tr>
<td style="text-align:center">readonly 是否只读</td>
<td style="text-align:center">color 颜色输入</td>
</tr>
<tr>
<td style="text-align:center">required 是否必填</td>
<td style="text-align:center">email 邮箱输入</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">range 范围输入</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">date 日期输入</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">submit 提交</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">hidden 隐藏</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">reset 重设</td>
</tr>
</tbody>
</table>
<h2 id="7-挑战1">7. 挑战1</h2>
<h1 id="css">CSS</h1>
<h2 id="1-css基础">1. CSS基础</h2>
<h4 id="css-规则">CSS 规则</h4>
<p>每个编程语言都会有自己的语法规则，CSS 自然也不例外，一个 CSS 规则由选择器和属性组组成：</p>
<ul>
<li>选择器，用来选择需要添加样式的元素；</li>
<li>在属性组中，每一个属性和属性值的组合可以设置 HTML 内容的样式。比如，我想让元素字体颜色变为红色，那么就可以设置一个属性组 color: red （其中 color 是属性，red 就是属性值）。</li>
</ul>
<h4 id="css-使用方法">CSS 使用方法</h4>
<p>CSS 的使用方式有三种不同的方式：内嵌式、内联式 、外联式。这里先简单了解，后面会有具体应用。</p>
<ul>
<li>内嵌：通过元素的 style 属性把样式内容书写在元素上。</li>
</ul>
<pre><code>&lt;span style=&quot;font-size: 15px; color: #FFF;&quot;&gt;Hello World&lt;/style&gt;
&lt;h1 style=&quot;font-family: Arial;&quot;&gt;Hello World&lt;/h1&gt;
</code></pre>
<ul>
<li>内联：通过 style 标签，将样式内容书写在页面中，<strong>并且 style 标签的位置一般放置在 head 结束标签之前。</strong></li>
</ul>
<pre><code>&lt;head&gt;
&lt;style type=&quot;text/css&quot;&gt;
body {background-color:yellow;}
p {color:blue;}
&lt;/style&gt;
&lt;/head&gt;
</code></pre>
<ul>
<li>外联：通过引用外部的 CSS 文件，将样式引入当前文档中进行使用。当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。</li>
</ul>
<pre><code>&lt;head&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;
&lt;/head&gt;
</code></pre>
<p><strong>在实际开发过程中，为了实现结构与样式的分离标准，使代码更加清晰直观，建议统一使用外联式来书写 CSS 代码。</strong></p>
<h4 id="css-单位">CSS 单位</h4>
<p>网页样式设置中肯定会涉及宽高大小等，所以 CSS 当中是需要有单位概念的，可以分为长度单位和颜色单位。</p>
<p>长度单位又分为绝对单位和相对单位：</p>
<ul>
<li>绝对单位是指与屏幕像素点保持绝对一致，我们使用得最多的是绝对单位 px，也就是像素。</li>
<li>相对单位是指屏幕像素点与屏幕大小的等比例单位值，有 em 和 rem。</li>
</ul>
<p>颜色单位使用最多的有 Hex 、rgb 和 rgba：</p>
<ul>
<li>rgb 和 rgba 不同地方在于，rgba 是在 rgb 的基础上多了一个颜色透明度的参数值；</li>
<li>而在没有透明度的颜色上建议使用 Hex 色值；</li>
<li>在有透明度的颜色上建议使用 rgba。</li>
</ul>
<h4 id="样式重设">样式重设</h4>
<p>由于不同的浏览器的默认样式都不同，这导致我们编写的样式代码在不同浏览器上会有不一样的展示，也就是所谓的<strong>浏览器样式兼容性</strong>。因此，在页面开发时，我们需要对所有浏览器的默认样式进行统一设定，这样就可以避免出现相同代码在不同浏览器上展示效果不一致的现象。</p>
<p>当然，现在有很多专门用于实现样式重置的解决方案，主流的就有 Normalize、Reset 和通配符设置法。</p>
<ul>
<li>Normalize.css 保护了有价值的默认值，而 Reset 则是用来为几乎所有元素添加默认样式的方式，强行使元素有相同的视觉效果。所以相比之下，Normalize.css 保持了更多浏览器的默认样式。这就意味着，你不用再为所有的公共元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时，Normalize.css 会力求让这些样式保持一致，并尽可能与开发标准相符合。</li>
<li>Reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。</li>
<li>通配符设置，使用通配符 * 选择器把浏览器中所有的元素都统一设置。</li>
</ul>
<p><strong>那么在开发当中我们该如何选择呢？</strong></p>
<ul>
<li>如果我们需要 1:1 还原设计稿，那么就要对页面样式进行精准控制，所以建议使用 Reset，这样就能去除多余的样式，更方便计算。</li>
<li>如果在项目中需要灵活插入文本内容，或者在大型项目中涉及多个页面，存在富文本内容插入的区域，此时就建议保留内容的默认样式，一般使用 Normalize.css。</li>
<li>在我们的教学示例中，我们对样式的要求并不特别高，可以使用通配符快速完成重置设置。</li>
</ul>
<h2 id="2-css选择器">2. CSS选择器</h2>
<p>CSS 的选择器是一种组合模式，可以选取到需要组合，进行元素(标签)样式的控制。下面的表格展示了不同的选择器及使用方式，不同的选择器可以任意组合使用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">选择器类型</th>
<th style="text-align:center">使用方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通配符选择器</td>
<td style="text-align:center">（ * ）</td>
</tr>
<tr>
<td style="text-align:center">元素选择器</td>
<td style="text-align:center">（ element )</td>
</tr>
<tr>
<td style="text-align:center">class 选择器</td>
<td style="text-align:center">（ .class )</td>
</tr>
<tr>
<td style="text-align:center">id 选择器</td>
<td style="text-align:center">（ #id ）</td>
</tr>
<tr>
<td style="text-align:center">后代选择器</td>
<td style="text-align:center">（Ｅ Ｆ）</td>
</tr>
<tr>
<td style="text-align:center">子元素选择器</td>
<td style="text-align:center">( E &gt; F )</td>
</tr>
<tr>
<td style="text-align:center">相邻兄弟元素选择器</td>
<td style="text-align:center">( E + F )</td>
</tr>
<tr>
<td style="text-align:center">通用兄弟选择器</td>
<td style="text-align:center">（ Ｅ 〜 Ｆ ）</td>
</tr>
<tr>
<td style="text-align:center">群组选择器</td>
<td style="text-align:center">（selector1,…,selectorN）</td>
</tr>
<tr>
<td style="text-align:center">属性选择器</td>
<td style="text-align:center">( E[attr] )</td>
</tr>
<tr>
<td style="text-align:center">否定选择器</td>
<td style="text-align:center">（ :not(E) ）</td>
</tr>
<tr>
<td style="text-align:center">动态伪类选择器</td>
<td style="text-align:center">（ :hover ）</td>
</tr>
<tr>
<td style="text-align:center">伪元素选择器</td>
<td style="text-align:center">（ :before ）</td>
</tr>
<tr>
<td style="text-align:center">:nth选择器</td>
<td style="text-align:center">:nth（ :an+b ）</td>
</tr>
</tbody>
</table>
<p>上述的选择器，代表了不同的选择方式，我们可以使用这些不同的选择器具体操作某个元素（标签），也可以进行组合使用。下面我们就对不同的选择器的不同使用方式，进行逐个讲解。</p>
<h4 id="页面准备">页面准备</h4>
<p>首先我们要新建一个 HTML 文档，使用 style 标签在当前页面中设置样式代码，然后使用以下 CSS 命令来查看不同选择器带来的样式呈现。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;CSS Select&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;ul&gt;
      &lt;li data=&quot;attr-data&quot;&gt;1&lt;/li&gt;
      &lt;li class=&quot;klass&quot;&gt;2&lt;/li&gt;
      &lt;li class=&quot;klass&quot;&gt;3&lt;/li&gt;
      &lt;li id=&quot;testID&quot;&gt;4&lt;/li&gt;
      &lt;li&gt;&lt;span&gt;5&lt;/span&gt;&lt;/li&gt;
      &lt;li&gt;&lt;span&gt;6&lt;/span&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在浏览器中打开这个 HTML 文档后，我们可以看到到浏览器的一些默认样式，例如 margin 和 padding 属性带来的默认边距。页面准备好之后，就可以使用选择器来控制元素了。</p>
<h4 id="通配符选择器">通配符选择器（ * ）</h4>
<p>通配符选择器可以选择所有元素，也可以选择某个元素下的所有元素（这里的元素是指标签）。在不同的浏览器下，不同元素默认的内外边距都是不同的。</p>
<p>下面我们就使用通配符来选中所有元素， 然后利用 CSS 将内外边距的值设置为零，最后就会发现界面上的 1～6 在展示时就不再存有默认的上下间距了。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;CSS Select&lt;/title&gt;
  &lt;style&gt;
    * {
      margin: 0;
      padding: 0;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;ul&gt;
    &lt;li data=&quot;attr-data&quot;&gt;1&lt;/li&gt;
    &lt;li class=&quot;klass&quot;&gt;2&lt;/li&gt;
    &lt;li class=&quot;klass&quot;&gt;3&lt;/li&gt;
    &lt;li id=&quot;testID&quot;&gt;4&lt;/li&gt;
    &lt;li&gt;&lt;span&gt;5&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt;6&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h4 id="元素选择器element">元素选择器（element)</h4>
<p>下面的实例用来演示如何选择 body 元素并设置一个浅灰色背景。</p>
<pre><code>body{
    background: #f1f1f1;
}
</code></pre>
<h4 id="class-选择器class">class 选择器（.class）</h4>
<p>下面的语法表示选中 class 属性值为 klass 的所有元素，然后将这些元素们的字体颜色设置为红色。</p>
<pre><code>.klass{
    color: red;
}
</code></pre>
<h4 id="id选择器-id">id选择器 （#id）</h4>
<p>选择 id=“testID” 的元素，如下设置 id 的元素颜色为蓝色。</p>
<pre><code>#testID{
    color: blue;
}
</code></pre>
<h4 id="后代选择器e-f">后代选择器（Ｅ Ｆ）</h4>
<p>这里的 E 用来表示祖先元素（祖先元素是指包裹其他元素的元素）而 F 就是它的后代元素（后代元素是指被包裹的元素），比如以下示例表示选中 li 下所有 span 元素，并且将字体设置为绿色。</p>
<pre><code>li span{
    color: green;
}
</code></pre>
<h4 id="子元素选择器e-f">子元素选择器（E &gt; F）</h4>
<p>子元素选择器只能选择某元素的子元素，其中 E 为父元素，而 F 为子元素，其中 E&gt;F 所表示的是选择Ｅ元素下的所有子元素Ｆ。</p>
<p>这和后代选择器（Ｅ Ｆ）不一样，在后代选择器中，Ｆ是Ｅ的后代元素，而子元素选择器Ｅ &gt; F，<strong>其中Ｆ仅仅是Ｅ的子元素（隔代无法选中）。</strong></p>
<pre><code>li&gt;span{
    color: orange;
}
</code></pre>
<h4 id="相邻兄弟元素选择器e-f">相邻兄弟元素选择器（E + F）</h4>
<p>相邻兄弟选择器可以选择紧接在另一元素后的元素，而且它们具有一个相同的父元素，换句话说，EF 两元素具有一个相同的父元素，而且Ｆ元素在Ｅ元素后面，而且相邻，这样我们就可以使用相邻兄弟元素选择器来选择Ｆ元素。以下设置 id 为 testID 的下一个 li 元素的背景色。</p>
<pre><code>#testID+li{
    background: #ccc;
}
</code></pre>
<h4 id="通用兄弟选择器e-f">通用兄弟选择器（Ｅ 〜 Ｆ）</h4>
<p>通用兄弟元素选择器是 CSS3 新增加一种选择器，这种选择器将选择某元素后面的所有兄弟元素，它们也和相邻兄弟元素类似，需要在同一个父元素之中。换句话说，E 和 F 元素是属于同一父元素之内，并且 F 元素在 Ｅ 元素之后，那么 E ~ F 选择器将选择中所有 Ｅ 元素后面的 Ｆ 元素。以下设置 id 为testID 之后所有 li 元素的背景色。</p>
<pre><code>#testID~li{
    background: #ccc;
}
</code></pre>
<h4 id="群组选择器selector1selectorn">群组选择器（selector1,…,selectorN）</h4>
<p>群组选择器是将具有相同样式的元素分组在一起，每个选择器之间使用逗号“，”隔开，这个逗号告诉浏览器，规则中包含多个不同的选择器，以下设置 class=&quot;klass&quot;及 id=&quot;testID&quot;的背景色。</p>
<pre><code>#testID,.klass{
    background: #ccc;
}
</code></pre>
<h4 id="属性选择器eattr">属性选择器（E[attr]）</h4>
<p>使用 CSS3 属性选择器，你可以只指定元素的某个属性，或者你还可以同时指定元素的某个属性和其对应的属性值。</p>
<ul>
<li>E[attr]：只使用属性名，但没有确定任何属性值。</li>
<li>E[attr=“value”]：指定属性名，并指定了该属性的属性值。</li>
<li>E[attr~=“value”]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个 value 词，而且等号前面的“〜”不能不写。</li>
<li>E[attr^=“value”]：指定了属性名，并且有属性值，属性值是以 value 开头的。</li>
<li>E[attr$=“value”]：指定了属性名，并且有属性值，而且属性值是以 value 结束的。</li>
<li>E[attr*=“value”]：指定了属性名，并且有属性值，而且属值中包含了 value。</li>
<li>E[attr|=“value”]：指定了属性名，并且属性值是 value 或者以“value-”开头的值（比如说zh-cn）。</li>
</ul>
<p>以下设置有data属性的 li 元素的背景色。</p>
<pre><code>li[data]{
    background: #ccc;
}
</code></pre>
<h4 id="否定选择器-note">否定选择器（ :not(E) ）</h4>
<p>在选择的元素中排除 E 元素之后的的每个元素。以下是 li 元素中除了 id 为 testID 的元素，字体大小都为 12px。</p>
<pre><code>li:not(#testID){
    font-size: 12px;
}
</code></pre>
<h4 id="动态伪类选择器">动态伪类选择器</h4>
<p>这些伪类并不存在于 HTML 中，而只有当用户和网站交互时才能体现出来。</p>
<p>动态伪类包含两种，第一种是我们在链接中常看到的锚点伪类，如:link、:visited；另外一种被称作用户行为伪类，如<br>
:hover、:active、:focus。</p>
<ul>
<li>:link 链接没有被访问时，前景色为灰色。</li>
<li>:visited 链接被访问过后。前景色为黄色。</li>
<li>:hover 鼠标悬浮在链接上时，前景色为绿色。</li>
<li>:active 鼠标点中激活链接那一下，前景色为蓝色。</li>
<li>:focus 用于元素成为焦点，这个经常用在表单元素上。</li>
</ul>
<pre><code>li a:link{
    color: gray;
}
li a:visited{
    color: yellow;
}
li a:hover{
    color: green;;
}
li a:active{
    color: blue;
}
</code></pre>
<h4 id="伪元素选择器">伪元素选择器</h4>
<ul>
<li>::first-line（选择元素的第一行）</li>
<li>::first-letter（选择文本块的第一个字母）</li>
<li>::before （给元素的前面<strong>插入</strong>内容，无content内容就不会有反应）</li>
<li>::after （给元素的后面<strong>插入</strong>内容，无content内容就不会有反应）</li>
</ul>
<pre><code>#testID::before{
    content: 'A'
}
#testID::after{
    content: 'D'
}
#testID::first-letter{
    color: #333;
}
#testID::first-line{
    background: #f1f1f1;
}
</code></pre>
<h4 id="nth选择器">:nth选择器</h4>
<ul>
<li>:first-child，选择某个元素的第一个子元素</li>
<li>:last-child，选择某个元素的最后一个子元素</li>
<li>:nth-child(n)，选择某个元素的一个或多个特定的子元素</li>
<li>:nth-last-child(n)，选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算</li>
<li>:nth-of-type(n)，选择指定的元素</li>
<li>:nth-last-of-type(n)，选择指定的元素，从元素的最后一个开始计算</li>
<li>:first-of-type，选择一个上级元素下的第一个同类子元素</li>
<li>:last-of-type，选择一个上级元素的最后一个同类子元素</li>
<li>:only-child，选择的元素是它的父元素的唯一一个子元素</li>
<li>:only-of-type，选择一个元素是它的上级元素的唯一一个相同类型的子元素</li>
<li>:empty，选择的元素里面没有任何内容</li>
</ul>
<p>(n)可使用公式 (an + b)。描述：表示周期的长度，n 是计数器（从 0 开始），b 是偏移值。</p>
<pre><code>li:first-child::after{
    content: 'first-child'
}
li:last-child::after{
    content: 'last-child'
}
li:nth-child(4){
    font-size: 12px;
}
</code></pre>
<p>在了解了 CSS 中各类选择器之后，接下来我们就通过一段代码来进行语法练习。</p>
<h4 id="语法练习">语法练习</h4>
<p>可以通过以下代码，进一步了解 CSS 中各类选择器。</p>
<ul>
<li>HTML 结构</li>
</ul>
<pre><code>&lt;div class=&quot;gird-list&quot;&gt;
  &lt;div class=&quot;gird-item&quot;&gt;1&lt;/div&gt;
  &lt;div class=&quot;gird-item&quot;&gt;2&lt;/div&gt;
  &lt;div class=&quot;gird-item&quot;&gt;3&lt;/div&gt;
  &lt;div class=&quot;gird-item&quot;&gt;4&lt;/div&gt;
  &lt;div class=&quot;gird-item&quot;&gt;5&lt;/div&gt;
  &lt;div class=&quot;gird-item&quot;&gt;6&lt;/div&gt;
  &lt;div class=&quot;gird-item&quot;&gt;7&lt;/div&gt;
  &lt;div class=&quot;gird-item&quot;&gt;8&lt;/div&gt;
  &lt;div class=&quot;gird-item&quot;&gt;9&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>CSS 样式</li>
</ul>
<pre><code>/*定义容器大小、居中*/
.gird-list{
  margin: 100px auto 0;
  width: 600px;
  height: 600px;
  background: #f1f1f1;
  font-size: 0;
}
/*所有项目*/
.gird-item{
  display: inline-block;
  box-sizing: border-box;
  width: 200px;
  height: 200px;
  font-size: 12px;
  border-top: 1px solid #333;
  border-left: 1px solid #333;
}
/*所有序号以3为倍数的元素*/
.gird-item:nth-child(3n){
  border-right: 1px solid #333;
}
/*从第7个开始所有项目*/
.gird-item:nth-child(n + 7){
  border-bottom: 1px solid #333;
}
/*第5个项目*/
.gird-item:nth-child(5){
  background: #666;
}
/*第1个项目*/
.gird-item:first-child{
  background: #666;
}
/*最后1个项目*/
.gird-item:last-child{
  background: #666;
}
/*第3个项目且鼠标悬浮的时候*/
.gird-item:nth-child(3):hover{
  background: #999;
}
</code></pre>
<h4 id="逗号分隔选择器">逗号分隔选择器</h4>
<p>当两个选择器之间有空格的情况下，代表的是子类选择器。.a .b{} 代表的是 b 类是 a 的子类。而两个选择器之间没有空格的情况下，代表的是同时拥有两个类名的标签。</p>
<pre><code>&lt;div class=&quot;a b&quot;&gt;&lt;/div&gt;
.a .b{}
</code></pre>
<p>当两个选择器之间是逗号的情况下，代表的两个并列的类选择器。</p>
<pre><code>&lt;div class=&quot;a&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;b&quot;&gt;&lt;/div&gt;
.a,.b{}
</code></pre>
<p>在使用选择器时，不同的选择器可能会作用在同一个元素上，那么这种情况下，哪个选择器会起作用呢？这就需要有一定的优先级规则了，也就是不同的选择器的权重问题，接下来，我们一起看一下 CSS 的权重问题。</p>
<h4 id="权重比较">权重比较</h4>
<p>CSS 的权重可以分为 6 级：</p>
<table>
<thead>
<tr>
<th style="text-align:center">级别</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第一级</td>
<td style="text-align:center">!important 无穷大；它的权重最高； 正无穷</td>
</tr>
<tr>
<td style="text-align:center">第二级</td>
<td style="text-align:center">内嵌样式(style)；1000</td>
</tr>
<tr>
<td style="text-align:center">第三级</td>
<td style="text-align:center">id选择器；100</td>
</tr>
<tr>
<td style="text-align:center">第四级</td>
<td style="text-align:center">类选择器，伪类选择器；10</td>
</tr>
<tr>
<td style="text-align:center">第五级</td>
<td style="text-align:center">标签选择器。伪元素选择器; 1</td>
</tr>
<tr>
<td style="text-align:center">第六级</td>
<td style="text-align:center">继承的样式，*通配符的样式。 0</td>
</tr>
</tbody>
</table>
<p>它们的权重依次降低，那么当出现多个选择器时，在同一行的选择器权重相加即可；<strong>当两个混合选择器权重相同时优先选择后面的选择器。</strong></p>
<h2 id="3-文本样式">3. 文本样式</h2>
<h4 id="html-结构">HTML 结构</h4>
<p>以下 HTML 结构为示范：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Text Select&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;text-test.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p class=&quot;text-test&quot;&gt;技术成就梦想之美&lt;/p&gt;
&lt;/body&gt;
</code></pre>
<h4 id="文字颜色">文字颜色</h4>
<p>定义文本颜色可以为：HexColor（十六进制颜色值），如 #ff00ff ；rgb &amp; rgba；hsl &amp; hsla，比如下面这段代码：</p>
<pre><code>.text-test{
    color: #35b558;
}
</code></pre>
<h4 id="字体">字体</h4>
<p>在字体中包括了字体尺寸、字体族、字体风格、字体粗细等。</p>
<p><strong>尺寸（font-size）</strong>：定义字体大小，单位可以为 px 、 em 、 rem ，有以下几个取值选项。</p>
<ul>
<li>绝对值 xx-small | x-small | small | medium | large | x-large | xx-large；</li>
<li>相对值 larger | smaller；</li>
<li>长度；</li>
<li>百分数，相对父元素计算值，以父级元素为基础进行等比例设置。</li>
</ul>
<pre><code>.text-test{
  font-size: 24px;
}
</code></pre>
<p><strong>字体族（font-family）</strong>：字体族是不同的一类字体样式，具有某种共同的样式特征，如下所示。</p>
<ul>
<li>使用英文逗号分隔字体族名称；</li>
<li>初始值由浏览器设置决定，可继承；</li>
<li>字体族名称可指定的具体字体的名称，比如&quot;times&quot;、“courier”、“arial”；</li>
<li>字体族名称可指定通常字体系列名称，比如：“serif”、“sans-serif”、“cursive”、“fantasy”、“monospace”；</li>
<li>英文字体放在中文字体的前面；</li>
<li>最后总是添加通用字体族；</li>
</ul>
<h4 id="通常字体族">通常字体族</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">serif(衬线体)</td>
<td style="text-align:center">衬线体有爪形的衬线并且笔划粗细有变化</td>
<td style="text-align:center">Centaur,Garamond,Caslon,Baskerville,Didot,Bodoni</td>
</tr>
<tr>
<td style="text-align:center">sans-serif(无衬线体)</td>
<td style="text-align:center">完全抛弃装饰衬线，笔画粗细对比小，x高度较高</td>
<td style="text-align:center">Helvetica,Franklin Gothic,Futura,Gill Sans,Optima,Univers,Myriad,Avenir</td>
</tr>
<tr>
<td style="text-align:center">cursive(手写体)</td>
<td style="text-align:center">一般具有连笔(joining strokes)或者其它除斜体字体外的手写特征</td>
<td style="text-align:center">Comic Sans MS</td>
</tr>
<tr>
<td style="text-align:center">fantasy(幻想体)</td>
<td style="text-align:center">主要是装饰性的，但仍然具有字符表现(与不表现字符的 Pi 或者Picture字体相反)</td>
<td style="text-align:center">Bodoni Ornaments</td>
</tr>
<tr>
<td style="text-align:center">monospace(等宽体)</td>
<td style="text-align:center">所有字形都具有相等的固定宽度</td>
<td style="text-align:center">Menlo</td>
</tr>
</tbody>
</table>
<p>那么在一个字体族中，如何选择具体的字体样式呢？这就要涉及匹配算法了。</p>
<h4 id="字体的匹配算法">字体的匹配算法</h4>
<ol>
<li>浏览器会先获取一个系统字体列表</li>
<li>对元素中每一个字符，使用 font-family 属性及其他属性进行匹配，如果能匹配就暂定该字体</li>
<li>如果步骤 2 没有匹配上，选择下一个可选的 font-family 执行步骤 2</li>
<li>如果匹配到一个字体，但是字体中没有该字符，继续对下一个可选 font-family 执行步骤 2</li>
<li>如果没有匹配到字体，使用浏览器默认字体</li>
</ol>
<pre><code>.text-test{
    font-size: 24px;
    font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;
}
</code></pre>
<p><strong>风格（font-style）</strong></p>
<p>定义字体的风格有：默认值标准体、斜体、倾斜体</p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">normal</td>
<td style="text-align:center">浏标准的字体样式（ 默认值 ）</td>
</tr>
<tr>
<td style="text-align:center">italic</td>
<td style="text-align:center">斜体的字体样式</td>
</tr>
<tr>
<td style="text-align:center">oblique</td>
<td style="text-align:center">倾斜的字体样式</td>
</tr>
<tr>
<td style="text-align:center">inherit</td>
<td style="text-align:center">从父元素继承字体样式</td>
</tr>
</tbody>
</table>
<p><strong>粗细（font-weight）</strong></p>
<p>定义文字的粗细程度，取值为：normal | bold | bolder | lighter | 100 | 200 | … | 900</p>
<table>
<thead>
<tr>
<th style="text-align:center">数值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">Thin</td>
</tr>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:center">Extra Light(Ultra Light)</td>
</tr>
<tr>
<td style="text-align:center">300</td>
<td style="text-align:center">Light</td>
</tr>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:center">Normal</td>
</tr>
<tr>
<td style="text-align:center">500</td>
<td style="text-align:center">Medium</td>
</tr>
<tr>
<td style="text-align:center">600</td>
<td style="text-align:center">Semi Bold(Demi Bold)</td>
</tr>
<tr>
<td style="text-align:center">700</td>
<td style="text-align:center">Bold</td>
</tr>
<tr>
<td style="text-align:center">800</td>
<td style="text-align:center">Extra Bold(Ultra Bold)</td>
</tr>
<tr>
<td style="text-align:center">900</td>
<td style="text-align:center">Black(Heavy)</td>
</tr>
</tbody>
</table>
<p>比如font-weight:400; // 把某元素的粗细程度定义为正常，注意：font-weight 的值在之后的开发中，使用数值表示。</p>
<p><strong>字体样式（font）</strong></p>
<p>可以按顺序设置如下属性：</p>
<ol>
<li>font-style</li>
<li>font-variant</li>
<li>font-weight</li>
<li>font-size/line-height</li>
<li>font-family</li>
</ol>
<p>可以不设置其中的某个值，比如 font:100% verdana; 也是允许的。未设置的属性会使用其默认值，例如小米官网的字体设置：</p>
<pre><code>font: 14px/1.5 &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Heiti SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;
</code></pre>
<h4 id="行高">行高</h4>
<p>行高是指元素所属 line box 所占有的高度，它的初始值为 normal，取值有长度、数字、百分比，其中段落一般取值为 1.4 ～ 1.8，就像下述代码呈现的样子。</p>
<pre><code>.text-test{
    font-size: 24px;
    font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;
    line-height: 1.5;
}
</code></pre>
<p>另外，如果你想进行单行文本垂直居，当高为 height 为 40px 的时候，你可以设置字体的行高和高相等 line-height 40px，这样文字就会在这个 40px 的高度中居中。</p>
<h4 id="对齐">对齐</h4>
<p>定义文本在容器中的对齐方式，初始值由 HTML 的 dir 属性决定，可继承，具体的对齐方式如下表所示，表格中展示了不同的对齐方式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">取值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">left</td>
<td style="text-align:center">左对齐</td>
</tr>
<tr>
<td style="text-align:center">right</td>
<td style="text-align:center">右对齐</td>
</tr>
<tr>
<td style="text-align:center">center</td>
<td style="text-align:center">居中</td>
</tr>
<tr>
<td style="text-align:center">justify</td>
<td style="text-align:center">两端对齐</td>
</tr>
</tbody>
</table>
<pre><code>.text-test{
  text-align: center; // 文本在容器中居中
}
</code></pre>
<h4 id="间距">间距</h4>
<p>定义字符之间的距离，比如下面这段代码。</p>
<pre><code>.text-test{
  letter-spacing: .5px;
}
</code></pre>
<h4 id="缩进">缩进</h4>
<p>指定文本缩进，取值 length 或者 percentage，初始值为 0。</p>
<pre><code>.text-test{
  text-indent: 20px;
}
</code></pre>
<h4 id="装饰效果">装饰效果</h4>
<p>定义文本的一些装饰效果，如下划线、删除线等，具体使用方式如下表所示，可以展示不同不同的装饰效果。</p>
<table>
<thead>
<tr>
<th style="text-align:center">取值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">none</td>
<td style="text-align:center">没有</td>
</tr>
<tr>
<td style="text-align:center">underline</td>
<td style="text-align:center">下划线</td>
</tr>
<tr>
<td style="text-align:center">line-through</td>
<td style="text-align:center">中划线</td>
</tr>
<tr>
<td style="text-align:center">overline</td>
<td style="text-align:center">上划线</td>
</tr>
</tbody>
</table>
<pre><code>a {
    text-decoration: none;
}
</code></pre>
<h4 id="空白符处理">空白符处理</h4>
<p>HTML 展示空白符的策略会把连续的空白符号合成一个，再换行不会直接换行。white-space 就是指定空白符该如何处理，比如<code>white-space: nowrap; //</code>文字不换行。</p>
<table>
<thead>
<tr>
<th style="text-align:center">取值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">normal</td>
<td style="text-align:center">正常行为</td>
</tr>
<tr>
<td style="text-align:center">nowrap</td>
<td style="text-align:center">不换行</td>
</tr>
<tr>
<td style="text-align:center">pre</td>
<td style="text-align:center">换行</td>
</tr>
</tbody>
</table>
<h4 id="单词换行">单词换行</h4>
<p>指定是否允许单词中间换行，比如 word-break: break-all 则表示允许在一个完整的单词内进行换行。</p>
<table>
<thead>
<tr>
<th style="text-align:center">取值</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">normal</td>
<td style="text-align:center">正常行为</td>
</tr>
<tr>
<td style="text-align:center">break-all</td>
<td style="text-align:center">允许在单词内换行</td>
</tr>
<tr>
<td style="text-align:center">keep-all</td>
<td style="text-align:center">只能在半角空格或连字符处换行</td>
</tr>
</tbody>
</table>
<h4 id="自定义字体">自定义字体</h4>
<p>除了电脑中自带的一些常见字体之外，在网页中的字体也可以自定义，就类似手机主题一样，但是我们自己制作一套字体难度是非常大的。</p>
<p>不过无所不能的网友们，已经制作了很多好看的字体并分享出来了，比如 Iconfont 就是国内功能很强大且图标内容很丰富的矢量图标库，提供矢量图标下载、在线存储、格式转换等功能。</p>
<p>它由阿里巴巴体验团队倾力打造，设计和前端开发的便捷工具。其中，就有非常多的网友上传的自定义字体，我们可以进行下载并使用。当然，大部分情况下，为了适应大部分网友的查看，网页还是尽量使用常见的字体进行展示，如宋体、微软雅黑等。</p>
<h2 id="4-背景样式">4. 背景样式</h2>
<h4 id="背景">背景</h4>
<p>定义元素的背景颜色、图片的展现形式，缩写：</p>
<pre><code>background: color img_url repeat attachment position / size;
background: #f00 url(background.jpg) no-repeat fixed 0 0 / 50px 50px;
</code></pre>
<p>如果不设置其中的某个值，也是允许的，例如：</p>
<pre><code>background: #f00;
</code></pre>
<blockquote>
<p>小提示：在首页的全屏 banner 中，一般使用 background 实现。</p>
</blockquote>
<p>在具体操作之前，我们先来认识一下要学习和使用到的具体知识点，不同的背景操作，需要使用不同的属性知识点，其中属性知识点有：</p>
<ul>
<li>背景颜色 background-color</li>
<li>背景图片 background-image</li>
<li>背景重复 background-repeat</li>
<li>背景定位 background-attachment</li>
<li>背景位置 background-position</li>
<li>背景大小 background-size</li>
<li>定位方式 background-origin</li>
<li>背景区域 backgrouind-clip</li>
</ul>
<p>接下来，我们具体来看上面的这些属性，到底如何使用。</p>
<h4 id="背景颜色-color">背景颜色 color</h4>
<p>含义就是定义背景的颜色，代码如下，你可以在浏览器看一下到底展示了哪种颜色的背景：</p>
<pre><code>background-color: #f5f5f5;
</code></pre>
<h4 id="背景图片-image">背景图片 image</h4>
<p>使用一个图片，作为页面的背景使用</p>
<pre><code>background-image: url(background.jpg); //图片
</code></pre>
<h4 id="背景重复">背景重复</h4>
<p>repeat 定义背景重复方式，默认值为 repeat 水平和垂直重复。具体见下表，可以实现其他不同的重复方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">repeat</td>
<td style="text-align:center">垂直和水平方向重复</td>
</tr>
<tr>
<td style="text-align:center">repeat-x</td>
<td style="text-align:center">水平方向重复</td>
</tr>
<tr>
<td style="text-align:center">repeat-y</td>
<td style="text-align:center">垂直方向重复</td>
</tr>
<tr>
<td style="text-align:center">no-repeat</td>
<td style="text-align:center">背景图像将仅显示一次</td>
</tr>
</tbody>
</table>
<p>比如下面这段代码的意思就是定义背景重复方式，让背景图像仅显示一次：</p>
<pre><code>background-repeat: no-repeat;
</code></pre>
<h4 id="背景定位-attachment">背景定位 attachment</h4>
<p>背景定位的意思是指，定义背景图像是否固定或者随着页面的其余部分滚动，可选值为 scroll（默认值）、fixed（固定）：</p>
<pre><code>background-attachment: fixed;
</code></pre>
<p>背景定位一般配合背景图片使用，使背景图展示内容不随着页面的其余部分滚动。</p>
<h4 id="背景位置-position">背景位置 position</h4>
<p>定义背景图像的起始位置</p>
<pre><code>background-position: center;
background-position: 10px 10px;
</code></pre>
<p>position 是需要两个值进行横纵坐标设置的，如果你仅规定了一个关键词的值，那么第二个值将默认使用 “center” 进行定义。</p>
<h4 id="背景大小-size">背景大小 size</h4>
<p>定义背景图片的尺寸，可选值为长度、百分数、cover、contain：</p>
<ul>
<li>cover，把背景图像扩展至足够大，以使背景图像完全覆盖背景区域，<strong>背景图像的某些部分也许无法显示在背景定位区域中</strong>；</li>
<li>contain，把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。</li>
</ul>
<pre><code>background-size: cover;
</code></pre>
<p>尺寸大小一样需要长宽两个值定义，长度、百分数中，如果只设置一个值，则第二个值会被默认的设置为 “auto”，也就是由浏览器选择合适的值进行展示。</p>
<h4 id="背景定位方式">背景定位方式</h4>
<p>origin origin 是在 background-position 的基础上进行操作设置的，它规定 background-position 属性相对于什么位置来定位，具体定位方式如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">border-box</td>
<td style="text-align:center">相对于边框盒来定位</td>
</tr>
<tr>
<td style="text-align:center">padding-box</td>
<td style="text-align:center">相对于内边距框来定位</td>
</tr>
<tr>
<td style="text-align:center">content-box</td>
<td style="text-align:center">相对于内容框来定位</td>
</tr>
</tbody>
</table>
<pre><code>background-origin: content-box;
</code></pre>
<p>如果背景图像的 background-attachment 属性为 “fixed”，则该属性没有效果，实际就是取消了对应的样式操作，因此不会在浏览器中有具体效果展示。</p>
<h4 id="背景区域">背景区域</h4>
<p>clip 定义对背景（图片和背景色）的切割，具体切割方式如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">border-box</td>
<td style="text-align:center">被裁切到边框盒</td>
</tr>
<tr>
<td style="text-align:center">padding-box</td>
<td style="text-align:center">被裁切到内边距框</td>
</tr>
<tr>
<td style="text-align:center">content-box</td>
<td style="text-align:center">被裁切到内容框</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意是裁切。</p>
</blockquote>
<pre><code class="language-css">background-clip: content-box; // 这样的话在 padding的区域将没有背景图片及颜色
</code></pre>
<h2 id="5-盒模型的概念与应用">5. 盒模型的概念与应用</h2>
<h4 id="什么是盒子模型">什么是盒子模型</h4>
<p>CSS 盒模型（Box Model）本质上是一个盒子，它包括边距（margin）、边框（border）、填充（padding），以及内容（content）等一系列内容组成的。</p>
<p>具体的盒子计算方式在不同的浏览器中有所差异，目前有以下两种方式：</p>
<ul>
<li>标准盒模型 - W3C 的标准模型 CSS 中的宽（width） = 内容 （content）的宽</li>
<li>IE盒模型 - 低版本 IE 非 H5 声明 CSS 中的宽（width）= 内容（content）的宽+（border + padding）* 2</li>
</ul>
<p>其中 IE 浏览器已经基本被市场淘汰，因此，我们更多的还是关注标准盒模型，IE 盒模型只做个简单的了解即可。下面这段代码就是展示了两个盒子模型的具体操作，当你运行代码会发现有两个相同颜色的框显示在了浏览器中：</p>
<pre><code>.content-box{
    box-sizing: content-box;
    width: 100px;
    height: 100px;
    padding: 25px;
    border: 25px solid #333;
}

.border-box{
    box-sizing: border-box;
    width: 200px;
    height: 200px;
    padding: 25px;
    border: 25px solid #333;
}
</code></pre>
<p>以上两个选择器样式中，CSS 设置的宽高不一样，实际显示的大小一样。这就是盒子模型的作用。当然，想要更好的操作盒模型，需要掌握不同的设置属性，属性知识点如下：</p>
<ul>
<li>模型模式 box-sizing</li>
<li>显示方式 display</li>
<li>外边距 marign</li>
<li>内边距 padding</li>
<li>宽度 width</li>
<li>高度 height</li>
</ul>
<p>上面展示的内容是在标准盒模型中进行操作的，你可以通过 CSS 中 box-sizing 属性的值为 border-box 来切换到 IE 盒模型的渲染模式，两种盒模型只是计算方式不一样（IE 盒模型中的宽度包括了边框和内边距），具体使用哪一种取决于团队决定。因为 IE 浏览器基本已经被淘汰了，因此，这里只需要做个简单的了解。</p>
<p>了解完盒模型的基本概念，接下来我们看一下如何具体的操作盒模型，进行网页的整体布局操作。</p>
<h4 id="margin">margin</h4>
<p>marign（外边距），它定义了元素之间的距离。</p>
<p>比如以下的例子就定义了三个元素（container-1、container-2、container-3）的盒模型距离，其中：</p>
<ul>
<li>container-1 定义了元素距离下一个元素的外边距为 10px；</li>
<li>container-2定 义了元素距离上一个元素的距离为 20px。</li>
</ul>
<p>实际它们之间的间隔为 20px，这种现象叫作“外边距合并”。</p>
<pre><code>&lt;div style=&quot;width: 200px;height:50px;background:#ccc;margin-bottom:10px;&quot;&gt;
    container-1
&lt;/div&gt;
&lt;div style=&quot;width: 200px;height:50px;background:#ccc;margin:20px 0;&quot;&gt;
    container-2
&lt;/div&gt;
&lt;div style=&quot;width: 200px;height:50px;background:#ccc;margin-top:20px;&quot;&gt;
    container-3
&lt;/div&gt;
</code></pre>
<p><strong>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距，合并后的外边距高度等于两个发生合并的外边距高度中的较大者。</strong></p>
<h4 id="border">border</h4>
<p>border 是简写方式，是声明设置所有方向上的边框属性的，如果想控制单个方向上的边框，可以按顺序设置，具体有如下属性：</p>
<ul>
<li>border-width 规定边框的宽度；</li>
<li>border-style 规定边框的样式；</li>
<li>border-color 规定边框的颜色。</li>
</ul>
<p>如果不设置其中的某个值，也不会出问题，比如 border:solid #ff0000; 也是允许的。下面是三个div，我们使用 CSS 来设置具体的边框属性。</p>
<pre><code>&lt;div style=&quot;display: inline-block;margin-right: 20px;width: 100px;height: 100px;border: 1px solid #e4e4e4;&quot;&gt;&lt;/div&gt;
&lt;div style=&quot;display: inline-block;margin-right: 20px;width: 100px;height: 100px;border: 1px dotted #e4e4e4;&quot;&gt;&lt;/div&gt;
&lt;div style=&quot;display: inline-block;margin-right: 20px;width: 100px;height: 100px;border: 1px dashed #e4e4e4;&quot;&gt;&lt;/div&gt;
border: 1px solid #e4e4e4;  // 实线框
border: 1px dotted #e4e4e4; // 点状框
border: 1px dashed #e4e4e4; // 虚线框
</code></pre>
<h4 id="padding">padding</h4>
<p>padding 是简写方式，声明设置所有内边距属性，可以设置最多4个属性值，不同的属性值个数具有不同的含义，具体使用见下面的代码。</p>
<pre><code>padding-top: 5px; //上内边距为5px
padding-top: 10px; //上内边距为10px
padding-top: 20px; //上内边距为20px

padding: 10px;      // 上下左右内边距为 10px
padding: 10px 20px; // 上下内边距为 10px，左右内边距为 20px
padding: 10px 20px 0; // 上边距为 10px，左右内边距为 20px，下内边距为 0
padding: 10px 20px 0 5px; // 上边距为 10px，右内边距为 20px，下内边距为 0，左内边距为 10px
</code></pre>
<h4 id="内容宽高设置">内容宽高设置</h4>
<p>height 、width 属性分别设置盒子的宽度和高度。</p>
<pre><code>.content-box{
    width: 60px;
    height: 60px;
    padding: 10px;
    border:10px solid #e4e4e4;
}
</code></pre>
<h2 id="6-特殊图形的绘制">6. 特殊图形的绘制</h2>
<h4 id="绘制圆和椭圆">绘制圆和椭圆</h4>
<p>绘制圆和椭圆，需要使用 border-radius 属性定义元素的圆角，可以配合绘制出圆形、椭圆形。当 border-radius 为 50% 时候，圆角为元素本身的一半，如果元素是的宽高比是 1:1，那么元素就会呈现圆形。当元素的宽高比非 1:1 时候，就会呈现出椭圆形。</p>
<p>具体看下面的代码：</p>
<ul>
<li>圆</li>
</ul>
<pre><code>display: inline-block;
height: 200px;
width: 200px;
background: #fff;
border-radius: 50%;
</code></pre>
<ul>
<li>椭圆</li>
</ul>
<pre><code>display: inline-block;
height: 150px;
width: 200px;
background: #fff;
border-radius: 50%;
</code></pre>
<h4 id="绘制三角形">绘制三角形</h4>
<p>要想绘制出三角形，我们需要使用透明和非透明的 border 组合。以尖角朝上的三角形为例子，我们设置宽和高都为 0，然后设置下边框为 20px 黑色，设置左右边框为 10px 透明。</p>
<p>这样设置三角形的高为下边框的宽度 20px，宽度为左右边框的和 20px。</p>
<p>同理大家可以更具算法规则，绘制出不同朝向的三角形及等边三角形，比如我代码中呈现的样子：</p>
<pre><code>//向上三角形
width: 0;
height: 0;
border-bottom: 20px solid #fff;
border-left: 10px solid transparent;
border-right: 10px solid transparent;
//向下三角形
width: 0;
height: 0;
border-top: 20px solid #fff;
border-left: 10px solid transparent;
border-right: 10px solid transparent;
//向左三角形
width: 0;
height: 0;
border-top: 10px solid transparent;
border-bottom: 10px solid transparent;
border-right: 20px solid #fff;
//向右三角形
width: 0;
height: 0;
border-top: 10px solid transparent;
border-bottom: 10px solid transparent;
border-left: 20px solid #fff;
</code></pre>
<h2 id="7-css定位">7. CSS定位</h2>
<h4 id="非定位-static">非定位 static</h4>
<p>默认值，没有定位，元素出现在正常的流中。一般不会使用到，也没有任何的布局效果。因此作为了解即可。</p>
<h4 id="相对定位-relative">相对定位 relative</h4>
<p>相对（自己）定位的元素，有以下四个关键点：</p>
<ul>
<li>在常规流里面布局</li>
<li><strong>相对于自身本应该在的位置偏移</strong></li>
<li>使用 top、bottom、left、right 设置偏移长度</li>
<li>流内其他元素当作没偏移一样布局</li>
</ul>
<h4 id="绝对定位-absolute">绝对定位 absolute</h4>
<p>相对于非 static 祖先父元素进行定位，同样有以下四个关键点：</p>
<ul>
<li>脱离正常流</li>
<li>相对于最近非 static 祖先的 padding box 定位</li>
<li>不会对流内元素布局造成影响</li>
<li>可以有 margin 但不会折叠</li>
</ul>
<h4 id="固定定位-fixed">固定定位 fixed</h4>
<p>相对于<strong>视口</strong>绝对定位：</p>
<ul>
<li>相对于 Viewport 定位</li>
<li>不会随着页面滚动发生变化</li>
</ul>
<h4 id="自动计算">自动计算</h4>
<p>无论是哪种定位方式，如果不指定 top、left、right、bottom、width、height 的时候，会默认安照 auto 计算，以自身默认的位置为基础机型计算。而非 top:0 、left:0 进行计算。</p>
<h4 id="定位练习">定位练习</h4>
<p>我们可以通过一段 Demo 体验一下绝对定位，只要能够完成绝对定位，其他定位方式就可以自行完成了，基本就是换汤不换药，简单修改参数即可完成操作。</p>
<ul>
<li>HTML</li>
</ul>
<pre><code class="language-html">&lt;div class=&quot;pos-list&quot;&gt;
  &lt;div class=&quot;pos-item abs&quot;&gt;绝对定位 1&lt;/div&gt;
  &lt;div class=&quot;pos-item abs&quot;&gt;绝对定位 2&lt;/div&gt;
  &lt;div class=&quot;pos-item abs&quot;&gt;绝对定位 3&lt;/div&gt;
  &lt;div class=&quot;pos-item abs&quot;&gt;绝对定位 4&lt;/div&gt;
  &lt;div class=&quot;pos-item fixed&quot;&gt;固定定位 5&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>CSS</li>
</ul>
<pre><code class="language-css">/* 定义容器，且定位相对定位 */
/* 绝对定位的位置是相对于其有相对定位的父元素定位，会一直追寻到 body 元素 */
/* 可以尝试注释或者删除容器中的相对定位，再看看效果 */
.pos-list{
 position: relative;
 margin: 100px auto 0;
 width: 600px;
 height: 600px;
 background: #f1f1f1;
}
/* 定义每个项目 */
.pos-item{
 width: 200px;
 height: 200px;
 border: 5px solid #333;
 background: #666;
}
/* 定义绝对定位 */
.abs{
 position: absolute;
}
/* 定义第 1 个绝对定位项目的位置 */
.abs:nth-child(1){
 top: 20px;
 left: 20px;
}
/* 定义第 2 个绝对定位项目的位置 */
.abs:nth-child(2){
 top: 40px;
 left: 40px;
}
/* 定义第 3 个绝对定位项目的位置 */
.abs:nth-child(3){
 top: 60px;
 left: 60px;
}
/* 定义第 4 个绝对定位项目的位置 */
.abs:nth-child(4){
 top: 80px;
 left: 80px;
}
/* 定义固定定位项目及位置 */
.fixed{
 position: fixed;
 top: 20px;
 right: 20px;
}
</code></pre>
<h2 id="8-flex布局">8. flex布局</h2>
<h4 id="flex-布局是什么">Flex 布局是什么</h4>
<p>Flex 是 Flexible Box 的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。不过需要注意的是，设置 flex 布局以后，子元素的 float 、clear 、vertical-align 属性将失效。</p>
<pre><code>.box{
  display: flex;
}
</code></pre>
<p>Flex 布局使用起来十分方便，而且兼容性方面也得到了大多数浏览器的兼容支持，可以放心使用。</p>
<p><strong>1. 兼容性</strong></p>
<p>IE10 + ／Chrome 21+ ／Opera 12.1+ ／Firefox 22+ ／Safari 6.1+</p>
<figure data-type="image" tabindex="1"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/oNqoQTcQLlGchhgzbbWE8X3nq50CaNoORpLfW7L6.png" alt="img" loading="lazy"></figure>
<p><strong>2. 基本概念</strong></p>
<figure data-type="image" tabindex="2"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/2jFXAjnMx3HmwejW5xeeV1AoCz5NVqh5LpgXPveY.png" alt="img" loading="lazy"></figure>
<ul>
<li>采用 Flex 布局的元素，成为 Flex 容器（flex container），它的子元素自动变成容器成员，成为项目（flex item）。</li>
<li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。</li>
<li>主轴（默认情况下x轴）的开始位置（与边框的交叉点）叫 main start，结束位置叫做 main end。</li>
<li>交叉轴（默认情况下y轴）的开始位置叫做 cross start，结束位置叫做 cross end。</li>
<li>项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</li>
</ul>
<p>其实 Flex 布局使用起来很简单，主要步骤有三个：首先定义 Flex 容器，然后设置容器相关属性，最后再设置项目相关属性（项目属性不一定要设置，依实际情况而定），我们需要记住不同容器属性和项目属性的使用场景（后面会重点介绍容器属性和项目属性的语法），接下来我们通过代码演示下。</p>
<h4 id="使用">使用</h4>
<ol>
<li>定义Flex容器</li>
</ol>
<ul>
<li>任何容器都可以定义为 Flex 布局，包括行内元素。需要添加内核前缀。</li>
<li>子元素在容器中水平（默认）摆放</li>
</ul>
<pre><code>.box-container{
 display: flex;
 display: -ms-flex; /* IE10 /
 display: -webkit-flex; / Safari chrome opera */
}
.box-inline-container{
 display: inline-flex;
}
</code></pre>
<ol>
<li>设置容器属性（容器属性是重点）</li>
</ol>
<pre><code>flex-direction: row | row-reverse | column | column-reverse;
flex-wrap: nowrap | wrap | wrap-reverse;
flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;
justify-content: flex-start | flex-end | center | space-between | space-around;
align-items: flex-start | flex-end | center | baseline | stretch;
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
</code></pre>
<p>针对上面的容器属性，我们详细展开介绍下：</p>
<ul>
<li>flex-direction：排列方向
<ul>
<li>row（默认值）：水平方向 ，起点在左端。</li>
<li>row-reverse：水平方向，起点在右端。</li>
<li>column：垂直方向，起点在上沿。</li>
<li>column-reverse：垂直方向，起点在下沿。<br>
<img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/ciMr5MzWuoxA3Ryw2r4JmIupvGn9IeslTOCX0IU7.png" alt="image.png" loading="lazy"></li>
</ul>
</li>
<li>flex-wrap：默认情况下，项目都排在一条线（又称&quot;轴线&quot;）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。
<ul>
<li>nowrap（默认值） ：不换行</li>
<li>wrap ：换行，第一行在上方</li>
<li>wrap-reverse：换行，第一行在下方</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/rtLomLlWfC9fskb8NpzOWXLOeIwlMSEqhFGH4u3u.png" alt="img" loading="lazy"></figure>
<ul>
<li>flex-flow ：flex-direction + flex-wrap 的简写
<ul>
<li>row nowrap（ 默认值）</li>
</ul>
</li>
<li>justify-content：主轴对齐方式
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center：居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/vl137oV26XRn1HgU5hlQCguWp2o57aWmOAcdCyNP.png" alt="img" loading="lazy"></figure>
<ul>
<li>align-items ：叉轴对齐方式
<ul>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。<br>
<img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/JJge0n0nbiARWnylvEdSaoAoNv7oqxq8BID0Z1aq.png" alt="image.png" loading="lazy"></li>
</ul>
</li>
<li>align-content ：多轴线的对齐方式，一个轴线不起作用
<ul>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/t8x7pux9qagWM1Ox4872WlL3640aP5spp61Oq0ai.png" alt="img" loading="lazy"></figure>
<ol>
<li>设置项目属性（项目属性是重点）</li>
</ol>
<pre><code class="language-css">order: &lt;integer&gt;;
flex-grow: &lt;number&gt;; /* default 0 /
flex-shrink: &lt;number&gt;; / default 1 /
flex-basis: &lt;length&gt; | auto; / default auto */
flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]
align-self: auto | flex-start | flex-end | center | baseline | stretch;
</code></pre>
<p>针对上面的项目属性，我们详细展开介绍下。</p>
<ul>
<li>order：定义项目的排列顺序
<ul>
<li>0 （默认值）：越小排列越靠前，可以为负数。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/5CfeRfLiIWUnFWPGWnJXmE5xiji264oMYVGpncrR.png" alt="img" loading="lazy"></figure>
<ul>
<li>flex-grow：定义项目的放大比例
<ul>
<li>0（默认值）：如果存在剩余空间，也不放大。</li>
<li>1 ：按 1 比例等分空间。</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/F3SJv1CWseoNE3v3CYsunaSfR6hx7YblxPjADYbn.png" alt="img" loading="lazy"></figure>
<ul>
<li>flex-shrink：定义了项目的缩小比例
<ul>
<li>1（默认值）：当空间不足时，都按比例缩小。</li>
<li>0 ： 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>
<img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/DRBYTgKQW45traDzwugMwyfBj2VJXJ7wTsLvgW2I.png" alt="image.png" loading="lazy"></li>
</ul>
</li>
<li>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
<ul>
<li>auto（默认值）：项目本来大小。</li>
</ul>
</li>
<li>flex ： flex-grow, flex-shrink 和 flex-basis的简写，后两个属性可选。
<ul>
<li>0 1 auto （默认值）</li>
<li>auto ：1 1 auto</li>
<li>none：0 0 auto</li>
</ul>
</li>
<li>align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。
<ul>
<li>auto（默认值）： 表示继承父元素的align-items属性</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0220/admin/BSScIYT3mOFCuPgHMtHlzGuANG2wFH5aISnatsEW.png" alt="img" loading="lazy"></figure>
<h1 id="css-3d">CSS 3D</h1>
<p>这里强调一下transform-style默认值是flat：表示子元素不保留其 3D 位置，而值preserve-3d表示保留其子元素 3D 位置。这也就意味着想要实现3D效果需要设置transform-style为preserve-3d，需要记住该知识点。</p>
<p><strong><em>transform中rotateY rotateX rotate等参数</em>不同设置的顺序呈现效果是不一样的</strong></p>
<h1 id="javascript">Javascript</h1>
<h2 id="1-js介绍">1. JS介绍</h2>
<h4 id="什么是js">什么是JS</h4>
<ul>
<li>JavaScript一种直译式的、基于对象 (Object) 和事件驱动(EventDriven)的脚本语言，是一种动态、弱类型的语言</li>
<li>Javascript的运行环境或者说解释器被称为JavaScript引擎，为浏览器的一部分 (比如Chrome的V8引擎)</li>
<li>JavaScript是广泛用于客户端的脚本语言，最早在HTML网页上使用，用来给HTML网页增加动态特效，实现动态交互，美化页面的功能</li>
<li>然而现在JavaScript也可被用于网络服务器,如 Node.js。</li>
<li>JavaScript也通常简称为JS</li>
</ul>
<h4 id="js基本特性">JS基本特性</h4>
<ul>
<li>脚本语言:不同于C、C++等语言先编译后执行，JavaScript是在程序运行过程中逐行进行执行的</li>
<li>基于对象:可以创建对象,也可以使用现有对象</li>
<li>简单性:变量类型简单、数据类型非严格要求</li>
<li>动态性:事件驱动，不需要经过Web服务器就可以做出响应</li>
<li>跨平台性:不受操作系统限制,仅需要浏览器的支持</li>
</ul>
<h4 id="js主要组成">JS主要组成</h4>
<ul>
<li>浏览器对象模型BOM</li>
<li>文档对象模型DOM</li>
<li>核心ECMAScript</li>
</ul>
<h4 id="js常见用途">JS常见用途</h4>
<ul>
<li>嵌入动态文本于HTML页面</li>
<li>对浏览器事件做出响应</li>
<li>读写HTML元素</li>
<li>在数据被提交到服务器之前<strong>验证数据</strong></li>
<li>检测访客的浏览器信息</li>
<li>控制cookies，包括创建和修改等</li>
</ul>
<h4 id="示例">示例</h4>
<p>![image-20230824153952392](/Users/rowan/Library/Application Support/typora-user-images/image-20230824153952392.png)</p>
<h2 id="2-js基本类型">2. JS基本类型</h2>
<h4 id="类型">类型</h4>
<p>类型是值的内部特征，它定义了值的行为，以使其区别于其他值，JavaScript 有七种内置的值类型：</p>
<p><strong>undefined（未定义）、boolean（布尔值）、string（字符串）、number（数字）、object（对象）、null（空值）、symbol（符号，ES6新增）</strong>。</p>
<h4 id="typeof">typeof</h4>
<p>我们可以用 typeof 运算符来查看值的类型，它返回的是类型字符串值，但七种类型并不是一一对应，特殊值 null 会被认为是一个空的对象引用。</p>
<pre><code class="language-js">typeof undefined === &quot;undefined&quot;; 
typeof true      === &quot;boolean&quot;;
typeof 42        === &quot;number&quot;;
typeof &quot;42&quot;      === &quot;string&quot;;
typeof {lift:42} === &quot;object&quot;;
typeof Symbol()  === &quot;symbol&quot;;
typeof null      === &quot;object&quot;;
</code></pre>
<p>可以用以下方法判断 null 类型：</p>
<pre><code class="language-js">var a = null;
(!a &amp;&amp; typeof a === &quot;object&quot;);
</code></pre>
<h4 id="boolean">Boolean</h4>
<p>布尔值指代真或假、开或关、是或否，只有2个值，保留字true和false。在ECMA中所有类型的值都有与这两个Boolean值等价的值，可以通过转换函数Boolean()来使用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">转为true的值</th>
<th style="text-align:center">转为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Bollean</td>
<td style="text-align:center">TRUE</td>
<td style="text-align:center">FALSE</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">非空字符串</td>
<td style="text-align:center">“”（空字符串）</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">非零数字值</td>
<td style="text-align:center">0和NaN</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">任何对象</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">undefined</td>
<td style="text-align:center">n/a</td>
<td style="text-align:center">undefined</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">var message = &quot;Hello word&quot;;
var messageAsBollean = Bollean(message);
</code></pre>
<p>在流程控制语句中会自动执行相应的 Boolean 转换。</p>
<pre><code class="language-js">var message = &quot;Hello word&quot;
if(message){
    alert(&quot;Value is true&quot;);
}
</code></pre>
<h4 id="undefined-与-null">undefined 与 null</h4>
<p>特殊值 undefined 与 null 类型只有一个值，即其特殊值本身。它们各自表达其自身的含义不包含任何信息，未定义和空对象指针。</p>
<h5 id="undefined">undefined</h5>
<p>在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。例如：</p>
<pre><code class="language-js">var message;
console.log(message === undefined) //true
</code></pre>
<p>在很多操作中，因为每个操作都必须返回一个值，而这个值没有定义返回值的时候，那么就是默认的undefined。例如：</p>
<pre><code>function conl(a) {
    console.log(a)
}
</code></pre>
<p>在获取空对象的属性中，如果属性已经定义，会获取到返回的值，否则会返回undefined。例如：</p>
<pre><code>var obj = {
    attr1:'attr1'
}

obj.attr1 // attr1
obj.attr2 // undefined
</code></pre>
<p>这个在以后会经常用到，在遍历时判断是否有数据展现页面的结构及类型。</p>
<h5 id="null">null</h5>
<p>从逻辑角度上来看，null 值表示一个空对象指针。所以，如果定义变量准备在将来用保存对象，那么最好将该变量初始化为 null 而不是其他值。实际上，undefined 值是派生自 null 值，因此在 ECMA-262 规定对它们的相等性测试要返回 true。</p>
<pre><code>null == undefined //true
</code></pre>
<p>尽管 undefined 和 null 有这样的关系，但是它们的用途完全不同。如前所诉，<strong>无论在什么情况下都没有必要把一个变量的值显式地设置为 undefined</strong>，而只要一再保存对象变量还没真正保存对象，就应该明确地让变量保存值为 null 值。</p>
<h4 id="string">string</h4>
<p>字符串是存储字符（比如 “James”）的变量，字符串可以是引号中的任意文本，我们可以使用单引号或双引号：</p>
<pre><code>var carname=&quot;Volvo XC60&quot;;
var carname='Volvo XC60';
</code></pre>
<p>你可以在字符串中使用引号，只要不匹配包围字符串的引号即可：</p>
<pre><code class="language-js">var answer=&quot;It's alright&quot;;
var answer=&quot;He is called 'Johnny'&quot;;
var answer='He is called &quot;Johnny&quot;';
</code></pre>
<h4 id="number">number</h4>
<p>JavaScript 只有一种数字类型，数字可以带小数点，也可以不带：</p>
<pre><code>var x1=34.00;     //使用小数点来写
var x2=34;        //不使用小数点来写
</code></pre>
<p>极大或极小的数字可以通过科学（指数）计数法来书写：</p>
<pre><code>var y=123e5;     // 12300000
var z=123e-5;    // 0.00123
</code></pre>
<h4 id="symbol">symbol</h4>
<p>“Symbol” 值表示唯一的标识符，可以使用 Symbol() 来创建这种类型的值：</p>
<pre><code>// id 是 symbol 的一个实例化对象
let id = Symbol();
</code></pre>
<p>创建时，我们可以给 Symbol 一个描述（也称为 Symbol 名），这在代码调试时非常有用：</p>
<pre><code>// id 是描述为 &quot;id&quot; 的 Symbol
let id = Symbol(&quot;id&quot;);
</code></pre>
<p>Symbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。比如，这里有两个描述相同的 Symbol （它们不相等）：</p>
<pre><code class="language-js">let id1 = Symbol(&quot;id&quot;);
let id2 = Symbol(&quot;id&quot;);
alert(id1 == id2); // false
</code></pre>
<h4 id="object">object</h4>
<p>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：</p>
<pre><code>var person={firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};
</code></pre>
<p>上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。空格和折行无关紧要，声明可横跨多行：</p>
<pre><code>var person={
 firstname : &quot;John&quot;,
 lastname : &quot;Doe&quot;,
 id : 1122
};
</code></pre>
<p>对象属性有两种寻址方式：</p>
<pre><code>name=person.lastname;
name=person[&quot;lastname&quot;];
</code></pre>
<h2 id="3-js基本语法">3. JS基本语法</h2>
<h4 id="变量声明">变量声明</h4>
<h5 id="var-let-const">var、let、const</h5>
<p>在 ES5 的时候 我们只能通过 var 声明变量，由于没有常量的声明概念，所以我们会用全大写来代表这个变量是一个常量。例如：</p>
<pre><code>var variable = 'Variable';
var CONSTANT = 'Constant';
</code></pre>
<p>在 ES6 之后，我们可以分别通过 let 和 const 声明变量和常量。例如：</p>
<pre><code>let   variable = 'Variable';
const CONSTANT = 'Constant';
</code></pre>
<blockquote>
<p>这里有两个注意点：变量可重复赋值，常量不可，定义常量时必须制定一个值；变量在使用前，请先申明。</p>
</blockquote>
<h4 id="作用域">作用域</h4>
<p>执行环境定义了变量对象有权访问其他的数据，每个执行环境都有一个与之关联的变量对象，环境定义的所有变量和函数都保存在这个对象中，解析器在处理数据时会在后台使用到它。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链，保证对执行环境有权访问的所有变量和函数的有序访问。作用域链中的下一个变量对象来自包含环境，再下一个变量对象则来自下一个包含环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>比较简单的说明就是，当前变量在什么情况下能起作用。</p>
<ul>
<li>全局作用域</li>
</ul>
<p>全局作用域是最外层的一个执行环境，所有地方都可以引用到。一般在最外层定义（推荐使用），及所有没有 var 直接赋值的变量都属于全局变量（不推荐使用）。</p>
<pre><code>var global = 100;

global_2 = 100;
</code></pre>
<ul>
<li>函数作用域</li>
</ul>
<p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，当函数执行完毕的时候栈从环境中弹出，把所有权返回给执行环境。函数可以当作值来传递，函数内部，可以访问外部函数的作用域，称之为闭包。</p>
<pre><code>function funtest(){
    var funstr = 'test';
}
</code></pre>
<ul>
<li>块级作用域</li>
</ul>
<p>ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 { } 包括，if 语句和 for 语句里面的 { } 也属于块作用域。let 和 const 的声明的变量就仅在块级别作用域生效。</p>
<pre><code>if(true){
    let tmp = 123;
}
</code></pre>
<ol>
<li>var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。</li>
<li>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</li>
<li>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</li>
<li>同一个变量只能使用一种方式声明，不然会报错</li>
</ol>
<h4 id="运行符号">运行符号</h4>
<ul>
<li>布尔操作符（ &amp;&amp; 、|| 、!）</li>
</ul>
<pre><code>var bool_1 = true &amp;&amp; false; // false
var bool_2 = true || false; // true
var bool_3 = !true;         // false
var bool_4 = !!NaN;         // false
</code></pre>
<ul>
<li>加减乘除运算符（ +、-、 * 、 / 、% ）</li>
</ul>
<pre><code>var plus       = 10 + 1; // 11
var minus      = 10 - 1; // 9
var multiplied = 10 * 2; // 20
var divided    = 10 / 2; // 5
var remainder  = 10 % 2; // 0
</code></pre>
<ul>
<li>关系运算符 ( &gt; 、&lt; )</li>
</ul>
<pre><code>var greater = 5 &gt; 3; // true
var less    = 5 &lt; 3; // false
</code></pre>
<ul>
<li>相等运算符（ == 、 === ）</li>
</ul>
<pre><code>var equal     = ( 10 == '10'); // true
var congruent = ( 10 === '10'); // false
</code></pre>
<ul>
<li>条件操作符</li>
</ul>
<pre><code>var ifstr = true ? 'ok' : 'no'; // ok
</code></pre>
<ul>
<li>赋值操作符</li>
</ul>
<pre><code>var num = 10;
// num = num + 10;
num += 10; // 20
</code></pre>
<ul>
<li>递增递减操作符 ( ++ )</li>
</ul>
<pre><code>var num = 10;
num ++; // 10
++ num; // 12
</code></pre>
<h4 id="条件判断语句">条件判断语句</h4>
<ul>
<li>if</li>
</ul>
<pre><code>var tmp = 12;
if(tmp &gt; 10){
    console.log(tmp + ' &gt; 12');
}else{
    console.log(tmp + ' &lt; 12');
}
</code></pre>
<ul>
<li>switch</li>
</ul>
<p>如果超过 4 个及以上的多重判断，建议用 switch 语法进行判断。</p>
<pre><code>var tmp = 12;
switch (tmp) {
    case 12:
        tmp = tmp * tmp;
        break;
    case 13:
        tmp = tmp + tmp;
        break;
    default:
        tmp = tmp / tmp;
}
console.log(tmp)
</code></pre>
<h4 id="循环语句">循环语句</h4>
<ul>
<li>for</li>
</ul>
<p>for 语句也是前测试循环语句，但它具备在执行循环前初始化变量和定义循环后要执行的代码能力。</p>
<pre><code>var count = 0;

for (var i = 0;i &lt; 10; i++ ) {
    count = count + i;
}
console.log(count);
</code></pre>
<p>以上代码定义变量 i 的初始值为 0。只有当条件表达式（ i &lt; 10 ) 返回 true 的情况下才会进入 for 循环。如果执行了循环体中的代码，则会对循环后的表达式 （ i ++ ）求值，即递增 i 的值。</p>
<ul>
<li>for-in</li>
</ul>
<p>for-in 语句是一种精准的迭代语句，可以用来枚举对象属性。</p>
<pre><code>var obj = { a: 1, b: 2 };

for( var key in obj){
    console.log(key,obj[key]);
}
</code></pre>
<h2 id="4-js函数">4. JS函数</h2>
<h4 id="基本构成">基本构成</h4>
<ul>
<li>创建 function</li>
</ul>
<pre><code class="language-js">function funName(){ ... }      // 函数声明（开发插件时、函数需要全局调用时使用）
var fun = function(){ ... }    // 函数表达式(推荐)
var sum = new Function('a', 'b', 'return a + b'); // Function 构造函数
</code></pre>
<ul>
<li>参数 arguments</li>
</ul>
<p>可以通过，参数名 和 arguments(参数对象) 获取到函数调用时传递过来的值。</p>
<pre><code class="language-js">var fun = function(a,b,c){ 
    console.log(arguments[0],a);
    console.log(arguments[1],b);
    console.log(arguments[2],c);
}
fun('a','b','c');
</code></pre>
<ul>
<li>返回值 return</li>
</ul>
<p>函数不指定返回值默认返回 undefined</p>
<pre><code class="language-js">var fun = function(a,b){ 
    return a + b;
}
var result = fun(2,3); // 5
</code></pre>
<h4 id="全局函数">全局函数</h4>
<ul>
<li>URI 编码解码</li>
</ul>
<pre><code>var uri = 'https://www.aitschool.com?hmsr=test';
encodeURI(uri); // &quot;https://www.aitschool.com?hmsr=test&quot;
encodeURIComponent(uri); // &quot;https%3A%2F%2Fwww.aitschool.com%3Fhmsr%3Dtest&quot;
</code></pre>
<p>其中，encodeURI 不会对本身属于URI的特殊字符进行编码，例如冒号、斜杠、问号和井号。而 encodeURIComponent 则会对它发现的任何非标准字符进行编码。和两个方法进行对应的解码方法分别为 decodeURI 和 decodeURIComponent。</p>
<pre><code>var uri = 'https%3A%2F%2Fwww.aitschool.com%3Fhmsr%3Dtest';
decodeURIComponent(uri); // &quot;https://www.aitschool.com?hmsr=test&quot;
</code></pre>
<p>一般情况下常用的是 encodeURIComponent 和 decodeURIComponent 对查询字符串参数进行编码，而不是基础 URI 进行。</p>
<ul>
<li>定时器</li>
</ul>
<p>setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。setInterval( ) 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval( ) 方法会不停地调用函数，直到 clearInterval( ) 被调用或窗口被关闭。由 setInterval( ) 返回的 ID 值可用作 clearInterval( ) 方法的参数。</p>
<pre><code>- setTimeout (延迟执行)
- setInterval （定时执行）
var count = 0;
var intervalID = setInterval(function(){
    count ++;
    console.log(count);
},1000);

setTimeout(function(){
    clearInterval(intervalID);
},10000)
</code></pre>
<h2 id="5-内置对象">5. 内置对象</h2>
<h4 id="date">Date</h4>
<pre><code>var date = new Date(); // 返回当日的日期和时间
date.getDay();         // 返回一周中的第几天(0-6) 
date.getFullYear();    // 返回完整的4位年份数 
date.getMonth();       // 返回月份数(0-11) 
date.getDate();        // 返回日(1-31) 
date.getHours();       // 返回小时数(0-23)
</code></pre>
<h4 id="math">Math</h4>
<p>Math 对象保存数学公式和信息，常用的有：</p>
<ul>
<li>Math.PI ( π 的值 )</li>
<li>Math.ceil (向上舍入)</li>
<li>Math.floor (向下舍入)</li>
<li>Math.round (四舍五入)</li>
<li>Math.random (返回大于等于0小于1的随机数)</li>
</ul>
<pre><code>Math.PI; //3.141592653589793
Math.ceil(4.3); // 5
Math.floor(4.6); // 4
Math.round(4.5); // 5
Math.random();  // 0.5892502788505454
</code></pre>
<h4 id="array">Array</h4>
<p>Array 对象用于在变量中存储多个值：</p>
<pre><code>var arr = [&quot;cba&quot;, &quot;nba&quot;, &quot;cuba&quot;];
</code></pre>
<p>第一个数组元素的索引值为 0，第二个索引值为 1，以此类推。创建一个数组，有以下三种方法（下面的代码定义了一个名为 myCars的数组对象）。</p>
<p>第一种常规方式：</p>
<pre><code>var myCars=new Array();
myCars[0]=&quot;Saab&quot;;      
myCars[1]=&quot;Volvo&quot;;
myCars[2]=&quot;BMW&quot;;
</code></pre>
<p>第二种简洁方式：</p>
<pre><code>var myCars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;);
</code></pre>
<p>第三种字面：</p>
<pre><code>var myCars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;];
</code></pre>
<ul>
<li>访问数组</li>
</ul>
<p>通过指定数组名以及索引号码，你可以访问某个特定的元素（以下实例可以访问myCars数组的第一个值）。</p>
<pre><code>var name=myCars[0];
</code></pre>
<p>以下实例修改了数组 myCars 的第一个元素：</p>
<pre><code>myCars[0]=&quot;Opel&quot;;
</code></pre>
<ul>
<li>数组的方法和属性</li>
</ul>
<p>使用数组对象预定义属性和方法：</p>
<pre><code>var x=myCars.length;            // myCars 中元素的数量
var y=myCars.indexOf(&quot;Volvo&quot;);  // &quot;Volvo&quot; 值的索引值
var arr = [1, 2, 3];
arr.toString();                 // &quot;1,2,3&quot; toString方法返回数组的字符串形式
</code></pre>
<h4 id="string-2">String</h4>
<p>String对象是用于存储字符串的全局对象，字符串可以是双引号或单引号内的任何文本：</p>
<pre><code>var msg = &quot;Hello world&quot;;
var msg = 'Hello world';
</code></pre>
<p>与某些其他语言不同，JavaScript 在单引号和双引号之间没有区别，JavaScript 字符串的索引为零：字符串的第一个元素位于索引 0，第二个元素为 1，依此类推。</p>
<h4 id="number-2">Number</h4>
<p>使用 Number 对象可以处理数字，JavaScript 只有一种数字数据类型，并且不能区分整数和浮点值。</p>
<p>数字可以带或不带小数：</p>
<pre><code>var a = 3.14;     // 带小数的数字
var b = 12;       // 不带小数的数字
</code></pre>
<p>可以使用科学记数法来写特大号或小号：</p>
<pre><code>var a = 1e5;      // 100000
var b = 1e-1;     // 0.1
var c = 1.23e9;   // 1230000000
</code></pre>
<h4 id="boolean-2">Boolean</h4>
<p>Boolean（布尔）对象用于将非布尔值转换为布尔值（true 或者 false）。</p>
<ul>
<li>创建 Boolean 对象</li>
</ul>
<p>Boolean 对象代表两个值：true 或者 false，下面的代码定义了一个名为 myBoolean 的布尔对象：</p>
<pre><code>var myBoolean=new Boolean();
</code></pre>
<p>如果布尔对象无初始值或者其值为：</p>
<ul>
<li>0</li>
<li>-0</li>
<li>null</li>
<li>“”</li>
<li>false</li>
<li>undefined</li>
<li>NaN</li>
</ul>
<p>那么对象的值为 false。否则，其值为 true（即使当变量值为字符串 “false” 时）！</p>
<h4 id="regexp">RegExp</h4>
<p>RegExp 对象</p>
<p>正则表达式是描述字符模式的对象，正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</p>
<p>语法</p>
<pre><code>var patt=new RegExp(pattern,modifiers);
// 或者更简单的方式:
var patt=/pattern/modifiers;
</code></pre>
<ul>
<li>pattern（模式） 描述了表达式的模式</li>
<li>modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配，常见的修饰符如下：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">执行对大小写不敏感的匹配</td>
</tr>
<tr>
<td style="text-align:center">g</td>
<td style="text-align:center">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td>
</tr>
<tr>
<td style="text-align:center">m</td>
<td style="text-align:center">执行多行匹配</td>
</tr>
</tbody>
</table>
<h1 id="雪碧图">雪碧图</h1>
<h2 id="1-在导航中使用字体图标">1. 在导航中使用字体图标</h2>
<pre><code>&lt;div class=&quot;wrapper&quot;&gt;
  &lt;header&gt;
    &lt;div class=&quot;navbar-collapse&quot;&gt;
	  &lt;a href=&quot;#&quot; class=&quot;navbar-brand&quot;&gt;雪碧精灵&lt;/a&gt;
	  &lt;nav&gt;
	    &lt;ul&gt;
		  &lt;li&gt;雪碧图&lt;/li&gt;
		  &lt;li&gt;SVG图片&lt;/li&gt;
		  &lt;li&gt;字体图标&lt;/li&gt;
		  &lt;li&gt;字体单位&lt;/li&gt;
		&lt;/ul&gt;
	  &lt;/nav&gt;
	&lt;/div&gt;
  &lt;/header&gt;
 &lt;/div&gt;
</code></pre>
<p>在这里我们使用了 header 来做页面的头部，nav 标签完成导航，无序列表完成导航菜单内容。</p>
<p>接下来完成基本的样式编写</p>
<pre><code class="language-css">body,
dl,
dt,
dd,
ul,
ol,
li,
h1,
h2,
h3,
h4,
h5,
h6,
form,
fieldset,
legend,
input,
button,
textarea,
p,
th,
td,
figure,
font,
a {
	margin: 0;
	padding: 0;
	font: 12px/1.5 &quot;microsoft yahei&quot;;
	text-decoration: none;
	box-sizing: border-box;
	list-style: none;
}
body{
	background: #1fa67a;
}
header {
	height: 40px;
	background: #1fa67a;
	border-bottom: 1px solid #1b926c;
}
header .navbar-collapse {
	width: 1000px;
	margin: 0 auto;
}
header .navbar-brand {
	color: #fff;
	float: left;
	padding: 8px 15px;
	font-size: 16px;	
}


header .navbar-brand .fa-universal-access {
	font-size: 25px;
	margin-right: 5px;
	float: left;
	
}


header nav{
	float: left;
}
header nav&gt;ul&gt;li{
	float: left;
	color: #fff;
	line-height: 40px;
	padding: 0px 20px;
	font-size: 12px;
}
header nav&gt;ul&gt;li:hover{
	background: #1B926C;
	cursor: pointer;
}
</code></pre>
<p>基础样式很简单不做讲解，我们先来预览下效果：</p>
<figure data-type="image" tabindex="9"><img src="https://one-assets.jiker.com/simditor/2019/1218/8NpWYat0pmGcxD3t4TYhMkXbnAiBnmbla305gaXK.png" alt="img" loading="lazy"></figure>
<p>只是一个普通的导航，那么接下来我们给头部加上 logo, 给每个导航菜单加上 icon。</p>
<p>首先我们来看下图标字体的使用方式，找一个字体图标网站，比如：</p>
<ul>
<li>http://fontawesome.dashgame.com/</li>
</ul>
<p><strong>第一步：下载</strong></p>
<p>官网介绍了使用字体的多种方式，我们采用直角下载引入的方式来使用。</p>
<p>首先点击官网的立即下载，下载资源包，并解压到我们项目的 css 文件夹下面，并将解压后的文件命名为 font-awesome。</p>
<p><strong>第二步：引入</strong></p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/font-awesome/css/font-awesome.min.css&quot; /&gt;
</code></pre>
<p>我们将 awesome.min.css 引入到我们的页面中来。</p>
<p><strong>第三步：使用字体图标</strong></p>
<p>使用方式可以参考官网的介绍，在这里不做讲解，我们修改导航代码加入字体图标：</p>
<pre><code>&lt;!-- header --&gt;
&lt;header&gt;
	&lt;div class=&quot;navbar-collapse&quot;&gt;
		&lt;a href=&quot;#&quot; class=&quot;navbar-brand&quot;&gt;&lt;i class=&quot;fa fa-universal-access&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;雪碧精灵&lt;/a&gt;
		&lt;nav&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;span class=&quot;fa-stack fa-lg&quot;&gt;
						&lt;i class=&quot;fa fa-square-o fa-stack-2x&quot;&gt;&lt;/i&gt;
						&lt;i class=&quot;fa fa-twitter fa-stack-1x&quot;&gt;&lt;/i&gt;
					&lt;/span&gt;雪碧图
				&lt;/li&gt;
				&lt;li&gt;&lt;span class=&quot;fa-stack fa-lg&quot;&gt;
						&lt;i class=&quot;fa fa-square-o fa-stack-2x&quot;&gt;&lt;/i&gt;
						&lt;i class=&quot;fa fa-apple fa-stack-1x&quot;&gt;&lt;/i&gt;
					&lt;/span&gt;SVG图片&lt;/li&gt;
				&lt;li&gt;&lt;span class=&quot;fa-stack fa-lg&quot;&gt;
						&lt;i class=&quot;fa fa-square-o fa-stack-2x&quot;&gt;&lt;/i&gt;
						&lt;i class=&quot;fa fa-android fa-stack-1x&quot;&gt;&lt;/i&gt;
					&lt;/span&gt;字体图标&lt;/li&gt;
				&lt;li&gt;&lt;span class=&quot;fa-stack fa-lg&quot;&gt;
						&lt;i class=&quot;fa fa-square-o fa-stack-2x&quot;&gt;&lt;/i&gt;
						&lt;i class=&quot;fa fa-github fa-stack-1x&quot;&gt;&lt;/i&gt;
					&lt;/span&gt;字体单位&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/nav&gt;
	&lt;/div&gt;
&lt;/header&gt;
&lt;!-- end header --&gt;
</code></pre>
<p>我们再来预览页面：</p>
<figure data-type="image" tabindex="10"><img src="https://one-assets.jiker.com/simditor/2019/1218/hOaeJ7X6LMS6iIxsGf8VLztp3SJVbakwNi2Bvquo.png" alt="img" loading="lazy"></figure>
<p>我们要的 logo 和导航的 icon 出现了。</p>
<figure data-type="image" tabindex="11"><img src="https://one-assets.jiker.com/simditor/2019/1218/wyEm5ERJ9ZYm6G6ErC70CLdxKvdC6mPSlcUvpVFL.png" alt="img" loading="lazy"></figure>
<p>打开浏览器的调试工具我们发现字体图标是用：before 伪类的方式来实现的。</p>
<h2 id="2-svg完成燃烧字体">2. SVG完成燃烧字体</h2>
<p>先完成我们的页面布局，为我们的燃烧字体和后续要完成的龙留出位置。</p>
<pre><code>&lt;div class=&quot;content&quot;&gt;
	&lt;div class=&quot;showbox&quot;&gt;
		&lt;div class=&quot;svgbox&quot;&gt;&lt;/div&gt;
		&lt;div id=&quot;dragon&quot;&gt;&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>增加样式：</p>
<pre><code>.showbox{
	width:1000px;
	margin: 0 auto;
	padding:40px;
	color: #fff;
	overflow: hidden;
	
}
.svgbox{
	width:600px;
	float: left;
}
#dragon {
	width:400px;
	float: left;
}
</code></pre>
<p>在向 svgbox 里加入 SVG 的时候我们先来学习一下 SVG。</p>
<p>概述：</p>
<blockquote>
<p>SVG 是一种基于 XML 语法的图像格式，全称是可缩放矢量图（Scalable Vector Graphics）。其他图像格式都是基于像素处理的，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真</p>
</blockquote>
<p>优势：</p>
<blockquote>
<p>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：<br>
SVG 图像可通过文本编辑器来创建和修改；<br>
SVG 图像可被搜索、索引、脚本化或压缩；<br>
SVG 是可伸缩的；<br>
SVG 图像可在任何的分辨率下被高质量地打印；<br>
SVG 可在图像质量不下降的情况下被放大；</p>
</blockquote>
<p>浏览器支持情况：</p>
<figure data-type="image" tabindex="12"><img src="https://one-assets.jiker.com/simditor/2019/1218/39fUTIEjwnobczqdGCb2RcBsFquMZkoVkLnqtoL8.png" alt="img" loading="lazy"></figure>
<p>具体详细的使用方式可以参考 <a href="http://www.w3school.com.cn/svg/svg_reference.asp">SVG 参考手册</a>。</p>
<p>我们可以找到大量的 SVG 基础教程，所以在这里我们不会再从基础课程讲起，我会把代码先贴出来然后添加详细注释：</p>
<pre><code class="language-html">&lt;svg  width=&quot;100%&quot; height=&quot;100%&quot; viewBox=&quot;0 0 1000 300&quot; version=&quot;1.1&quot;   xmlns=&quot;http://www.w3.org/2000/svg&quot; &gt; 
	&lt;defs&gt;
		&lt;path id=&quot;MyPath&quot; d=&quot;M 100 200 
C 200 100 300   0 400 100
C 500 200 600 300 700 200
C 800 100 900 100 900 100&quot; /&gt;
	&lt;/defs&gt;
	&lt;pattern id=&quot;p-fire&quot; viewBox=&quot;30 100 186 200&quot; patternUnits=&quot;userSpaceOnUse&quot; width=&quot;216&quot; height=&quot;200&quot; x=&quot;-70&quot; y=&quot;35&quot;&gt;
	  &lt;image xlink:href=&quot;img/fire.gif&quot; width=&quot;256&quot; height=&quot;300&quot;&gt;&lt;/image&gt;
	&lt;/pattern&gt;
	&lt;text font-family=&quot;Verdana&quot;&gt;
		&lt;textPath xlink:href=&quot;#MyPath&quot; class=&quot;text&quot;&gt;
			I love css sprites
		&lt;/textPath&gt;
	&lt;/text&gt;
&lt;/svg&gt;
</code></pre>
<p>代码讲解：</p>
<pre><code>svg width=&quot;100%&quot; height=&quot;100%&quot;
</code></pre>
<p>设置SVG画布的宽度和高度为 100%，在 SVG 中支持的长度单位有：em、ex、pt、px、pc、cm、mm、in 和百分比值。</p>
<pre><code>viewBox=&quot;0 0 1000 300&quot;
</code></pre>
<p>viewBox 是 SVG “真正”的坐标系统，viewBox 是用于在画布上绘制 SVG 图形的坐标系统。这个坐标系统可以比 viewport 大，也可以比 viewport 小，并且它可以在 viewport 中完全可见或部分可见。这里我们设置了以左上角为起点，宽度为 1000 高度为 300。 默认为像素(px)。</p>
<pre><code>version=&quot;1.1&quot;

 \#版本号

xmlns=&quot;&lt;http://www.w3.org/2000/svg&gt;&quot;
</code></pre>
<p>#标头 必须项</p>
<pre><code>&lt;defs&gt;
</code></pre>
<p><code>&lt;defs&gt;</code>元素用于预定义一个元素使其能够在 SVG 图像中重复使用</p>
<pre><code>&lt;path id=&quot;MyPath&quot; d=&quot;M 100 200

C 200 100 300 0 400 100

C 500 200 600 300 700 200

C 800 100 900 100 900 100&quot;&gt;
</code></pre>
<p>path元素是用来定义形状的通用元素。所有的基本形状都可以用 path 元素来创建。在这里我们使用 path 绘制出了曲线，其中 M 表示位于绝对位置 x=100, y= 200，C 表示绘制曲线。</p>
<pre><code>&lt;/defs&gt;
	&lt;pattern id=&quot;p-fire&quot; viewBox=&quot;30 100 186 200&quot;
</code></pre>
<p><code>&lt;pattern&gt;</code><strong>使用准备好的图片对一个对象进行填充</strong>，这里我们将使用准备好的火焰的图片对文字对象进行填充，https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/pattern。</p>
<pre><code>patternUnits=&quot;userSpaceOnUse&quot; width=&quot;216&quot; height=&quot;200&quot; x=&quot;-70&quot; y=&quot;35&quot;
</code></pre>
<ul>
<li><code>userSpaceOnUse</code>：x、y、width 和 height 表示的值都是当前用户坐标系统的值，这些值没有缩放，userSpaceOnUse 不会对pattern的单位进行缩放。</li>
<li>userSpaceOnUse：使用百分比配置</li>
<li>objectBoundingBox：使用宽高值配置</li>
</ul>
<pre><code>&lt;image xlink:href=&quot;img/fire.gif&quot; width=&quot;256&quot; height=&quot;300&quot;&gt;&lt;/image&gt;
</code></pre>
<p>引入一张图片，<code>xlink:href</code> 规定图片的路径，并定义图片的宽高。</p>
<pre><code>pattern;
text font-family=&quot;Verdana&quot;;
textPath xlink:href=&quot;#MyPath&quot; 
class=&quot;text&quot;;
I love css sprites
/textPath;
/text;
</code></pre>
<p>文本路径<code>&lt;textPath&gt;</code>作用就是放在<code>&lt;text&gt;</code>标记内部引用预定义的 ，引用时，我们需要使用<code>xlink:href</code>属性指明需要引用的路径的 ID。在 SVG 里，处理能沿直线方向写文字外，还能够使用先定义一条路径，让文字沿着定义好的路径排列，在这里我们引用了 id=”MyPath“的路径。</p>
<pre><code>&lt;/svg&gt;
</code></pre>
<p>将 SVG 代码放在<code>&lt;div class=&quot;svgbox&quot;&gt;&lt;/div&gt;</code>中，顺便给我们的 text 定义一下样式，然后预览。</p>
<pre><code>.text{
    fill:url(&quot;#p-fire&quot;); /*fill填满，铺满*/
    stroke:#330000;  /*文本轮廓的线条颜色*/
    stroke-width:1; /*文本轮廓的厚度，线条宽度*/
    stroke-opacity: .5;  /*轮廓透明度*/
    font-size:10em;
    font-weight:600;
}
</code></pre>
<p>预览效果图：</p>
<figure data-type="image" tabindex="13"><img src="https://one-assets.jiker.com/simditor/2019/1218/YC37rUDhMxbUD1xnsLZNK9LNcen0JLDSK27cD1J4.png" alt="img" loading="lazy"></figure>
<p>SVG 在线编辑器：https://c.runoob.com/more/svgeditor/</p>
<p>完成了火焰文字我们继续来使用服务器字体完成我们另一个任务。</p>
<h2 id="3-使用服务器字体完成特殊字体">3. 使用服务器字体完成特殊字体</h2>
<p>在 svgbox 中，SVG 标签之后添加</p>
<pre><code>&lt;p&gt;使用&lt;span class=&quot;black&quot;&gt;css sprites&lt;/span&gt;拼成一只完整的龙，并了解这样做有什么好处？&lt;/p&gt;
&lt;p&gt;学习&lt;span class=&quot;black&quot;&gt;SVG&lt;/span&gt;的使用，思考&lt;span class=&quot;black&quot;&gt;SVG&lt;/span&gt;的作用？&lt;/p&gt;
</code></pre>
<p>接下来我们就是给span标签中的字体使用特殊字体来展示。</p>
<p>首先我们可以去下载一些自己喜欢的字体：https://www.dafont.com/</p>
<p>并存在才项目的文件夹下，在本实例中我们直接放在了css文件夹中。然后在css文件中配置服务器字体：</p>
<pre><code>@font-face {
	font-family:myfont;
	src: url(&quot;3D.woff&quot;)format(&quot;opentype&quot;);
}
</code></pre>
<p>在这里我们给服务器字体命名为：myfont， 使用src进行引入，format 的作用是进行浏览器识别。不同后缀的字体识别的格式也不一样。一般有以下几种——truetype、opentype、truetype-aat、embedded-opentype、svg 等。</p>
<p>简书上有一个篇文章进行了详细介绍，由于篇幅有限我们不做太多讲解了。</p>
<blockquote>
<p>CSS3 @font-face属性:https://www.jianshu.com/p/c0301e632a01</p>
</blockquote>
<p>定义好字体之后我们就可以进行使用了</p>
<pre><code class="language-css">.svgbox p{
	font-family:myfont;
	margin-top: 15px;
    margin-bottom: 15px;
    font-size: 30px;
    line-height: 1.3;
    font-weight: lighter;
    text-shadow: 0 1px 0 rgba(0,0,0,.15)
}
.svgbox p span{
	font-size:50px;
	padding: 0px 10px;
}
</code></pre>
<p>正如使用普通的字体一般，接下来我们在浏览器中查看效果：</p>
<figure data-type="image" tabindex="14"><img src="https://one-assets.jiker.com/simditor/2019/1218/7nzhFz7QPP9JQeaPzsW77V6PRlCY2anU0bqUYZAg.png" alt="img" loading="lazy"></figure>
<h2 id="4-使用雪碧图完成龙的拼接">4. 使用雪碧图完成龙的拼接</h2>
<p>在项目里我们提供了一条龙的各个部件，并且集和在了一张图上，大家需要通过 background 背景定位的方式把龙组合成一整条龙，</p>
<p>龙的图片比较大，可以先组合好以后通过缩放的方式，将龙缩小到合适的尺寸，来使用。</p>
<p>本案例主要在于介绍雪碧图的使用方式。</p>
<p>思考：</p>
<ul>
<li>雪碧图的优点有哪些？为什么要使用它。</li>
<li>雪碧图的缺点有哪些？</li>
</ul>
<p>相信这写在网络上可以找到很多答案，不过我们还是要知行合一，接下来我将介绍雪碧图的使用。</p>
<p>在开始讲解之前我们来看一个使用雪碧图的实际案例：</p>
<p>TAPD 的官网：https://www.tapd.cn/official/index</p>
<figure data-type="image" tabindex="15"><img src="https://one-assets.jiker.com/simditor/2019/1218/eeZYCwi7zXI9dSu2j0awVurAlIxkIl67JDyFySS8.png" alt="img" loading="lazy"></figure>
<p>雪碧图来完成的图片和 icon：https://www.tapd.cn/sprite/official.sprite+1555295717988.png</p>
<figure data-type="image" tabindex="16"><img src="https://one-assets.jiker.com/simditor/2019/1218/9Lygt5mVlqlHCO6pbonEG6ZBXH8f2uWzqUDo2xwl.png" alt="img" loading="lazy"></figure>
<p>实现原理：</p>
<p>通过 background-posion 控制一个容器的可视范围，在范围内进行背景图片定位。</p>
<p>雪碧图的制作：</p>
<ol>
<li>通过 photoshop 进行拼接</li>
<li>使用 sprite 工具自动生成，如：<br>
CssGaga https://www.99css.com/cssgaga/ 不过只支持 Windows 系统。</li>
</ol>
<p>接下来我们来看下我们龙的实现方式：</p>
<figure data-type="image" tabindex="17"><img src="https://one-assets.jiker.com/simditor/2019/1218/tE2oJ7ahX5nN1MQinmyhRgQ4hSUu4UUYfwZPlTQc.png" alt="img" loading="lazy"></figure>
<p>红色的方框都是 div 通过背景定位来显示龙的各个部位，然后通过该 <code>position:absolute</code> 定位来实现拼接。</p>
<p>首先我看看下龙的 HTML 结构</p>
<pre><code class="language-html">&lt;div id=&quot;dragon&quot;&gt;
			&lt;div class=&quot;head-box&quot;&gt;
				&lt;div class=&quot;head&quot;&gt;&lt;/div&gt;
				&lt;div class=&quot;eyeL&quot;&gt;&lt;/div&gt;
				&lt;div class=&quot;eyeR&quot;&gt;&lt;/div&gt;
				&lt;div class=&quot;beardL&quot;&gt;&lt;/div&gt;
				&lt;div class=&quot;beardR&quot;&gt;&lt;/div&gt;
				&lt;div class=&quot;hair&quot;&gt;&lt;/div&gt;
			&lt;/div&gt;
		
			&lt;div class=&quot;body-box&quot;&gt;
				&lt;div class=&quot;body&quot;&gt;&lt;/div&gt;
				&lt;div class=&quot;clothes&quot;&gt;&lt;/div&gt;
		
				&lt;div class=&quot;armL-box&quot;&gt;
					&lt;div class=&quot;armUpperL&quot;&gt;&lt;/div&gt;
					&lt;div class=&quot;armL&quot;&gt;&lt;/div&gt;
					&lt;div class=&quot;handL&quot;&gt;&lt;/div&gt;
				&lt;/div&gt;
		
				&lt;div class=&quot;armR-box&quot;&gt;
					&lt;div class=&quot;armUpperR&quot;&gt;&lt;/div&gt;
					&lt;div class=&quot;armR&quot;&gt;&lt;/div&gt;
					&lt;div class=&quot;handR&quot;&gt;&lt;/div&gt;
				&lt;/div&gt;
		
				&lt;div class=&quot;legL&quot;&gt;&lt;/div&gt;
				&lt;div class=&quot;legR&quot;&gt;&lt;/div&gt;
		
			&lt;/div&gt;
			&lt;div class=&quot;tail-box&quot;&gt;
				&lt;div class=&quot;tail&quot;&gt;&lt;/div&gt;
				&lt;div class=&quot;tailTip&quot;&gt;&lt;/div&gt;
			&lt;/div&gt;
		&lt;/div&gt;
</code></pre>
<p>我们把头部、身体、衣服、胳膊、腿、尾部拼凑在一起。</p>
<p>接下来我们来看下 CSS 的实现：</p>
<pre><code class="language-css">#dragon {
	position: relative;
	margin: 0px auto;
	
}
#dragon div {
	background: url(../img/texture.png);
	position: absolute;
	z-index: 22;
}
#dragon .head-box {
	position: absolute;
	left: 450px;
	margin-left: -170px;




}
#dragon .head-box .head {
	background-position: 0 0;
	z-index: 22;
	width: 340px;
	height: 394px;
}
#dragon .head-box .eyeL {
	width: 28px;
	height: 46px;
	background-position: -459px -961px;
	left: 65px;
	top: 150px;
	position: absolute;
	z-index: 22;
	animation: eyeL 1s infinite;
}
#dragon .head-box .eyeR {
	width: 37px;
	height: 58px;
	background-position: -420px -961px;
	left: 140px;
	top: 150px;
	animation: eyeR 1s infinite;
}
#dragon .head .beardL {
	width: 119px;
	height: 36px;
	left: -80px;
	top: 283px;
	background-position: -237px -955px;
}
#dragon .head .beardR {
	width: 136px;
	height: 36px;
	left: 120px;
	top: 270px;
	background-position: -99px -955px;
}




#dragon .hair {
	width: 124px;
	height: 282px;
	left: 200px;
	top: 85px;
	z-index: 18;
	background-position: -443px -677px;
}
#dragon .body-box {
	width: 235px;
	height: 347px;
	top: 300px;
	left: 340px;
	z-index: 18;
	background: none;

}
#dragon .body-box .body {
	width: 235px;
	height: 347px;
	background-position: -1px -397px;
}
#dragon .body-box .armUpperL {
	width: 112px;
	height: 86px;
	top: 100px;
	left: -80px;
	z-index: -15;
	background-position: -340px -234px;
}
#dragon .body-box .armL-box {
	z-index: 16;
}
#dragon .body-box .armL-box .armL {
	width: 48px;
	height: 80px;
	z-index: 17;
	top: 115px;
	left: -120px;




	background-position: -373px -859px;
}
#dragon .body-box .armL-box .handL {
	width: 96px;
	height: 78px;
	z-index: 17;
	top: 55px;
	left: -200px;
	background-position: -1px -922px;
}
#dragon .body-box .armR-box {}
#dragon .body-box .armUpperR {
	width: 160px;
	height: 94px;
	z-index: 23;
	left: 110px;
	top: 55px;
	background-position: -211px -859px;
}

#dragon .body-box .armR-box .armR {
	width: 45px;
	height: 77px;
	background-position: -373px -941px;
	left: 230px;
	top: 90px;
	z-index: 23;
	
}
#dragon .body-box .armR-box .handR {
	width: 98px;
	height: 58px;
	background-position: -340px -322px;
	z-index: 24;
	left: 200px;
	top: 160px;
}
#dragon .clothes {
	left: -35px;
	top: 80px;
	width: 208px;
	height: 174px;
	background-position: -1px -746px;
}
#dragon .tail-box {
	width: 216px;
	height: 278px;
	background: none;
	z-index: 16;
	left: 530px;
	top: 380px;
}
#dragon .tail {
	width: 216px;
	height: 278px;
	z-index: 20;
	background-position: -238px -397px;
}
#dragon .tailTip {
	width: 111px;
	height: 209px;
	z-index: 18;
	background-position: -456px -235px;
	top: -150px;
	left: 160px;
}
#dragon .body-box .legR {
	width: 180px;
	height: 231px;
	background-position: -340px -1px;
	z-index: 23;
	top: 250px;
	left: 90px;
	
}
#dragon .body-box .legL {
	width: 203px;
	height: 180px;
	background-position: -238px -677px;
	z-index: 16;
	top: 250px;
	left: -100px;
}
/* 左右眼 */
@keyframes eyeL {
	0% {
		left: 64px;
	}	
	100% {
		left: 66px;
	}
}
@keyframes eyeR {
	0% {
		left: 141px;
	}	
	100% {
		left: 142px;
	}
}

</code></pre>
<p>我们给定义 <code>#dragon</code> 中的每个 div 都设置了相同的背景图片，并设置了绝对定位，然后通过该背景定位的方式让每个部位都可以显示他应该显示发部分。然后通过调整位置让他们到达他们应该在的位置。</p>
<p>最后为了将它放在合适的位置，我们对整条龙进行了缩小。</p>
<h1 id="腾讯首页">腾讯首页</h1>
<h2 id="1-页面结构分析">1. 页面结构分析</h2>
<h3 id="1-页面总体结构">1- 页面总体结构</h3>
<p>首先需要说明一点：页面结构划分不唯一。有点类似一千个人眼中有一千个哈姆雷特，页面结构划分也会因人而异。</p>
<p>接下来我们一起来看下腾讯官网的页面结构：</p>
<p>1） 大颗粒度划分下结构</p>
<p>大颗粒度划分是比较粗的划分方式，可以简单的将页面划分为上，中，下三部分，对应头部，中部（内容区）和底部区域。这样划分整体结构会比较简单，CSS 样式命名更具有层级性。</p>
<figure data-type="image" tabindex="18"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0511/admin/3amL0HqlTfAoHb4VOiy0SMk3OpYka9ooN4PkZnnb.png" alt="效果图" loading="lazy"></figure>
<p>当然大颗粒划分有缺点：大颗粒划分 HTML 耦合度高，如果页面再次改动，改动比较大的话，会导致整体复用性降低。而细颗粒度则不存在这个问题， 细颗粒度划分结构复用性会比较强。</p>
<p>2） 细颗粒度划分结构</p>
<p>相对大颗粒度划分细粒度划分精度高，如下图：</p>
<figure data-type="image" tabindex="19"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0511/admin/chmv5Ii63zRQEKQJKJdNkHFC4VxzraDcWuxH86xH.png" alt="效果图" loading="lazy"></figure>
<p>划分结果：</p>
<p>头部区域、海报区域、面包屑导航区域、媒体库标题、媒体库注释、媒体库内容，关注我们，服务信息和版权新信息。实际开发中要看具体修改频率和修改幅度来定哪种划分方式。</p>
<p>这里说明一下，我们的项目后续任务是按照大颗粒度划分方法和划分结果展开的。另外，因为我们要开发的页面是线上页面，所以很多页面元素间距和尺寸都可以通过浏览器的开发者工具获得。开发者工具可以通过组合按钮：Ctrl + Shift + I 打开，或者通过访问网页点击右键出现菜单项，最后一项检查打开。</p>
<p>3）资源获取</p>
<p>在实际开发中，页面的切图和标注工作大多不是前端开发来做，而是 UI 设计师来做。而我们直接开发线上页面，所以我们可以直接将需要的页面素材通过开发者工具拿过来。至于标注，标注的目的是获取 UI元素的位置、颜色、大小等信息，因为我们这里采用的是线上页面，所以也可以通过开发者工具搞定。</p>
<p>有些图片是可以直接右键拿到的，右键出现“图片另存为…”；如果右键没有这个选项，可以借助开发者工具，如下所示，gif 图中点击图片的“当前来源：”后的 URL。</p>
<figure data-type="image" tabindex="20"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0523/admin/ZMTEtoCTIwT7QHCti7DJJJgZcMUnO4LvPyaMUUXI.gif" alt="效果图" loading="lazy"></figure>
<p>获取尺寸示例：</p>
<figure data-type="image" tabindex="21"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0511/admin/vyxnsDZTRvYK1WkdQCCPmLuA0bsbVZPDkB4jQzMZ.png" alt="效果图" loading="lazy"></figure>
<p>我们要自己练习这两个功能，后面开发的素材和具体尺寸都需要自己去获取。</p>
<p>接下来我们看下每个模块的结构，得出每个部分的布局方案草案。每种布局方案具体是怎么回事大家不用着急搞清楚，任务3我们会讲到。</p>
<h3 id="2-头部分析">2- 头部分析</h3>
<p>头部部分可细分为3部分：头部导航区域，海报区域和面包屑导航区域。</p>
<figure data-type="image" tabindex="22"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0511/admin/GLLYX1LN3AhF6kSIssevW6ieJT8BthqvwbsHlrcq.png" alt="效果图" loading="lazy"></figure>
<p>头部导航区域不是标准的三栏布局，所以采用相对定位更灵活，如果是标准三栏布局（各个子元素间距相同），可以采用弹性布局或者浮动布局。</p>
<p>海报区域：可以通过标签的方式引入图片链接也可以通过背景图的方式引入，之后利用相对定位，定位好图片上的文字。</p>
<p>面包屑导航区域：可以直接采用弹性盒模型的方案，然后利用伪类绘制箭头即可。</p>
<h3 id="3-内容区分析">3- 内容区分析</h3>
<p>内容区细分为媒体库标题，媒体库注释和媒体库内容。</p>
<figure data-type="image" tabindex="23"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0511/admin/H8a5J4cJuL8glESg1XK3mDgICtt88smsQqO7xv7D.png" alt="效果图" loading="lazy"></figure>
<p>媒体库标题：标题可直接使用 HTML <code>h</code> 标题标签。</p>
<p>媒体库注释：使用 <code>p</code> 或者 <code>h</code> 标签。</p>
<p>媒体库内容：内容区的导航可以使用弹性布局或者浮动布局；其下的图片区域也可以使用弹性盒子模型；最后一个上面带有文字，实际和海报上面有文字方案一致，采用相对定位布局。</p>
<h3 id="4-底部分析">4- 底部分析</h3>
<p>底部区域细分为关注我们，服务信息和版权信息。</p>
<figure data-type="image" tabindex="24"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0511/admin/aOViSZoKLq9fQgTXJS8dSVjJSmijSqdS6y5Yfzqi.png" alt="效果图" loading="lazy"></figure>
<p>关注我们：可以直接使用 <code>span</code> 和 <code>img</code> 内联标签，之后调整间距即可，也可以采用弹性布局。</p>
<p>服务信息：加入我们，联系我们，法律信息可以采用浮动布局方案，后面的腾讯 logo 采用相对定位布局。</p>
<p>版权信息：两个<code>p</code> 标签即可。</p>
<h2 id="2-基础样式编辑">2. 基础样式编辑</h2>
<h3 id="1-完成基础样式编写">1- 完成基础样式编写</h3>
<p>基础样式是为了解决各个浏览器之间 CSS 默认值差异问题。目前也有一些成熟的解决方案比如 reset.css 和 Normalize.css，我们这里相当于 reset.css 的简版。代码如下：</p>
<pre><code class="language-css">a,
  b,
  big,
  body,
  dd,
  del,
  div,
  dl,
  dt,
  em,
  font,
  form,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  html,
  i,
  iframe,
  img,
  ins,
  label,
  li,
  ol,
  p,
  pre,
  small,
  span,
  strong,
  u,
  ul {
    margin: 0;
    padding: 0
}

a {
    text-decoration: none;
}

ul,
li {
    list-style: none;
}
</code></pre>
<p>以上基础样式部分大家可以自行存储以方便日后的页面开发复用。</p>
<h3 id="2-开发整体框架结构的-html-代码">2- 开发整体框架结构的 HTML 代码</h3>
<p>整体页面分为三个部分：头部、内容、底部，相对应3个 <code>div</code> 的 <code>class</code> 名分别为 <code>header</code>、<code>content</code> 和 <code>footer</code>。</p>
<pre><code class="language-html">&lt;!-- 头部区域 --&gt;
 &lt;div class=&quot;header&quot;&gt;
 &lt;/div&gt;
 &lt;!-- 内容区域 --&gt;
 &lt;div class=&quot;content&quot;&gt;
 &lt;/div&gt;
 &lt;!-- 底部区域 --&gt;
 &lt;div class=&quot;footer&quot;&gt;
 &lt;/div&gt;
</code></pre>
<h2 id="3-模块开发">3. 模块开发</h2>
<p>我们在任务1中提到了三种布局方式：弹性盒子布局，相对定位布局和浮动布局。在这里我们来进一步的阐述与实现。</p>
<p>1）弹性布局</p>
<p>通过 <code>display:flex</code> 开启，既可以实现水平方向布局也可以实现垂直方向布局。当盒子宽度不够时，盒子内部元素可以自动换行。适合比较标准的布局方式，也就是内容间距相对统一，尤其适合对自适应要求比较高的标准布局。参考：<a href="https://blog.csdn.net/Mq_sir/article/details/118545778">CSS 弹性盒子布局详解</a>。</p>
<p>2）相对定位布局</p>
<p>父元素相对定位，子元素绝对定位，俗称“子绝父相”，同上既可以实现水平方向布局也可以实现垂直方向布局。相对定位布局适合无统一标准的布局，也就是间距没有明显规律。另外相对布局也适合 <code>z-index</code>方向的层级布局，适合背景图片上面有文字甚至多层的情况。参考：<a href="https://blog.csdn.net/m0_64346035/article/details/124116447">CSS中更加高级的布局手段–定位之相对定位</a>。</p>
<p>3）浮动布局</p>
<p>通过 <code>float:left</code> 或者 <code>float:right</code> 开启，仅可以进行水平方向布局，适合比较标准的布局方式。浮动元素有缺点的地方：会对其后面的元素有影响，导致后面元素继承浮动。为了消除这种影响需要使用 <code>clear:left</code> 或 <code>clear:right</code>清除。参考：<a href="https://blog.csdn.net/Czc1357618897/article/details/122980847">CSS浮动</a>。</p>
<p>至于三种布局方式的其它特性，随着学习的深入，你们可以自行总结。下面我们一起来开始着手开发各个模块。</p>
<h3 id="1-头部开发">1- 头部开发</h3>
<p>头部分成三部分：头部导航、头部海报和头部面包屑。</p>
<p>头部导航要求水平方向上布局，因为各个标签元素之间的间距不统一，所以这里采用相对定位布局。</p>
<h4 id="1-1-头部导航">1-1 头部导航</h4>
<p>1）头部导航 HTML</p>
<pre><code class="language-html">&lt;div class=&quot;header&quot;&gt;
    &lt;!-- 头部导航 --&gt;
    &lt;div class=&quot;header-nav&quot;&gt;
        &lt;a class=&quot;logo&quot;&gt;
            &lt;img src=&quot;./imgs/tencent_logo.png&quot; alt=''&gt;
        &lt;/a&gt;
        &lt;ul class=&quot;menu-list&quot;&gt;
            &lt;li&gt;
                &lt;a href=&quot;https://www.tencent.com/zh-cn/about.html&quot;&gt;简介&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&quot;https://www.tencent.com/zh-cn/business.html&quot;&gt;业务&lt;/a&gt;

            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&quot;https://www.tencent.com/zh-cn/employees.html&quot;&gt;员工&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&quot;https://www.tencent.com/zh-cn/esg.html&quot;&gt;ESG&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&quot;https://www.tencent.com/zh-cn/investors.html&quot;&gt;投资者&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&quot;https://www.tencent.com/zh-cn/media.html&quot;&gt;媒体&lt;/a&gt;
            &lt;/li&gt;

        &lt;/ul&gt;
        &lt;div class=&quot;lang-area&quot;&gt;
            &lt;a&gt;简&lt;/a&gt; &lt;i class=&quot;s-line&quot;&gt;|&lt;/i&gt; &lt;a&gt;繁&lt;/a&gt; &lt;i class=&quot;s-line&quot;&gt;|&lt;/i&gt; &lt;a&gt;EN&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>强调一些点：头部的 logo 外面要用<code>a</code>标签包起来，因为网站的 logo 大都可以点击跳转。头部 logo 最好采用直接<code>img</code>引入图片的方式而不是<code>background</code>引入的方式，因为从浏览器渲染原理来讲<code>img</code>呈现的速度要比背景图片快。</p>
<p>2）头部导航CSS</p>
<pre><code class="language-css">.header .header-nav {
    margin: 0px auto;
    height: 72px;
    width: 1200px;
    position: relative;
    display: flex;
}

.header .header-nav .logo {
    position: absolute;
    top: 25px;
}

.header .header-nav .logo img {
    height: 22px;
    width: 168px;
}

.header .header-nav .menu-list {
    display: block;
    height: 72px;
    position: absolute;
    right: 160px;
    top: 0px;
    cursor: pointer;
}

.header .header-nav .menu-list li {
    display: inline-block;
    height: 72px;
    margin-left: 72px;

}

.header .header-nav .menu-list li a {
    color: #2b2e2e;
    font-size: 16px;
    font-weight: bold;
    display: block;
    height: 72px;
    line-height: 72px;
}

.header .header-nav .lang-area {
    position: absolute;
    right: 0;
    top: 25px;
}

.header .header-nav .lang-area a:nth-child(n+2) {
    opacity: 0.7;

}

.header .header-nav .lang-area .s-line {
    font-size: 12px;
    margin: 0px 3px;
    position: relative;
    top: -2px;
    opacity: 0.7;
}
</code></pre>
<p>3）头部导航预览</p>
<figure data-type="image" tabindex="25"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0523/admin/ISqifLJcm5BNIYHIN1ZNefMjb5mSRhz6oC2cMCkH.png" alt="image.png" loading="lazy"></figure>
<h4 id="1-2-头部海报">1-2 头部海报</h4>
<p>头部海报因为背景图片上有文字所以采用相对定位布局。</p>
<p>1）头部海报 HTML 结构</p>
<pre><code class="language-html">&lt;div class=&quot;header&quot;&gt;
    &lt;div class=&quot;header-banner&quot;&gt;
        &lt;div class=&quot;banner-img-box&quot;&gt;
            &lt;img src=&quot;./imgs/media-1.jpg&quot; alt=&quot;腾讯新闻&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;banner-txt&quot;&gt;
            &lt;h2&gt;媒体资料库&lt;/h2&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>注意，图片标签<code>img</code>最好加上<code>alt</code>属性，这个有利于 seo，也就是搜索引擎优化，搜索引擎优化是另一个领域的知识点，在这里我们只知晓即可。</p>
</blockquote>
<p>2）头部海报 CSS</p>
<pre><code class="language-css">.header .header-banner {
    position: relative;
}

.header .banner-img-box {
    position: relative;
    overflow: hidden;
    height: 240px;
}

.header .banner-img-box img {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.header .banner-txt {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    flex-direction: row;
    padding: 0px 80px;
    box-sizing: border-box;
}

.header .banner-txt h2 {
    font-size: 32px;
    margin: 12px 0px;
    padding: 0px;
    font-weight: 100;
    font-style: italic;
}
</code></pre>
<p>这里我们关注logo 的<code>object-fit</code>，这个 CSS 属性可以调整图片的显示方式，进而调整显示内容的多少。</p>
<p>3）头部海报预览</p>
<figure data-type="image" tabindex="26"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0523/admin/bLyKhel2YbORttcPv2PN1xl0PXZziq4aCujxLrXP.png" alt="image.png" loading="lazy"></figure>
<h4 id="1-3-头部面包屑">1-3 头部面包屑</h4>
<p>头部面包屑要求水平方向上布局，因为各个标签元素之间间距统一，所以可以采用弹性布局或浮动布局，我们这里采用弹性布局。</p>
<p>1）头部面包屑 HTML 结构</p>
<pre><code>&lt;div class=&quot;header&quot;&gt;
    &lt;div class=&quot;header-breadcrumb&quot;&gt;
        &lt;div class=&quot;breadcrumb-con&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;a href=&quot;https://www.tencent.com/zh-cn/index.html&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;https://www.tencent.com/zh-cn/media.html&quot;&gt;媒体&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;https://www.tencent.com/zh-cn/media/library.html&quot;&gt;媒体资料库&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>2）头部面包屑 CSS</p>
<pre><code>.header .header-breadcrumb {
    background: #FBFBFB;
    padding: 18px 0px;
}

.header .header-breadcrumb .breadcrumb-con {
    max-width: 1200px;
    margin: 0 auto;
}

.header .header-breadcrumb .breadcrumb-con ul {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    flex-wrap: wrap;
}

.header .header-breadcrumb .breadcrumb-con li {
    margin: 0px 12px 0px 0px;
}

.header .header-breadcrumb .breadcrumb-con li a {
    color: inherit;
}

.header .header-breadcrumb .breadcrumb-con li:nth-child(-n + 2)::after {
    content: &quot;&quot;;
    display: inline-block;
    vertical-align: middle;
    width: 6px;
    height: 6px;
    margin-left: 12px;
    border-top: 1px solid #2b2e2e;
    border-right: 1px solid #2b2e2e;
    transform: rotate(45deg);
}
</code></pre>
<p>关注用来绘制面包屑导航的样式：利用伪类 <code>:after</code> 结合三角形的边框加上 <code>transform</code> 形成，这是一个特定样式，可以保存下来以后同样的场景借鉴此处。</p>
<p>3）头部面包屑预览</p>
<figure data-type="image" tabindex="27"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0523/admin/o05F0cvfxyBi1pD2Rm3cVWEGu5pWGGUx09eXNb5a.png" alt="image.png" loading="lazy"></figure>
<h4 id="1-4-头部整体-html">1-4 头部整体 HTML</h4>
<pre><code>&lt;!-- 头部区域 --&gt;
 &lt;div class=&quot;header&quot;&gt;
     &lt;!-- 头部导航 相对定位布局--&gt;
     &lt;div class=&quot;header-nav&quot;&gt;
         &lt;a class=&quot;logo&quot;&gt;
            &lt;img src=&quot;./imgs/tencent_logo.png&quot;&gt;
         &lt;/a&gt;
         &lt;ul class=&quot;menu-list&quot;&gt;
             &lt;li&gt;
                 &lt;a href=&quot;https://www.tencent.com/zh-cn/about.html&quot;&gt;简介&lt;/a&gt;
             &lt;/li&gt;
             &lt;li&gt;
                 &lt;a href=&quot;https://www.tencent.com/zh-cn/business.html&quot;&gt;业务&lt;/a&gt;
             &lt;/li&gt;
             &lt;li&gt;
                 &lt;a href=&quot;https://www.tencent.com/zh-cn/employees.html&quot;&gt;员工&lt;/a&gt;
             &lt;/li&gt;
             &lt;li&gt;
                 &lt;a href=&quot;https://www.tencent.com/zh-cn/esg.html&quot;&gt;ESG&lt;/a&gt;
             &lt;/li&gt;
             &lt;li&gt;
                 &lt;a href=&quot;https://www.tencent.com/zh-cn/investors.html&quot;&gt;投资者&lt;/a&gt;
             &lt;/li&gt;
             &lt;li&gt;
                 &lt;a href=&quot;https://www.tencent.com/zh-cn/media.html&quot;&gt;媒体&lt;/a&gt;
             &lt;/li&gt;
        &lt;/ul&gt;
        &lt;div class=&quot;lang-area&quot;&gt;
            &lt;a&gt;简&lt;/a&gt;
            &lt;i class=&quot;s-line&quot;&gt;&quot;&lt;/i&gt;
            &lt;a&gt;繁&lt;/a&gt;
            &lt;i class=&quot;s-line&quot;&gt;&quot;&lt;/i&gt;
            &lt;a&gt;EN&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 头部海报 相对定位布局--&gt;
    &lt;div class=&quot;header-banner&quot;&gt;
        &lt;div class=&quot;banner-img-box&quot;&gt;
            &lt;img src=&quot;./imgs/media-1.jpg&quot; alt=&quot;腾讯新闻&quot;&gt;
        &lt;/div&gt;
        &lt;div class=&quot;banner-txt&quot;&gt;
            &lt;h2&gt;媒体资料库&lt;/h2&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 头部面包屑 弹性盒布局--&gt;
    &lt;div class=&quot;header-breadcrumb&quot;&gt;
        &lt;div class=&quot;breadcrumb-con&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;
                    &lt;a href=&quot;https://www.tencent.com/zh-cn/index.html&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;https://www.tencent.com/zh-cn/media.html&quot;&gt;媒体&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;https://www.tencent.com/zh-cn/media/library.html&quot;&gt;媒体资料库&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h4 id="1-5-头部整体-css">1-5 头部整体 CSS</h4>
<pre><code>.header {
    width: 100%;
}

.header .header-nav {
    margin: 0px auto;
    height: 72px;
    width: 1200px;
    position: relative;
    display: flex;
}

.header .header-nav .logo {
    position: absolute;
    top: 25px;
}

.header .header-nav .logo img {
    height: 22px;
    width: 168px;
}

.header .header-nav .menu-list {
    display: block;
    height: 72px;
    position: absolute;
    right: 160px;
    top: 0px;
    cursor: pointer;
}

.header .header-nav .menu-list li {
    display: inline-block;
    height: 72px;
    margin-left: 72px;
}

.header .header-nav .menu-list li a {
    color: #2b2e2e;
    font-size: 16px;
    font-weight: bold;
    display: block;
    height: 72px;
    line-height: 72px;
}

.header .header-nav .lang-area {
    position: absolute;
    right: 0;
    top: 25px;
}

.header .header-nav .lang-area a:nth-child(n+2) {
    opacity: 0.7;
}

.header .header-nav .lang-area .s-line {
    font-size: 12px;
    margin: 0px 3px;
    position: relative;
    top: -2px;
    opacity: 0.7;
}

.header .header-banner {
    position: relative;
}

.header .banner-img-box {
    position: relative;
    overflow: hidden;
    height: 240px;
}

.header .banner-img-box img {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.header .banner-txt {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    padding: 0px 80px;
    box-sizing: border-box;
}

.header .banner-txt h2 {
    font-size: 32px;
    margin: 12px 0px;
    padding: 0px;
    font-weight: 100;
    font-style: italic;
}

.header .header-breadcrumb {
    background: #FBFBFB;
    padding: 18px 0px;
}

.header .header-breadcrumb .breadcrumb-con {
    max-width: 1200px;
    margin: 0 auto;
}

.header .header-breadcrumb .breadcrumb-con ul {
    display: flex;
}

.header .header-breadcrumb .breadcrumb-con li {
    margin: 0px 12px 0px 0px;
}

.header .header-breadcrumb .breadcrumb-con li a {
    color: inherit;
}

.header .header-breadcrumb .breadcrumb-con li:nth-child(-n + 2)::after {
    content: &quot;&quot;;
    display: inline-block;
    vertical-align: middle;
    width: 6px;
    height: 6px;
    margin-left: 12px;
    border-top: 1px solid #2b2e2e;
    border-right: 1px solid #2b2e2e;
    transform: rotate(45deg);
}
</code></pre>
<h3 id="2-内容区开发">2- 内容区开发</h3>
<p>内容区分成三部分：内容标题、内容注释和内容数据。</p>
<p>内容标题只是一行文字不涉及布局方案，直接采用<code>h2</code>标签，内容注释同理采用<code>h5</code>标签。内容数据主要要求水平方向上布局，因为图片部分间距统一且会要求自适应，所以我们采用弹性布局。</p>
<h4 id="2-1-内容区-html">2-1 内容区 HTML</h4>
<pre><code>&lt;!-- 内容区域 --&gt;
&lt;div class=&quot;content&quot;&gt;
    &lt;!-- 内容标题 --&gt;
    &lt;h2 class=&quot;content-title&quot;&gt;欢迎来到腾讯媒体资料库&lt;/h2&gt;
    &lt;!-- 内容注释 --&gt;
    &lt;h5 class=&quot;content-tip&quot;&gt;
        媒体库中的图像和视频仅供个人或编辑使用。请求更多信息您可以发送电子邮件至&lt;a href=&quot;mailto:gc@tencent.com&quot;&gt;gc@tencent.com&lt;/a&gt;
    &lt;/h5&gt;
    &lt;!-- 内容数据 弹性盒布局--&gt;
    &lt;div class=&quot;content-data&quot;&gt;
        &lt;div class=&quot;tab-box&quot;&gt;
            &lt;a class=&quot;ative&quot;&gt;企业图片&lt;/a&gt;
            &lt;a&gt;活动图集&lt;/a&gt;
            &lt;a&gt;视频资料&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;img-box&quot;&gt;
            &lt;div&gt;
                &lt;img src=&quot;./imgs/media.jpg&quot; alt=&quot;媒体资料库&quot;&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;img src=&quot;./imgs/media.jpg&quot; alt=&quot;媒体资料库&quot;&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;img src=&quot;./imgs/media.jpg&quot; alt=&quot;媒体资料库&quot;&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;img src=&quot;./imgs/media.jpg&quot; alt=&quot;媒体资料库&quot;&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;img src=&quot;./imgs/media.jpg&quot; alt=&quot;媒体资料库&quot;&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;img src=&quot;./imgs/media.jpg&quot; alt=&quot;媒体资料库&quot;&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;img src=&quot;./imgs/media.jpg&quot; alt=&quot;媒体资料库&quot;&gt;
            &lt;/div&gt;
            &lt;div class=&quot;last-img&quot;&gt;
                &lt;img src=&quot;./imgs/media.jpg&quot; alt=&quot;媒体资料库&quot;&gt;
                &lt;div class=&quot;img-blue&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;img-txt&quot;&gt;
                    &lt;a&gt;
                        &lt;h3&gt;查看全部&lt;/h3&gt;
                        &lt;p&gt;10张图片&lt;/p&gt;
                    &lt;/a&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>我们可以关注学习下上面邮箱的 <code>a</code> 标签：</p>
<pre><code>&lt;a href=&quot;mailto:gc@tencent.com&quot;&gt;gc@tencent.com&lt;/a&gt;
</code></pre>
<p><code>a</code> 标签的 <code>href</code> 属性也可以跳转到邮箱。要了解到<code>href</code>不仅可以是一个URL，还可以是一个邮箱地址。</p>
<h4 id="2-2-内容区-css">2-2 内容区 CSS</h4>
<pre><code>.content {
    margin: 0 auto;
    max-width: 1200px;
    padding-top: 72px;
}

.content .content-title {
    margin-bottom: 40px;
    font-size: 32px;
    color: #0052D9;
    font-weight: normal;
}

.content .content-tip {
    font-size: 18px;
    font-weight: normal;
    margin: 12px 0px;
}

.content .content-tip a {
    color: #0A43C8;
}

.content .content-data .tab-box {
    margin: 36px 0px;
    padding: 0 12px;
}

.content .content-data .tab-box a {
    font-weight: bold;
    padding: 6px 0px;
    margin: 0px 24px 0px 0px;
}

.content .content-data .tab-box a.ative {
    border-bottom: 3px solid #0052D9;
    color: #0052D9;
}

.content .content-data .img-box {
    display: flex;
    flex-wrap: wrap;
    margin: 36px 0px 36px -24px;
}

.content .content-data .img-box&gt;div {
    width: calc(25% - 24px);
    height: 188px;
    margin: 0px 0px 24px 24px;
}

.content .content-data .img-box&gt;div img {
    height: 100%;
    width: 100%;
}

.content  .content-data .last-img {
    position: relative;
}

.content  .content-data .last-img .img-blue {
    position: absolute;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    background: rgba(25, 74, 195, 0.8);
}

.content  .content-data .last-img .img-txt {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0px;
    text-align: center;
    display: flex;
    align-items: center;
}

.content  .content-data .last-img .img-txt a {
    width: 100%;
}

.content  .content-data .last-img .img-txt a h3 {
    font-size: 24px;
    margin: 12px 0px;
    color: #fff;
    font-weight: normal;
}

.content  .content-data .last-img .img-txt a p {
   font-size: 16px;
   line-height: 1.5em;
   margin: 12px 0px;
   padding: 0px;
   color: #fff;
   font-weight: normal;
}
</code></pre>
<p>上面图片宽度计算时用了属性 <code>calc</code> ：</p>
<pre><code>.content .content-data .img-box&gt;div {
    width: calc(25% - 24px);
    height: 188px;
    margin: 0px 0px 24px 24px;
}
</code></pre>
<p><code>calc</code> 这个是 CSS 计算属性，它可以用来动态计算数值，宽度、高度等。它的用法有一个需要注意的地方，就是 ( ) 括号内中间的符号两边必须有空格，否则会失效。</p>
<p>内容区预览：</p>
<figure data-type="image" tabindex="28"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0523/admin/yEAbuAfixntEyDCpN9wBqLUEaIp8YqtuHLl5R2R3.png" alt="image.png" loading="lazy"></figure>
<h3 id="3-底部区域开发">3- 底部区域开发</h3>
<p>底部区域分成三部分：关注我们、相关服务和版权信息。</p>
<h4 id="3-1-关注我们">3-1 关注我们</h4>
<p>关注我们要求水平方向上布局，因为间距统一，所以可以采用弹性布局或者浮动布局，这里我们采用的是弹性布局。</p>
<p>1）关注我们 HTML 结构</p>
<pre><code>&lt;div class=&quot;footer&quot;&gt;
    &lt;!-- 底部盒子 --&gt;
    &lt;div class=&quot;footer-wrap&quot;&gt;
        &lt;!-- 关注我们 --&gt;
        &lt;div class=&quot;focus-us&quot;&gt;
            &lt;h3&gt;关注我们&lt;/h3&gt;
            &lt;ul class=&quot;focus-list&quot;&gt;
                &lt;li&gt;
                    &lt;img src=&quot;./imgs/icon_wechat.png&quot; alt=&quot;img&quot;&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;img src=&quot;./imgs/icon_weibo.png&quot; alt=&quot;img&quot;&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;img src=&quot;./imgs/icon_twitter.png&quot; alt=&quot;img&quot;&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;img src=&quot;./imgs/icon_in.png&quot; alt=&quot;img&quot;&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>2）关注我们 CSS</p>
<pre><code>.footer {
    width: 100%;
    background: #fbfbfb;
}

.footer .footer-wrap {
    width: 1200px;
    margin: 0px auto;
    height: 480px;
    position: relative;
}

.footer .footer-wrap .focus-us h3 {
    font-weight: normal;
    margin-right: 33px;
}

.footer .footer-wrap .focus-us {
    display: flex;
    height: 55px;
    width: 100%;
    border-bottom: 1px solid #f2f3f5;
    padding-top: 33px;
    margin-bottom: 40px;
    box-sizing: content-box;

}

.footer .footer-wrap .focus-us .focus-list {
    display: flex;
}

.footer .footer-wrap .focus-us .focus-list li {
    margin-right: 28px;
}

.footer .footer-wrap .focus-us .focus-list li img {
    width: 28px;
    height: 28px;
}
</code></pre>
<p>3）关注我们预览</p>
<figure data-type="image" tabindex="29"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0523/admin/BJprxC41G38YySnvCdLI4pFGCWwuc1wbY0cVwwWR.png" alt="image.png" loading="lazy"></figure>
<h4 id="3-2-相关服务">3-2 相关服务</h4>
<p>相关服务主要要求水平方向上布局，腾讯 logo 因为位置比较特殊，所以采用相对定位布局；除了 logo 的剩余部分间距统一且要求在水平方向上布局，所以可以使用弹性布局与浮动布局，这里我们采用浮动布局。</p>
<p>1）相关服务 HTML</p>
<pre><code>&lt;div class=&quot;footer&quot;&gt;
    &lt;!-- 底部盒子 --&gt;
    &lt;div class=&quot;footer-wrap&quot;&gt;
        &lt;div class=&quot;service&quot;&gt;
            &lt;div class=&quot;join-us&quot;&gt;
                &lt;!-- 添加类名 sublist_show 显示子菜单 --&gt;
                &lt;h3&gt;加入我们&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://careers.tencent.com/&quot;&gt;社会招聘&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://join.qq.com/&quot;&gt;校园招聘&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://careers.tencent.com/en-us/home.html&quot;&gt;国际招聘&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            &lt;div class=&quot;contact-us&quot;&gt;
                &lt;h3&gt;联系我们&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/customer-service.html&quot;&gt;客户服务&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/partnership.html&quot;&gt;合作洽谈&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://spd.tencent.com/portal&quot;&gt;腾讯采购&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/enquiry.html&quot;&gt;媒体及投资者&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;h3&gt;法律信息&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/service-agreement.html&quot;&gt;服务协议&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/privacy-policy.html&quot;&gt;隐私政策&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://ipr.tencent.com/&quot;&gt;知识产权&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;!-- 腾讯logo --&gt;
        &lt;div class=&quot;tencent-logo&quot;&gt;
            &lt;img src=&quot;./imgs/tencent_logo.png&quot; alt=&quot;Tencent腾讯&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>2）相关服务 CSS</p>
<pre><code>.footer .footer-wrap .service .join-us {
    float: left;
    width: 216px;
}

.footer .footer-wrap .service .contact-us {
    float: left;
    width: 216px;
}

.footer .footer-wrap .service h3 {
    font-size: 20px;
    color: #5f6464;
    font-weight: normal;
    margin-bottom: 30px;
}

.footer .footer-wrap .service ul li a {
    display: block;
    font-size: 16px;
    color: #5f6464;
    font-weight: normal;
    margin-bottom: 18px;
}

.footer .footer-wrap .tencent-logo {
    display: block;
    height: 28px;
    width: 212px;
    position: absolute;
    right: 75px;
    top: 50%;
    margin-top: -21px;
}

.footer .footer-wrap .tencent-logo img {
    width: 100%;
}
</code></pre>
<p>3）相关服务预览</p>
<figure data-type="image" tabindex="30"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0523/admin/8pTNspeYDPbzfxdJzLnTZwBbfoO2eQ7i7Cwpt38z.png" alt="image.png" loading="lazy"></figure>
<h4 id="3-3-版权信息">3-3 版权信息</h4>
<p>版权信息两个块元素标签即可实现。</p>
<p>1）版权信息 HTML</p>
<pre><code>&lt;div class=&quot;footer&quot;&gt;
    &lt;!-- 底部盒子 --&gt;
    &lt;div class=&quot;footer-wrap&quot;&gt;
        &lt;div class=&quot;copyright-box&quot;&gt;
            &lt;ul class=&quot;links&quot;&gt;
                &lt;li&gt;
                    &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/statement.html&quot;&gt;法律声明&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/integrity-policy.html&quot;&gt;阳光准则&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/sitemap.html&quot;&gt;网站地图&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a target=&quot;_blank&quot; href=&quot;http://beian.miit.gov.cn/&quot;&gt;粤网文【2017】6138-1456号&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a target=&quot;_blank&quot; href=&quot;http://beian.miit.gov.cn/&quot;&gt;粤B2-20090059&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a target=&quot;_blank&quot; href=&quot;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030502008569&quot;&gt;粤公网安备
                        44030502008569号&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
            &lt;p class=&quot;copyright&quot;&gt;
                Copyright © 1998 - 2022 Tencent. All Rights Reserved. 腾讯公司 版权所有
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>这块可以关注学习 <code>a</code> 标签的另一个属性<code>target</code>，<code>target</code>可以当前窗口打开，也可以 <code>&quot;_blank&quot;</code> 新窗口打开，默认是当前窗口。</p>
<p>2）版权信息 CSS</p>
<pre><code>.footer .footer-wrap .copyright-box {
    clear: both;
    padding-top: 18px;
}

.footer .footer-wrap .copyright-box .links {
    display: flex;
}

.footer .footer-wrap .copyright-box .links li {
    display: inline-block;
    margin-right: 20px;
}

.footer .footer-wrap .copyright-box .links li a {
    font-size: 14px;
    color: #5f6464;
    margin-bottom: 0px;
}

.footer .footer-wrap .copyright-box .copyright {
    font-size: 14px;
    color: #5f6464;
    float: left;
    width: 100%;
    margin-top: 12px;
}
</code></pre>
<p>上面有一个样式：</p>
<pre><code>.footer .footer-wrap .copyright-box {
    clear: both;
    padding-top: 18px;
 }
</code></pre>
<p>这里用了<code>clear:both</code>，这个用法既可以清除左浮动也可以清除右浮动，确保当前元素不上浮。</p>
<p>3）版权信息预览</p>
<figure data-type="image" tabindex="31"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0523/admin/8aaoiGv7Fa7SqDrAWLBHbjI8lkIDzXqiPTnRQ53N.png" alt="image.png" loading="lazy"></figure>
<h4 id="3-4-底部区域整体-html">3-4 底部区域整体 HTML</h4>
<pre><code>&lt;!-- 底部区域 --&gt;
&lt;div class=&quot;footer&quot;&gt;
    &lt;!-- 底部盒子 浮动布局、相对定位--&gt;
    &lt;div class=&quot;footer-wrap&quot;&gt;
        &lt;!-- 关注我们 弹性盒子布局--&gt;
        &lt;div class=&quot;focus-us&quot;&gt;
            &lt;h3&gt;关注我们&lt;/h3&gt;
            &lt;ul class=&quot;focus-list&quot;&gt;
                &lt;li&gt;
                    &lt;img src=&quot;./imgs/icon_wechat.png&quot; alt=&quot;img&quot;&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;img src=&quot;./imgs/icon_weibo.png&quot; alt=&quot;img&quot;&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;img src=&quot;./imgs/icon_twitter.png&quot; alt=&quot;img&quot;&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;img src=&quot;./imgs/icon_in.png&quot; alt=&quot;img&quot;&gt;
                &lt;/li&gt;
           &lt;/ul&gt;
        &lt;/div&gt;
        &lt;!-- 相关服务  浮动布局和相对定位布局--&gt;
        &lt;div class=&quot;service&quot;&gt;
            &lt;div class=&quot;join-us&quot;&gt;
                &lt;h3&gt;加入我们&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://careers.tencent.com/&quot;&gt;社会招聘&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://join.qq.com/&quot;&gt;校园招聘&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://careers.tencent.com/en-us/home.html&quot;&gt;国际招聘&lt;/a&gt;
                    &lt;/li&gt;
               &lt;/ul&gt;
            &lt;/div&gt;
            &lt;div class=&quot;contact-us&quot;&gt;
                &lt;h3&gt;联系我们&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/customer-service.html&quot;&gt;客户服务&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/partnership.html&quot;&gt;合作洽谈&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://spd.tencent.com/portal&quot;&gt;腾讯采购&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/enquiry.html&quot;&gt;媒体及投资者&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;h3&gt;法律信息&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/service-agreement.html&quot;&gt;服务协议&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/privacy-policy.html&quot;&gt;隐私政策&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;li&gt;
                        &lt;a target=&quot;_blank&quot; href=&quot;https://ipr.tencent.com/&quot;&gt;知识产权&lt;/a&gt;
                    &lt;/li&gt;
                 &lt;/ul&gt;
            &lt;/div&gt;
         &lt;/div&gt;
         &lt;!-- 腾讯logo --&gt;
         &lt;div class=&quot;tencent-logo&quot;&gt;
             &lt;img src=&quot;./imgs/tencent_logo.png&quot; alt=&quot;Tencent腾讯&quot;&gt;
         &lt;/div&gt;
         &lt;!-- 版权信息 --&gt;
         &lt;div class=&quot;copyright-box&quot;&gt;
             &lt;p class=&quot;links&quot;&gt;
                 &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/statement.html&quot;&gt;法律声明&lt;/a&gt;
                 &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/integrity-policy.html&quot;&gt;阳光准则&lt;/a&gt;
                 &lt;a target=&quot;_blank&quot; href=&quot;https://www.tencent.com/zh-cn/sitemap.html&quot;&gt;网站地图&lt;/a&gt;
                 &lt;a target=&quot;_blank&quot; href=&quot;http://beian.miit.gov.cn/&quot;&gt;粤网文【2017】6138-1456号&lt;/a&gt;
                 &lt;a target=&quot;_blank&quot; href=&quot;http://beian.miit.gov.cn/&quot;&gt;粤B2-20090059&lt;/a&gt;
                 &lt;a target=&quot;_blank&quot; href=&quot;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030502008569&quot;&gt;粤公网安备
                 44030502008569号&lt;/a&gt;
             &lt;/p&gt;
             &lt;p class=&quot;copyright&quot;&gt;
                 Copyright © 1998 - 2022 Tencent. All Rights Reserved. 腾讯公司 版权所有
             &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h4 id="3-3-5-底部区整体-css">3-3-5 底部区整体 CSS</h4>
<pre><code>.footer {
    width: 100%;
    background: #fbfbfb;
}

.footer .footer-wrap {
    width: 1200px;
    margin: 0px auto;
    height: 480px;
    position: relative;
}

.footer .footer-wrap .focus-us h3 {
    font-weight: normal;
    margin-right: 33px;
}

.footer .footer-wrap .focus-us {
    display: flex;
    height: 55px;
    width: 100%;
    border-bottom: 1px solid #f2f3f5;
    padding-top: 33px;
    margin-bottom: 40px;
}

.footer .footer-wrap .focus-us .focus-list {
    display: flex;
}

.footer .footer-wrap .focus-us .focus-list li {
    margin-right: 28px;
}

.footer .footer-wrap .focus-us .focus-list li img {
    width: 28px;
    height: 28px;
}

.footer .footer-wrap .service .join-us {
    float: left;
    width: 216px;
}
</code></pre>
<h2 id="4-页面优化">4. 页面优化</h2>
<h3 id="1-html-使用优化">1- HTML 使用优化</h3>
<p>1） 使用更加语义化的标签</p>
<p>语义化提高了代码的可读性和结构化，便于后期维护和不同开发者之间的协作。针对这点我们可以将头部区域的 <code>div</code> 标签改为 <code>header</code>标签，底部区域标签改为 <code>footer</code>。代码如下：</p>
<pre><code>&lt;!-- 头部区域 --&gt;
  &lt;header class=&quot;header&quot;&gt;
  &lt;/header&gt;
  &lt;!-- 内容区域 --&gt;
  &lt;div class=&quot;content&quot;&gt;
  &lt;/div&gt;
  &lt;!-- 底部区域 --&gt;
  &lt;footer class=&quot;footer&quot;&gt;
  &lt;/footer&gt;
</code></pre>
<h3 id="2-css-使用优化">2- CSS 使用优化</h3>
<p>1） 优化 CSS 样式的命名规则，让其更具有完整语义化和层级性。</p>
<p>比如我们可以优化头部部分样式，代码如下：</p>
<p>优化前：</p>
<pre><code>.header .header-nav .logo {
    position: absolute;
    top: 25px;
}
</code></pre>
<p>优化后：</p>
<pre><code>.header .header-nav .header-nav-logo {
    position: absolute;
    top: 25px;
}
</code></pre>
<p>优化前：</p>
<pre><code>.header .header-nav .logo h1 {
    position: absolute;
    top: 25px;
}
</code></pre>
<p>优化后：</p>
<pre><code>.header .header-nav .header-nav-logo .header-nav-logo-h1 {
    position: absolute;
    top: 25px;
}
</code></pre>
<p>当然这点涉及一个问题：高效开发和 CSS 完整语义优化之间的平衡，过于追求完整语义化和层级性会降低开发效率。至于究竟优化到哪种程度，我们可以慢慢总结，可以总结出一套 CSS 样式命名规范来。</p>
<p>2） 提取公共样式</p>
<p>本项目中公共样式不明显。上下两个腾讯 logo 可以提取但是大小不一致，因此没有提取的必要。如果两个 logo 大小一致，我们可以提取为以下代码：</p>
<pre><code>.tencent-logo {
    height: 22px;
    width: 168px;
}
</code></pre>
<p>3） 提取特殊样式</p>
<p>本项目中一些特殊样式，比如面包屑导航的小三角，可以单独拿出来，因为往往特殊样式具备唯一性，可复用性更高，如果有其他开发项目需要可以直接拿过去使用。</p>
<h3 id="3-性能优化">3- 性能优化</h3>
<p>工作之后你会发现，开发任务往往并不是最难的，难的是如何做好性能优化。互联网用户终端（用户的电脑或者用户的手机）是多样的，有的是有线网有的是无线网，有的是 5g 网有的是 4g 网，有人在信号良好的城市中心，有人在信号很差的地铁上……</p>
<p>性能优化就是为了尽可能保证页面在各种复杂网络情况下，依然能够有良好的加载速度与使用体验。同时性能优化也是进行各种体验优化的前提。</p>
<p>1） 减少 HTML 嵌套的层级</p>
<p>层级越少，实现效果的代码也就越少，代码越少性能也就越好。不知道你注意到没有，本项目用了好几处无序列表 <code>ul</code> 嵌套 <code>li</code>。内部包含 <code>a</code> 标签，实际上是可以去掉 <code>ul</code> 和 <code>li</code>，直接使用 <code>a</code> 链接。</p>
<p>我们再来看另一种实现布局效果的方法：利用标签元素的默认性质布局。</p>
<ul>
<li>块元素和块元素或者和内联元素元素一起，换行显示，所以适合垂直方向上布局</li>
<li>两个内联元素在一起，不换行显示，所以适合水平方向上布局</li>
</ul>
<blockquote>
<p>HTML（超文本标记语言）中元素大多数都是“块级”元素。块级元素占据其父元素（容器）的整个水平空间，垂直空间等于其内容高度，因此创建了一个“块”。通常浏览器会在块级元素前后另起一个新行，一个“内联“或者“行内”元素只占据对应标签所包含的空间。</p>
</blockquote>
<p>这种布局方式有其局限性，但是一旦可以实现需求效果，就能明显减少代码量，我们要注意掌握。</p>
<p>下面我们一起来实现下 用<code>a</code> 标签代替<code>ul</code>和<code>li</code>。</p>
<p>HTML 代码如下：</p>
<pre><code>&lt;div class=&quot;menu-list&quot;&gt;
    &lt;a href=&quot;https://www.tencent.com/zh-cn/about.html&quot;&gt;简介&lt;/a&gt;
    &lt;a href=&quot;https://www.tencent.com/zh-cn/business.html&quot;&gt;业务&lt;/a&gt;
    &lt;a href=&quot;https://www.tencent.com/zh-cn/employees.html&quot;&gt;员工&lt;/a&gt;
    &lt;a href=&quot;https://www.tencent.com/zh-cn/esg.html&quot;&gt;ESG&lt;/a&gt;
    &lt;a href=&quot;https://www.tencent.com/zh-cn/investors.html&quot;&gt;投资者&lt;/a&gt;
    &lt;a href=&quot;https://www.tencent.com/zh-cn/media.html&quot;&gt;媒体&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<p>CSS 代码如下：</p>
<pre><code>.menu-list {
    height: 72px;
    position: absolute;
    right: 160px;
    cursor: pointer;
    line-height: 72px;
}
.menu-list a {
    margin-left: 72px;
    color: #2b2e2e;
    font-size: 16px;
    font-weight: bold;
}
</code></pre>
<p>2）CSS 性能优化</p>
<p>CSS 多使用 <code>link</code> 外链的方式，取代直接使用内联样式。<code>link</code> 外链可以利用浏览器的多线程机制加快样式文件的下载，同时也有利于 seo。seo 翻译过来是搜索引擎优化，这里不做详细讲解，如果你想了解更多，可自行查找资料学习。</p>
<p>3）减少图片的大小</p>
<p>一个完整的 HTML 文件，除了HTML，CSS 和 JavaScript（后面会学习到），还会链接各种外部资源文件，比如图片、音频和视频等。如果外部资源所占存储空间过大，加载或显示会很慢，体验也很不友好。我们应该注意到项目中有好多图片的使用。在这里提供几个图片优化的方案：</p>
<ul>
<li>直接找 UI 设计师优化</li>
<li>借助美图秀秀或 Photoshop</li>
<li>借助第三方平台：<a href="https://tinypng.com/">TinyPNG – Compress WebP, PNG and JPEG images intelligently</a></li>
</ul>
<p>至于优化到什么程度合适，这里有一个平衡：图片大小和图片质量。应该说保证图片质量的前提下所占空间越小越好。</p>
<h1 id="极客之道">极客之道</h1>
<h2 id="1-页面分析">1. 页面分析</h2>
<p>首页内容有很多，一下子好像不知道如何下手，等我们分析完你会发现，内容虽然多，但无非也就几个类型的模块而已，且看下图：</p>
<figure data-type="image" tabindex="32"><img src="https://one-assets.jiker.com/simditor/2019/1218/vpUJEDXDfj2p9zaLFs7Z3AdYbX5lsw8LNgejIQ7h.png" alt="img" loading="lazy"></figure>
<p>第一类： 公用模块：头部，尾部</p>
<p>第二类： 使用轮播方式展示的模块： banner部分，学员故事部分</p>
<p>第三类：min广告位， 最新课程，职业方向，知识体系，企业合作</p>
<p>既然类型相同那么他们在页面结构和样式编写上就会存在一定的相同部分。</p>
<p>按照我们的分析，先完成我们的整体页面结构。然后再一步步的完成每个模块的内容，让我们的页面陆续的丰满起来。</p>
<pre><code>&lt;div id=&quot;jk-header&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;pager&quot;&gt;
  &lt;!-- 广告位 --&gt;
  &lt;div class=&quot;jk-banner&quot;&gt;&lt;/div&gt;
  &lt;!-- end 广告位 --&gt;
  &lt;!-- min 广告位 --&gt;
  &lt;div class=&quot;minbanner&quot;&gt;&lt;/div&gt;
  &lt;!-- end min广告位 --&gt;
  &lt;!-- jk最新课程 --&gt;
  &lt;div class=&quot;jk-uptodate&quot;&gt;&lt;/div&gt;
  &lt;!-- end jk最新课程 --&gt;
  &lt;!-- 职业方向 --&gt;
  &lt;div class=&quot;zhiye&quot;&gt;&lt;/div&gt;
  &lt;!-- end 职业方向 --&gt;
  &lt;!-- 知识体系 --&gt;
  &lt;div class=&quot;vip&quot;&gt;&lt;/div&gt;
  &lt;!-- end 知识体系 --&gt;    
  &lt;!-- 学员故事 --&gt;
  &lt;div class=&quot;jk-story&quot;&gt;&lt;/div&gt;
  &lt;!-- end 学员故事 --&gt;
  &lt;!--企业合作--&gt;
  &lt;div class=&quot;jk-partner&quot;&gt;&lt;/div&gt;
  &lt;!--end 企业合作--&gt;
&lt;/div&gt;
&lt;!--footer--&gt;
&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;
&lt;!--end footer--&gt;
</code></pre>
<p>这就是页面的整体结构了，有了整体结构，我们还需要完成基础公用样式的编写，新建公用 css 样式文件： common.css</p>
<pre><code class="language-css">@charset &quot;utf-8&quot;;
blockquote,
body,
button,
dd,
dl,
dt,
fieldset,
figure,
form,
h1,
h2,
h3,
h4,
h5,
h6,
input,
legend,
li,
ol,
p,
a,
pre,
select,
td,
textarea,
th,
ul {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
	-webkit-font-smoothing: antialiased;
	 -moz-osx-font-smoothing: grayscale;
	 list-style: none;
	 text-decoration: none;
	 /* 针对图标字体进行抗锯齿渲染。font-smoothing是非标准的CSS定义。它被列入标准规范的草案中，后由于某些原因从web标准中被移除了 */
	font-family: Verdana, &quot;Lantinghei SC&quot;,&quot;Hiragino Sans GB&quot;, &quot;Microsoft Yahei&quot;, Helvetica, arial, \5b8b\4f53, sans-serif
}

button, h1, h2, h3, h4, h5, h6, input, select, textarea {
    font-size: 100%;
    font-weight: 400;
    -webkit-font-smoothing: antialiased;
</code></pre>
<p>我们给常用的标签定义了基础样式。随着整个项目页面的增加， commom.css 文件内的内容还会继续增加。思考下我们在基础样式里的 font-size:100%；的作用是什么？</p>
<ul>
<li>在上述CSS代码中，<code>font-size: 100%;</code> 用于确保文档中的字体大小是基于用户代理（浏览器）的默认字体大小计算的。这是一种通用的CSS规则，用于确保文档中的文本大小不受浏览器或父元素的字体大小设置影响，以提供一致性的字体大小和可读性。</li>
</ul>
<p>这时，我们定义了整个页面的结构和公用的基础样式，如果是多人协作开发，那么就可以每个人去完成自己负责的模块了。</p>
<p>当然本次项目我们是自己独立完成的。接下来我们完成公用首尾的开发。</p>
<h2 id="2-头部和尾部公共模块开发">2. 头部和尾部公共模块开发</h2>
<figure data-type="image" tabindex="33"><img src="https://one-assets.jiker.com/simditor/2019/1218/s1RTqUiugMVJVRMlOLzcvAudSjEil9BgSOiZJzTV.png" alt="img" loading="lazy"></figure>
<p>我们看到头部承担了 logo 展示、下拉导航、搜索和登录注册的功能。</p>
<p>那么我们需要按照功能进行导航结构划分，然后通过 float：left ;来进行结构调整。</p>
<pre><code class="language-html">&lt;div id=&quot;jk-header&quot;&gt;
  &lt;div class=&quot;header&quot;&gt;
      &lt;!--logo--&gt;
      &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;logo.png&quot;&lt;/a&gt;&lt;/h1&gt;
      &lt;!--nav--&gt;
      &lt;nav&gt;&lt;/nav&gt;
      &lt;!--search--&gt;
      &lt;div class=&quot;search&quot;&gt;&lt;/div&gt;
      &lt;!--login--&gt;
      &lt;div class=&quot;nav-other&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>我们给每个模块定义宽度，然后通过左浮动进行结构图调整，但要注意给父级标签添加清除浮动。</p>
<p>头部内容我们重点来看下拉部分的实现。先看代码：</p>
<pre><code class="language-html">&lt;nav&gt;
	&lt;ul&gt;
		&lt;li class=&quot;careerpath&quot;&gt;
			&lt;a href=&quot;#&quot;&gt;职业&lt;/a&gt;&lt;i class=&quot;slide-icon&quot;&gt;&lt;/i&gt;
			&lt;div class=&quot;zhiye-submenu slide-submeu&quot;&gt;
				&lt;strong&gt;前端&lt;/strong&gt;
				&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;web-icon&quot;&gt;&lt;/i&gt;Web前端工程师&lt;/a&gt;
				&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;wx-icon&quot;&gt;&lt;/i&gt;微信小程序&lt;/a&gt;
				&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;ios-icon&quot;&gt;&lt;/i&gt;iOS工程师&lt;/a&gt;
				&lt;strong&gt;后端&lt;/strong&gt;
				&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;python-icon&quot;&gt;&lt;/i&gt;Python工程师&lt;/a&gt;
				&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;php-icon&quot;&gt;&lt;/i&gt;PHP工程师&lt;/a&gt;
				&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;golang-icon&quot;&gt;&lt;/i&gt;Golang工程师&lt;/a&gt;
				&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;java-icon&quot;&gt;&lt;/i&gt;JavaWeb工程师&lt;/a&gt;
			&lt;/div&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a href=&quot;#&quot; class=&quot;ying&quot;&gt;实战营&lt;/a&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
&lt;/nav&gt;
</code></pre>
<p>在这里使用无序列表 <code>ul&gt;li</code> 来进行排序，<code>li</code> 里包含了 <code>&lt;a&gt;</code> 标签和 <code>&lt;div&gt; .&lt;a&gt;</code> 标签用来显示导航标题，<code>&lt;div&gt;</code> 里的内容需要鼠标覆盖的 <code>:hover</code> 效果显示出来，下拉菜单的列表内容。</p>
<p>下面是 css 样式的实现：</p>
<pre><code class="language-css">#jk-header nav {
	/*width: 540px;*/
	display: inline-block;
	float: left;
}

#jk-header nav li {
	color: #555;
	list-style: none;
	line-height: 69px;
	padding-right: 32px;
	text-decoration: none;
	font-size: 15px;
	float: left;
	cursor: pointer;
	position: relative;
}

#jk-header nav li:hover .slide-submeu {
	display: block;
}

#jk-header nav li i.slide-icon {
	transition: All 0.4s ease-in-out;
	-webkit-transition: All 0.4s ease-in-out;
	-moz-transition: All 0.4s ease-in-out;
	-o-transition: All 0.4s ease-in-out;
}

#jk-header nav li:hover i.slide-icon {
	transform: rotate(180deg);
	-webkit-transform: rotate(180deg);
	-moz-transform: rotate(180deg);
	-o-transform: rotate(180deg);
	-ms-transform: rotate(180deg);
}

#jk-header nav li i.slide-icon {
	background: url(../img/icon.png);
	background-position: 0px -47px;
	display: inline-block;
	width: 11px;
	margin-left: 5px;
	height: 7px;
}

#jk-header nav li .ying {
	position: relative;
}

#jk-header nav li .ying:before {
	content: '';
	display: block;
	position: absolute;
	top: -9px;
	right: -16px;
	width: 16px;
	height: 16px;
  background: url(../img/ying_icon.png) no-repeat center center }
</code></pre>
<p>顺便我们还给下来的 icon 做了一个反正的动画效果。</p>
<p>其他部分都是正常的页面结构布局，不做过多讲解。</p>
<p>接下来我们看下尾部：</p>
<figure data-type="image" tabindex="34"><img src="https://one-assets.jiker.com/simditor/2019/1218/g4mn9b8OH4yI96iBra9adlkoHmCxilpdzq1XHxw2.png" alt="img" loading="lazy"></figure>
<p>尾部比较平淡无奇，不过这里我们使用了雪碧图来完成分享 icon 的显示：</p>
<pre><code class="language-html">&lt;!-- footer --&gt;
&lt;div id=&quot;footer&quot;&gt;
	&lt;div class=&quot;footer-content&quot;&gt;
		&lt;div class=&quot;contact-way&quot;&gt;
			&lt;div class=&quot;share-way&quot;&gt;
				&lt;a href=&quot;#&quot; class=&quot;weixin-icon&quot;&gt;&lt;/a&gt;
				&lt;a href=&quot;#&quot; class=&quot;sina-icon&quot;&gt;&lt;/a&gt;
				&lt;a href=&quot;#&quot; class=&quot;facebook-icon&quot;&gt;&lt;/a&gt;
				&lt;a href=&quot;#&quot; class=&quot;google-icon&quot;&gt;&lt;/a&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;nav&gt;
			&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;关于我们&lt;/a&gt;&lt;i&gt;|&lt;/i&gt;
			&lt;a href=&quot;#&quot;&gt;加入我们&lt;/a&gt;&lt;i&gt;|&lt;/i&gt;
			&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;i&gt;|&lt;/i&gt;
			&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;企业合作&lt;/a&gt;&lt;i&gt;|&lt;/i&gt;
			&lt;a href=&quot;#&quot;&gt;讲师合作&lt;/a&gt;&lt;i&gt;|&lt;/i&gt;
			&lt;a href=&quot;#&quot;&gt;帮助中心&lt;/a&gt;&lt;i&gt;|&lt;/i&gt;
			&lt;a href=&quot;#&quot;&gt;黑板报&lt;/a&gt;&lt;i&gt;|&lt;/i&gt;
			&lt;a href=&quot;#&quot;&gt;友情链接&lt;/a&gt;
		&lt;/nav&gt;
		&lt;div class=&quot;copyright&quot;&gt;Copyright © 2013-2018 jikexueyuan.com All Rights Reserved. 京ICP备11018032号
			京公网安备11010802013056&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;
&lt;!-- end footer --&gt;
</code></pre>
<p>做为公用模块为了避免可能的冲突这里我们没有才用 footer 标签来作为底部的结构标签。</p>
<p>页面比较简单，接下来我们看下。样式的编写。</p>
<pre><code class="language-css">/* footer */
#footer {
    margin-top: 70px;
    position: relative;
    font-size: 12px;
    background: #fff;
    box-sizing: border-box;
    padding-bottom: 20px;
    border-top: 1px solid #e4e4e4;
}
#footer .footer-content {
    width: 1000px;
    margin: 0 auto;
    text-align: center;
}
#footer .contact-way {
    box-sizing: border-box;
    width: 240px;
    z-index: 100;
    background: #fff;
    margin: 20px auto;
}
#footer .other-way a {
    background: url(../img/otherway.png) 0 0 no-repeat;
    display: inline-block;
    width: 22px;
    height: 18px;
    margin-right: 20px;
}
#footer .other-way a.weixin-icon {
    background-position: -28px 0px;
}
#footer .other-way a.sina-icon {
    background-position: 0px 0px;
}
#footer .other-way a.facebook-icon {
    background-position: -104px 0px;
}
#footer .other-way a.google-icon {
    background-position: -80px 0px;
}
#footer nav {
    border-bottom: 1px solid #f0f0f0;
    padding: 0px 0px 20px 0px;
}
#footer nav a {
    padding: 4px 10px;
    color: #666;
    text-decoration: none;
}
#footer nav i {
    color: #E4E4E4;
    font-style: normal;
}
#footer .copyright {
    color: #999;
  padding: 10px 0
}
</code></pre>
<p>细心的你一定发现了，在定义样式的时候我们一致都在用 模块的 ID 作为最外层，开始编写样式，最大限度的避免样式冲突的可能，毕竟作为公用模块，我们并不清楚以后他会在那些页面中被引用。</p>
<p>好了头部写完了，接下来就是幻灯模块出场了。</p>
<h2 id="3-幻灯模块开发">3. 幻灯模块开发</h2>
<p>在整个页面中有两部分用到了幻灯模。</p>
<p>先看下第一个幻灯模块的效果：</p>
<figure data-type="image" tabindex="35"><img src="https://one-assets.jiker.com/simditor/2019/1218/nezJLr3wlXCPNtvbOmH2exdnjAmU2JUKybG4w1Wt.png" alt="img" loading="lazy"></figure>
<p>这个模块相对复杂一些，在幻灯的层上又叠加了导航模块和新闻模块。</p>
<p>接下来我们先看下页面布局：</p>
<pre><code>&lt;!-- jk-banner --&gt;
	&lt;div class=&quot;jk-banner&quot;&gt;
        &lt;!--幻灯模块--&gt;
		&lt;div class=&quot;banner-container&quot;&gt;
			&lt;span id=&quot;banner-arrow-left&quot; class=&quot;banner-arrow-left&quot;&gt;&lt;/span&gt;
			&lt;span id=&quot;banner-arrow-right&quot; class=&quot;banner-arrow-right&quot;&gt;&lt;/span&gt;
			&lt;div class=&quot;swiper-wrapper&quot;&gt;
				&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;
			&lt;/div&gt;
			&lt;div class=&quot;banner-pagination&quot;&gt;
				&lt;span class=&quot;swiper-pagination-switch swiper-active-switch&quot;&gt;&lt;/span&gt;
				&lt;span class=&quot;swiper-pagination-switch&quot;&gt;&lt;/span&gt;
				&lt;span class=&quot;swiper-pagination-switch&quot;&gt;&lt;/span&gt;
				&lt;span class=&quot;swiper-pagination-switch&quot;&gt;&lt;/span&gt;
			&lt;/div&gt;
		&lt;/div&gt;
        &lt;!--幻灯模块--&gt;
		&lt;!-- 极客头条 --&gt;
		&lt;div class=&quot;subscription-container&quot;&gt;
			&lt;h3&gt;极客头条&lt;/h3&gt;
			&lt;ul class=&quot;subscription-list&quot;&gt;
				&lt;li&gt;&lt;img src=&quot;img/icon2.png&quot;/&gt;
					&lt;p&gt;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;极客训练日干货实录：敏捷开发核心实践&lt;/a&gt;&lt;/p&gt;
				&lt;/li&gt;
				&lt;li&gt;&lt;img src=&quot;img/icon2.png&quot;/&gt;
					&lt;p&gt;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;VIP新课 | 光线投射&lt;/a&gt;&lt;/p&gt;
				&lt;/li&gt;
				&lt;li&gt;&lt;img src=&quot;img/icon2.png&quot; alt=&quot;VIP新课 | 3D动画&quot;&gt;
					&lt;p&gt;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;VIP新课 | 3D动画&lt;/a&gt;&lt;/p&gt;
				&lt;/li&gt;
				&lt;li&gt;&lt;img src=&quot;img/icon2.png&quot; alt=&quot;VIP新课 | OBJ模型&quot;&gt;
					&lt;p&gt;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;VIP新课 | OBJ模型&lt;/a&gt;&lt;/p&gt;
				&lt;/li&gt;
				&lt;li&gt;&lt;img src=&quot;img/icon2.png&quot; alt=&quot;VIP新课 | 纹理&quot;&gt;
					&lt;p&gt;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;VIP新课 | 纹理&lt;/a&gt;&lt;/p&gt;
				&lt;/li&gt;
				&lt;li&gt;&lt;img src=&quot;img/icon2.png&quot; alt=&quot;VIP新课 | 纹理&quot;&gt;
					&lt;p&gt;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;VIP新课 | 纹理&lt;/a&gt;&lt;/p&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/div&gt;
		&lt;!-- 极客头条 end --&gt;
		&lt;!-- 侧导航 --&gt;
		&lt;div class=&quot;aside-allCategory&quot;&gt;
			&lt;ul&gt;
				&lt;li&gt;
					&lt;div&gt;&lt;a href=&quot;#&quot;&gt;前端开发&lt;/a&gt;&lt;/div&gt;
				&lt;/li&gt;
				&lt;li&gt;
					&lt;div&gt;&lt;a href=&quot;#&quot;&gt;前端开发&lt;/a&gt;&lt;/div&gt;
				&lt;/li&gt;
				&lt;li&gt;
					&lt;div&gt;&lt;a href=&quot;#&quot;&gt;前端开发&lt;/a&gt;&lt;/div&gt;
				&lt;/li&gt;
				&lt;li&gt;
					&lt;div&gt;&lt;a href=&quot;#&quot;&gt;前端开发&lt;/a&gt;&lt;/div&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/div&gt;
		&lt;!-- 侧导航 end --&gt;
	&lt;/div&gt;
</code></pre>
<p>这样我们要注意的是，幻灯的内容是通过 swiper-wrapper 元素内的 <code>&lt;a&gt;</code> 标签设置背景来实现的。幻灯效果的实现我们在上一个项目（小试牛刀中进行了讲解）。</p>
<p>新闻和导航，我们用过绝对定位和 z-index 来进行布局.实现在幻灯上的覆盖。</p>
<p>左侧导航有两种实现方式：</p>
<ol>
<li>借助 js 来实现 hover 导航展开效果；</li>
<li>参考头部导航使用纯 css 来实现。</li>
</ol>
<p>接下来我们来查看第二个幻灯模块的实现效果：</p>
<figure data-type="image" tabindex="36"><img src="https://one-assets.jiker.com/simditor/2019/1218/yG8vOoho0e8ZRcp9hsNjLdH1ADhFTqsIn0KIHiMx.png" alt="img" loading="lazy"></figure>
<p>这三个学员故事框是可以滚动轮播的。接下来我们看下html代码的布局：</p>
<pre><code>&lt;!-- 学员故事 --&gt;
&lt;div class=&quot;jk-story&quot;&gt;
	&lt;div class=&quot;story-container&quot;&gt;
		&lt;span class=&quot;story-arrow-left&quot;&gt;&lt;/span&gt;
		&lt;span class=&quot;story-arrow-right&quot;&gt;&lt;/span&gt;
		&lt;div class=&quot;swiper-wrapper&quot;&gt;
			&lt;ul style=&quot;width: 3000px;&quot;&gt;
				&lt;li&gt;
					&lt;a href=&quot;#&quot;&gt;
						&lt;div class=&quot;story-content&quot;&gt;
							&lt;span&gt;学员故事&lt;/span&gt;
							&lt;p&gt;Web大前端工程师就业班五期 03 班学员，某 985 大学信息与计算科学 2016 。&lt;/p&gt;
							&lt;div class=&quot;story-info&quot;&gt;
								&lt;img src=&quot;img/user.jpg&quot;&gt;
								&lt;p&gt;路昕宇&lt;/p&gt;
								&lt;span&gt;入职 浪弯融科科技公司&lt;/span&gt;
							&lt;/div&gt;
						&lt;/div&gt;
					&lt;/a&gt;
				&lt;/li&gt;
				&lt;li&gt;
					&lt;a href=&quot;#&quot;&gt;
						&lt;div class=&quot;story-content&quot;&gt;
							&lt;span&gt;学员故事&lt;/span&gt;
							&lt;p&gt;Web大前端工程师就业班五期 03 班学员，某 985 大学信息与计算科学 2016 。&lt;/p&gt;
							&lt;div class=&quot;story-info&quot;&gt;
								&lt;img src=&quot;img/user.jpg&quot;&gt;
								&lt;p&gt;路昕宇&lt;/p&gt;
								&lt;span&gt;入职 浪弯融科科技公司&lt;/span&gt;
							&lt;/div&gt;
						&lt;/div&gt;
					&lt;/a&gt;
				&lt;/li&gt;
				&lt;li&gt;
					&lt;a href=&quot;#&quot;&gt;
						&lt;div class=&quot;story-content&quot;&gt;
							&lt;span&gt;学员故事&lt;/span&gt;
							&lt;p&gt;Web大前端工程师就业班五期 03 班学员，某 985 大学信息与计算科学 2016 。&lt;/p&gt;
							&lt;div class=&quot;story-info&quot;&gt;
								&lt;img src=&quot;img/user.jpg&quot;&gt;
								&lt;p&gt;路昕宇&lt;/p&gt;
								&lt;span&gt;入职 浪弯融科科技公司&lt;/span&gt;
							&lt;/div&gt;
						&lt;/div&gt;
					&lt;/a&gt;
				&lt;/li&gt;
				&lt;li&gt;
					&lt;a href=&quot;#&quot;&gt;
						&lt;div class=&quot;story-content&quot;&gt;
							&lt;span&gt;学员故事&lt;/span&gt;
							&lt;p&gt;Web大前端工程师就业班五期 03 班学员，某 985 大学信息与计算科学 2016 。&lt;/p&gt;
							&lt;div class=&quot;story-info&quot;&gt;
								&lt;img src=&quot;img/user.jpg&quot;&gt;
								&lt;p&gt;路昕宇&lt;/p&gt;
								&lt;span&gt;入职 浪弯融科科技公司&lt;/span&gt;
							&lt;/div&gt;
						&lt;/div&gt;
					&lt;/a&gt;
				&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;
&lt;!-- end 学员故事 --&gt;
</code></pre>
<p>通过观察可以发现 学员故事的幻灯模块和第一个 banner 幻灯模块很相似，无非就是将 swiper-wrapper 中的展示内容换成了 <code>&lt;li&gt;&lt;li&gt;</code>中的内容。</p>
<p>一般来说 swiper-wrapper 内 <code>&lt;ul&gt;</code> 的宽度是通过 js 计算得出的，在本次项目不会涉及 js 的教学，所以我们用一个较大的固定宽度来代替 <code>&lt;ul style=&quot;width:30000&quot;&gt;</code>。</p>
<p>这里我们给出 css 样式以便各位参考：</p>
<pre><code class="language-css">/* stroy */
 .jk-story {
    margin: 20px auto 0;
    width: 1000px;
    height: 200px;
    overflow: hidden;
}
.jk-story .story-container {
    width: 1000px;
    height: 200px;
    position: relative;
    overflow: hidden;
}
.jk-story .story-container .swiper-slide {
    position: relative;
    text-align: center;
    float: left;
    background: #f4f4f4!important;
}
.jk-story ul {
    height: 200px;
}
.jk-story ul li {
    float: left;
    width: 327px;
    height: 200px;
    position: relative;
    margin-right: 7px;
    transition: all .5s ease;
    -moz-transition: all .5s ease;
    -webkit-transition: all .5s ease;
    -o-transition: all .5s ease;
}
.jk-story ul li a {
    display: block;
    height: 100%;
}
.jk-story ul .story-content {
    width: 100%;
    height: 130px;
    background: #fff;
    position: relative;
    padding-top: 40px;
}
.jk-story ul .story-content&gt;span {
    display: inline-block;
    width: 60px;
    height: 20px;
    line-height: 20px;
    color: #fff;
    position: absolute;
    top: 8px;
    left: 50%;
    margin-left: -30px;
    background: #f88;
    font-size: 12px;
    text-align: center;
}
.jk-story ul .story-content p {
    height: 90px;
    overflow: hidden;
    font-size: 12px;
    color: #555;
    line-height: 20px;
    padding: 0 32px;
    text-align: justify;
}
.jk-story ul .story-info {
    height: 70px;
    padding-left: 95px;
    padding-top: 10px;
    position: relative;
    background: #fafafa;
}
.jk-story ul .story-info img {
    position: absolute;
    top: 10px;
    left: 30px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
}
.jk-story ul .story-info {
    height: 70px;
    padding-left: 95px;
    padding-top: 10px;
    position: relative;
    background: #fafafa;
}
.jk-story ul .story-info p {
    font-size: 12px;
    color: #555;
    height: 24px;
    line-height: 24px;
    overflow: hidden;
    text-align: left;
	padding: 0;
}
.jk-story ul .story-info span {
    display: block;
    height: 24px;
    line-height: 24px;
    color: #999;
    font-size: 12px;
    text-align: left;
}
.jk-story .story-container .story-arrow-left {
    display: none;
    width: 20px;
    height: 40px;
    position: absolute;
    top: 50%;
    left: 0;
    margin-top: -20px;
    z-index: 2;
    cursor: pointer;
    background: url(../img/left.png) no-repeat center;
    background-size: 20px 40px;
}
.jk-story .story-container .story-arrow-right {
    display: none;
    width: 20px;
    height: 40px;
    position: absolute;
    top: 50%;
    right: 0;
    margin-top: -20px;
    z-index: 2;
    cursor: pointer;
    background: url(../img/left.png) no-repeat center;
    background-size: 20px 40px;
    transform: rotate(180deg);
    -ms-transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
}
.story-container:hover .story-arrow-right ,.story-container:hover .story-arrow-left{
	display: block;
}
</code></pre>
<p>注意：在编写每个模块的时候我们都会以最外层的 id 或者 class 为前缀，避免和其他模块的样式产生冲突。 在开始编程之前要在团队内部约定好每个模块的名称和代码风格等。</p>
<h2 id="4-其他模块开发">4. 其他模块开发</h2>
<p>剩下的模块有 <code>：min-banner</code> 模块、最新课程模块、职业方向模块、知识体系模块、合作企业模块。虽然模块的内容展示都不一样，但大致的模块结构是一样的。都是无序列表的浮动排列，有的是三列、有的四列。</p>
<p>在这里我们以最新课程模块为例，进行讲解：</p>
<figure data-type="image" tabindex="37"><img src="https://one-assets.jiker.com/simditor/2019/1218/R8s2mMmnBC0bqUkS16DDMcb0pHYMC8miwnw2Fa9v.png" alt="img" loading="lazy"></figure>
<p>有一个可以和其他模块公用的标题</p>
<p>四个内容块的排列，内容模块包含了图片、标题及标签（等级|课程数量）</p>
<p>那么对应到HTML应该是什么呢？</p>
<p>我们来看下代码先：</p>
<pre><code>&lt;!-- jk-uptodate --&gt;
&lt;div class=&quot;jk-uptodate&quot;&gt;
	&lt;h2&gt;最新课程&lt;/h2&gt;
	&lt;ul&gt;
	  &lt;li&gt;
		&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/ke.png&quot; /&gt;
				&lt;p class=&quot;uptodate-title&quot;&gt;架构设计专项课程之异步化架构设计&lt;/p&gt;
				&lt;p class=&quot;uptodate-info&quot;&gt;高级&lt;span&gt;|&lt;/span&gt;6门课&lt;/p&gt;
		&lt;/a&gt;
	 &lt;/li&gt;
	 &lt;li&gt;
		&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/ke.png&quot; /&gt;
				&lt;p class=&quot;uptodate-title&quot;&gt;架构设计专项课程之异步化架构设计&lt;/p&gt;
				&lt;p class=&quot;uptodate-info&quot;&gt;高级&lt;span&gt;|&lt;/span&gt;6门课&lt;/p&gt;
		&lt;/a&gt;
	 &lt;/li&gt;
         &lt;li&gt;
			&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/ke.png&quot; /&gt;
				&lt;p class=&quot;uptodate-title&quot;&gt;架构设计专项课程之异步化架构设计&lt;/p&gt;
				&lt;p class=&quot;uptodate-info&quot;&gt;高级&lt;span&gt;|&lt;/span&gt;6门课&lt;/p&gt;
			&lt;/a&gt;
		&lt;/li&gt;
		&lt;li&gt;
			&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/ke.png&quot; /&gt;
				&lt;p class=&quot;uptodate-title&quot;&gt;架构设计专项课程之异步化架构设计&lt;/p&gt;
				&lt;p class=&quot;uptodate-info&quot;&gt;高级&lt;span&gt;|&lt;/span&gt;6门课&lt;/p&gt;
			&lt;/a&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- end jk-uptodate --&gt;
</code></pre>
<p>用 H2 做为标题，ul 无序列表进行排序图片和内容包含在 <code>&lt;a&gt;</code> 标签内便于点击，用 <code>&lt;p&gt;</code> 标签写课程介绍 <code>&lt;span&gt;</code> 标签用来实现等级和课程数量。</p>
<p>我们再看下 css 怎么写：</p>
<pre><code>/* jk-update */
.jk-uptodate {
    position: relative;
    width: 1000px;
    margin: 10px auto 0;
}
.jk-uptodate h2 {
    line-height: 60px;
    height: 60px;
    text-align: left;
    font-size: 18px;
    color: #333;
}
.jk-uptodate li {
    display: inline-block;
    vertical-align: top;
    width: 235px;
    height: 240px;
    background: #fff;
    margin-right: 14px;
}
.jk-uptodate li:nth-child(4n) {
    margin-right: 0;
}
.jk-uptodate li:nth-child(n+5) {
    margin-top: 14px;
}
.jk-uptodate li&gt;a {
    display: block;
    width: 100%;
    height: 100%;
}
.jk-uptodate img {
    display: block;
    height: 157px;
}
.jk-uptodate .uptodate-title {
    padding: 10px 15px 0;
    font-size: 13px;
    color: #333;
    line-height: 18px;
    height: 46px;
    margin-bottom: 4px;
    overflow: hidden;
    text-align: justify;
}
.jk-uptodate .uptodate-info {
    font-size: 12px;
    line-height: 22px;
    height: 22px;
    overflow: hidden;
    color: #999;
    padding-left: 15px;
    text-align: justify;
}
</code></pre>
<p>css 部分非常的朴实无华，实在没什么好看的，但有一点需要强调要下，我们在编写代码的时候扩展性是必须要考虑的。比如我们当我们的课程数学超过4个的时候怎么处理? 我们可以通过 css 的伪类来达到页面调整的目的。 这里我们需要重点看下：</p>
<pre><code>.jk-uptodate li:nth-child(4n) {
    margin-right: 0;
}
.jk-uptodate li:nth-child(n+5) {
    margin-top: 14px;
}
</code></pre>
<p>也就是说当我们的课程是第4、8、12……的时候，右外边距为0。</p>
<p>从第5个开始，上外边距都是14px。</p>
<p>由于其他几个模块和最新课程模块非常类似，我们就不一一进行讲解。</p>
<h3 id="flex-弹性布局">Flex 弹性布局</h3>
<p>Flex 是 Flexible Box 的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<blockquote>
<p>Flex 布局教程：语法篇：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</p>
</blockquote>
<p>为了掌握更多的布局技巧，我们在处理职业模块开发的时候特意使用Flex弹性布局来进行开发。页面结构不变，我们来先下职业部分的css关键样式：</p>
<pre><code>.zhiye ul{
    display: flex;
    justify-content:flex-start;
	flex-wrap:wrap;
}
.zhiye ul li {
	flex-grow:1; 
    position: relative;
    vertical-align: middle;
    display: inline-block;
	margin: 8px 4px 0px 4px;
    padding-top: 15px;
    text-align: center;
    height: 150px;
	width:192px;
    background: #fff;
}
</code></pre>
<p>首先我们给职业模块最外围的ul定义了 <code>display:flex;</code> 如果要考虑到低版本浏览器和其他浏览器的兼容行还要加上<code>-webkit,-moz,-o</code> 等，事实上目前浏览器对css3的支持已经非常不错了。在这里我们将省略兼容的写法，让我们的代码看起来更纯粹一些。</p>
<p>当我们为容器设置 为flex以后他里面的所有子元素将自动成为flex弹性盒子的成员。</p>
<pre><code>flex-wrap:wrap;
</code></pre>
<p>的意思是允许换行。flex-wrap还有其它值，大家可以在教程提供的外部链接中查看到，不一一介绍了。</p>
<pre><code>justify-content:flex-start;
</code></pre>
<p>justify-content属性定义了元素在X轴上的对齐方式。flex-start是默认值，左对齐，其实可以省略。</p>
<pre><code>flex-grow:1;
</code></pre>
<p>flex-grow 默认为0，即使父元素有剩余空间也不变大，如果是1则变大，在这里我们用的是1。</p>
<p>我们看下效果：</p>
<p>当宽度是192px的情况下，每行可排列5个项目</p>
<figure data-type="image" tabindex="38"><img src="https://one-assets.jiker.com/simditor/2019/1218/Q1nOFisVenLFDq8YELIhCAIfieaV0zlQFcLzVaCO.png" alt="img" loading="lazy"></figure>
<p>当我们把宽度调整为200以后，有两个项目被挤到下面去了，样式会变成这样：</p>
<figure data-type="image" tabindex="39"><img src="https://one-assets.jiker.com/simditor/2019/1218/fiA0VS5AzzHioKNnppOyPne4TpVdiD5aRcpa4cAU.png" alt="img" loading="lazy"></figure>
<p>这就是 flex-grow：1 的作用。</p>
<p>弹性布局是 css3 新增的特性。用处非常广泛，大家需要多加练习和使用。</p>
<p>浮动布局和弹性布局各有千秋，具体使用哪个更好，要根据业务场景来选择，就想眼镜一样，你总会知道什么需要它。</p>
<h1 id="创新招募区信息展示板">创新招募区信息展示板</h1>
<h2 id="1-使用vue-cli新建项目">1. 使用Vue-CLI新建项目</h2>
<h3 id="1-使用vue-cli创建项目">1- 使用vue-cli创建项目</h3>
<p>同学们需要首先打开命令行，定位到某文件夹，比如D:/projects或者~/projects，然后打开命令控制台，运行命令。在命令控制台下运行：</p>
<pre><code>vue create innovation-table
</code></pre>
<blockquote>
<p>注：在window系统下，一个在当前文件路径下快速打开控制台的方法，选中文件夹导航输入cmd，然后回车：</p>
</blockquote>
<figure data-type="image" tabindex="40"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/pLdeTY4nZS7ZSInA9ZsahmigjeZFhWzei3jdqQvA.gif" alt="img" loading="lazy"></figure>
<p>随后Vue-CLI会提示选择一个preset，在这里我推荐大家选择Default，同时选择Vue 2：</p>
<figure data-type="image" tabindex="41"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/Buqwwhop8KqppjAOd74BREos3HEIQzi3nvM9F4kI.png" alt="img" loading="lazy"></figure>
<p>这样Vue-CLI会自动帮我们创建一个项目文件夹，名字叫做innovation-table，里面包含这样一些文件：</p>
<figure data-type="image" tabindex="42"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/WVLdhz96OQndVZxUN8fMmWr9RV3o5ecGr4eAPeks.png" alt="img" loading="lazy"></figure>
<p>关于Vue-CLI的详细文档，请查看这里，<strong><a href="https://cli.vuejs.org/zh/guide/">介绍 | Vue CLI</a></strong>。</p>
<h3 id="2-运行vue项目">2- 运行Vue项目</h3>
<p>Vue-CLI创建完项目后，我们可以通过命令来运行项目，验证项目是否能成功运行。</p>
<pre><code class="language-shell">cd innovation-table
npm run serve
</code></pre>
<p>npm run serve是调用package.json中scripts下面的serve命令。然后我们可以在Google Chrome浏览器中，访问http://localhost:8080，接下来就会看到Vue的欢迎页面，恭喜你已经成功运行了项目。</p>
<figure data-type="image" tabindex="43"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/ZDsRzeHsSG7AqVHSej5oMXUreImht82Yr20Z5RTm.png" alt="img" loading="lazy"></figure>
<h2 id="2-安装element-ui">2. 安装element-ui</h2>
<h3 id="1-安装-element-ui-vue-router和json-server">1- 安装 Element-UI、Vue-router和json-server</h3>
<p>使用以下命令安装：</p>
<pre><code>npm install element-ui axios vue-router json-server faker --save
</code></pre>
<p>会报错提示：</p>
<figure data-type="image" tabindex="44"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/VyFI82UW8RvrXWdiD0LPknVPokWxsRSHZOqUlRlI.png" alt="image.png" loading="lazy"></figure>
<p>这是因为默认安装的vue-router版本高导致的，可以将上述安装命令修改为：</p>
<pre><code>npm install element-ui axios vue-router@3.2.0 json-server faker --save
</code></pre>
<p>就可以正常安装了。检查package.json文件，发现增多相关的依赖包：</p>
<pre><code>&quot;dependencies&quot;: {
    &quot;axios&quot;: &quot;^0.27.2&quot;,
    &quot;core-js&quot;: &quot;^3.6.5&quot;,
    &quot;element-ui&quot;: &quot;^2.15.8&quot;,
    &quot;faker&quot;: &quot;^6.6.6&quot;,
    &quot;json-server&quot;: &quot;^0.17.0&quot;,
    &quot;vue&quot;: &quot;^2.6.11&quot;,
    &quot;vue-router&quot;: &quot;^3.2.0&quot;
  }
</code></pre>
<p>运行npm run serve。正常运行表明安装成功。</p>
<h2 id="3-构建展示板页面">3. 构建展示板页面</h2>
<h3 id="1-构造系统的路由结构">1- 构造系统的路由结构</h3>
<p>在上一步骤中我们已经成功创建了项目的基本结构并运行，在此步骤中开始构建系统，打开main.js，删除所有内容之后再添加以下代码：</p>
<pre><code>import Vue from 'vue'
import VueRouter from 'vue-router'
import axios from 'axios'
import ElementUI from 'element-ui'
import App from './App'
import DisplayTable from './components/DisplayTable'
import 'element-ui/lib/theme-chalk/index.css'

Vue.use(VueRouter)
Vue.use(ElementUI)
Vue.config.productionTip = false
Vue.prototype.$http = axios

const routes = [
  { path: '/', redirect: '/index' },
  { path: '/index', component: DisplayTable }
]


const router = new VueRouter({ routes })

new Vue({
  router,
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
<p>以上代码分别引入vue、引入 vue-router 插件、引入axios、引入element-ui还有引入element-ui样式。请注意其中的 Vue.use 的写法，这是通过全局方法 Vue.use() 使用插件：包括elment-ui和vue-router，它需要在你调用 new Vue() 启动应用之前完成。</p>
<p>Vue.config.productionTip设置为false表示生产环境vue不会给出提示。之后将axios绑定赋值给<code>$http</code>，这样就可以直接通过<code>this.$http</code>访问到<code>axios</code>。</p>
<p>代码中的 routes 部分就是本系统将要构造的前端路由，我们使用了 vue-router 来创建该路由，将系统的首页映射到我们的组件 DisplayTable 之上，vue-router 的具体使用方法请参照：<a href="https://router.vuejs.org/zh/">Vue Router</a>。</p>
<h3 id="2-创建新的展示板首页组件displaytablevue">2- 创建新的展示板首页组件DisplayTable.vue</h3>
<p>在components目录下新建DisplayTable.vue文件，添加以下代码：</p>
<pre><code>&lt;template&gt;
  &lt;el-container&gt;
    &lt;el-header&gt;
      &lt;h1&gt;创新招募信息展示板&lt;/h1&gt;
    &lt;/el-header&gt;
 &lt;/el-container&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &quot;DisplayTable&quot;,
  data() {
    return {};
  }
}
&lt;/script&gt;
&lt;style&gt;&lt;/style&gt;
</code></pre>
<p>这就是 Vue 中组件的基本结构，一共由三部分组成：Template (HTML)、JS、Style (CSS)，和普通的<code>HTML/CSS/JS</code>类似，这三部分组成了一个基本组件。</p>
<h3 id="3-将appvue与新建的组件连接">3- 将App.vue与新建的组件连接</h3>
<p>打开App.vue文件，修改为以下代码：</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
#app {
  font-family: 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB',
    'Microsoft YaHei', '微软雅黑', Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
}
&lt;/style&gt;
</code></pre>
<p>请注意其中 <code>&lt;router-view&gt;</code> 部分，该标签相当于一个占位符，当 url 匹配到路由表时会自动将这个占位符替换为在路由表中定义好的组件，详情请参考 ：<a href="https://router.vuejs.org/zh/api/#router-view">API 参考 | Vue Router</a>。该任务完成后页面会变为：</p>
<figure data-type="image" tabindex="45"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/cASptQI1tgbF0XrCQt33iSaT33CTygIe9jaCzw3i.png" alt="img" loading="lazy"></figure>
<h2 id="4-完成项目信息列表组件">4. 完成项目信息列表组件</h2>
<h3 id="1-在assets目录下创建dbjs文件">1- 在assets目录下创建db.js文件</h3>
<p>内容如下：</p>
<pre><code class="language-js">const faker = require('faker')
faker.locale ='zh_CN'

module.exports = () =&gt; {
  const data = { projects: [] }
  for (let i = 0; i &lt; 20; i++) {
    const item = {
      id: faker.random.number(),
      name: faker.name.jobTitle(),
      submitter: `${faker.name.firstName()}${faker.name.lastName()}`,
      department: faker.commerce.department(),
      description: faker.lorem.sentence(),
      expectation: faker.lorem.words(),
      assignee: `${faker.name.firstName()} ${faker.name.lastName()}`
    }
    data.projects.push(item)
  }
  return data
}
</code></pre>
<p>faker.js 是一个开源工具库，可以帮助我们生成一些随机数据。上面随机了一个对象，其projects有20条数据。</p>
<h3 id="2-在命令行里启动json-server">2- 在命令行里启动json-server</h3>
<p>打开控制台，进入项目根目录下，运行命令：</p>
<pre><code>npx json-server ./src/assets/db.js
</code></pre>
<p>在这里给大家介绍一个新的命令npx，npx是用来帮助我们运行npm安装包中的命令的，它和npm还是有区别的，千万不要搞混了。<strong><a href="https://www.zhihu.com/question/327989736">npm 和 npx 有什么区别? - 知乎</a></strong>。执行之后会开启一个后端服务，前端可以通过下述地址访问。运行成功后截图：</p>
<figure data-type="image" tabindex="46"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/In7rWYcV3TBhbEZHn69l18f9ji0KdhV6HgBDk4Sy.png" alt="image.png" loading="lazy"></figure>
<h3 id="3-在组件中调用json-server后端请求数据">3- 在组件中调用json-server后端请求数据</h3>
<p>打开 DisplaTable.vue 文件，修改 <code>&lt;script&gt;&lt;/script&gt;</code>中的代码，修改为如下代码块：</p>
<pre><code>export default {
  name: &quot;DisplayTable&quot;,
  data() {
    return { projects: []};
  },
  async created() {
    const response = await this.$http.get(&quot;http://localhost:3000/projects&quot;);
    this.projects = response.data;
  }
}
</code></pre>
<p>created方法中的内容即是我们使用axios库向json-server请求数据的部分，<code>async/await</code> 是 JavaScript 中的关键字，主要为了解决异步请求的代码嵌套问题，请参考：</p>
<p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Promises">优雅的异步处理 - 学习 Web 开发 | MDN</a></strong></p>
<p><strong><a href="https://zhuanlan.zhihu.com/p/72817372">vue中使用async和await解决异步</a></strong></p>
<h3 id="4-使用elemen-ui的表格组件完成数据的展示">4- 使用Elemen-UI的表格组件完成数据的展示</h3>
<p>还是在 DisplayTable.vue 文件中，编辑 <code>&lt;Template&gt;</code>部分，添加以下内容：</p>
<pre><code>&lt;template&gt;
  &lt;el-container&gt;
    &lt;el-header&gt;
      &lt;h1&gt;创新招募信息展示板&lt;/h1&gt;
      &lt;el-main&gt;
        &lt;el-table
          :stripe=&quot;true&quot;
          :border=&quot;true&quot;
          :data=&quot;projects&quot;
          style=&quot;width: 100%&quot;
        &gt;
          &lt;el-table-column label=&quot;项目编号&quot; prop=&quot;id&quot;&gt;&lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;项目名称&quot; prop=&quot;name&quot;&gt;&lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;提交人&quot; prop=&quot;submitter&quot;&gt;&lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;部门&quot; prop=&quot;department&quot;&gt;&lt;/el-table-column&gt;
          &lt;el-table-column
            label=&quot;项目描述&quot;
            prop=&quot;description&quot;
          &gt;&lt;/el-table-column&gt;
          &lt;el-table-column
            label=&quot;预期成果及收益&quot;
            prop=&quot;expectation&quot;
          &gt;&lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;指派给&quot; prop=&quot;assignee&quot;&gt;&lt;/el-table-column&gt;
          &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot;&gt;
            &lt;template slot-scope=&quot;scope&quot;&gt;
              &lt;el-button
                size=&quot;mini&quot;
                type=&quot;primary&quot;
                @click=&quot;openDetailPage(scope.row)&quot;
                &gt;我有方案&lt;/el-button
              &gt;
            &lt;/template&gt;
          &lt;/el-table-column&gt;
        &lt;/el-table&gt;
      &lt;/el-main&gt;
    &lt;/el-header&gt;
  &lt;/el-container&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &quot;DisplayTable&quot;,
  data() {
    return { projects: [] };
  },
  methods: {
    openDetailPage(){ 
    }
  },
  async created() {
    const response = await this.$http.get(&quot;http://localhost:3000/projects&quot;);
    this.projects = response.data;
  }
}
&lt;/script&gt;
</code></pre>
<p><code>&lt;el-main&gt;</code> 也是来源于 Element-UI的组件，主要用于布局，意思是该部分为页面展示的主要内容：<strong><a href="https://element.eleme.io/#/zh-CN/component/container">Element - The world’s most popular Vue UI framework</a></strong></p>
<p><code>&lt;el-table&gt;</code> 就是负责展示整个表格的主要组件，<code>:data=&quot;projects&quot;</code> 就是对应 <code>&lt;script&gt;</code> 中从后端请求返回的 projects，<code>:data</code> 是Vue中的数据和展示双向绑定的写法，关于 Table 组件和双向绑定的知识请参考：</p>
<p><strong><a href="https://element.eleme.io/#/zh-CN/component/table#table-methods">Element - The world’s most popular Vue UI framework</a></strong></p>
<p>该任务完成后页面大致展示如下：</p>
<figure data-type="image" tabindex="47"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/Tm16tLFOuZbh69thmTB9EsQdGJGz5AO3uWxwKSC6.png" alt="image.png" loading="lazy"></figure>
<h2 id="5-完成项目搜索组件">5. 完成项目搜索组件</h2>
<h3 id="1-使用-element-ui-创建搜索组件">1- 使用 Element-UI 创建搜索组件</h3>
<p>打开 DisplayTable.vue 组件，增加如下代码：</p>
<pre><code>&lt;template&gt;
  &lt;el-container&gt;
    &lt;el-header&gt;
      &lt;h1&gt;创新招募信息展示板&lt;/h1&gt;
      &lt;el-row class=&quot;search-container&quot;&gt;
        &lt;label&gt;项目名称: &lt;/label&gt;
        &lt;el-input
          class=&quot;search-input&quot;
          label=&quot;项目名称&quot;
          v-model=&quot;searchKey&quot;
          placeholder=&quot;请输入搜索关键字&quot;
        /&gt;
        &lt;el-button type=&quot;primary&quot; round @click=&quot;search&quot;&gt;搜索&lt;/el-button&gt;
      &lt;/el-row&gt;
      &lt;el-main&gt;
        ...
      &lt;/el-main&gt;
    &lt;/el-header&gt;
  &lt;/el-container&gt;
&lt;/template&gt;

&lt;style scoped&gt;
.search-container {
    text-align: left;
    margin-left: 20px;
}
.search-container &gt; div {
    width: 400px;
}
&lt;/style&gt;
</code></pre>
<p>其中 <code>&lt;el-row&gt;</code> 来自于 Element-UI 组件库，主要是为了排版目的使用，可以将其中被包含的元素按行排列并进行自动伸缩。</p>
<p><code>&lt;el-input&gt;</code> 即是我们添加的搜索组件，其本质就是一个 Input 输入框，使用 v-model 和组件内提前定义好的 this.searchKey 进行了双向绑定，以便在用户进行输入时同时更新组件内 this.searchKey 的值。</p>
<p><code>&lt;el-button&gt;</code> 同样来自于 Element-UI，提供了丰富的按钮样式供我们选择，只要改变 round type 等属性关键字即可实现不同的效果，<code>@click=&quot;search&quot;</code> 是我们绑定在元素上的方法，对应组件中定义的 search 实现。</p>
<p>该步骤完成之后页面截图大致如下：</p>
<figure data-type="image" tabindex="48"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/1xATfTryY5314TJ8LqFTCCWwv7KswT0GfUtDUF3h.png" alt="img" loading="lazy"></figure>
<h3 id="2-添加搜索事件完成数据过滤和展示">2- 添加搜索事件，完成数据过滤和展示</h3>
<p>完成上一步之后命令行中会提示一个错误，是由于没有在组件中找到 search 这个方法，打开 DisplayTable.vue，在 <code>&lt;script&gt;</code>中添加以下代码：</p>
<pre><code>data() {
  return { projects: [], searchKey: &quot;&quot;, replicas: [] };
},
methods: {
  search: function() {
    if (this.searchKey.trim().length === 0) {
      this.projects = this.replicas
    } else {
      this.projects = this.projects.filter(item =&gt; item.name.indexOf(this.searchKey) &gt; -1)
    }
  }
}
</code></pre>
<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用，方法中的 this 自动绑定为 Vue 实例，我们在 Template 中定义的方法都会写在 methods 中。</p>
<p>data 的返回值中 projects 对应表格数据，searchKey 对应搜索关键字，replicas 是为了存储初始 projects的值，因为 search 方法会修改 this.projects，因此当清空搜索关键字之后我们需要用事先保存的值来恢复 this.projects 的值。replicas的使用相关代码：</p>
<pre><code>async created() {
    const response = await this.$http.get(&quot;http://localhost:3000/projects&quot;);
    this.projects = response.data
    this.replicas = response.data
  }
</code></pre>
<p>搜索功能截图如下：</p>
<figure data-type="image" tabindex="49"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/EVfYA2MdC0XTbQbYWBOnRh1yLz196fL6mqcF9ehc.png" alt="img" loading="lazy"></figure>
<h2 id="6-实现项目信息列表组件的分页">6. 实现项目信息列表组件的分页</h2>
<h3 id="1-增加分页组件">1- 增加分页组件</h3>
<p>打开 DisplayTable.vue，添加如下代码：</p>
<pre><code>&lt;el-main&gt;
   ...   
&lt;/el-main&gt;
&lt;el-footer&gt;
  &lt;el-pagination
    :page-size=&quot;10&quot;
    layout=&quot;total, prev, pager, next&quot;
    :total=&quot;total&quot;
  /&gt;
&lt;/el-footer&gt;
</code></pre>
<p><code>&lt;el-pagination&gt;</code> 是Element-UI 提供的分页组件，其中 page-size 表示每页显示数据的数量，layout 规定展示Pagination组件的哪些部分，total显示数据的总条数，Pagination 组件的具体用法请参考：<a href="https://element.eleme.io/#/zh-CN/component/pagination">Element - The world’s most popular Vue UI framework</a>。同时total要在data中添加：</p>
<pre><code>data() {
    return { projects: [], searchKey: &quot;&quot;, replicas: [], total: 0 };
}
</code></pre>
<h3 id="2-增加发送后端请求的api格式">2- 增加发送后端请求的API格式</h3>
<p>添加分页之后，我们需要在 Table 上绑定分页的数据，添加如下数据：</p>
<pre><code>methods: {
  async handlePageClick(page) {
    const response = await this.$http.get(`http://localhost:3000/projects?_page=${page}&amp;_limit=10`);
    this.projects = response.data;
  }
}
</code></pre>
<blockquote>
<p>注：json-server可以通过参加分页的参数将请求数据分页。<a href="https://www.npmjs.com/package/json-server">参考：json-server</a></p>
</blockquote>
<p>这就是点击上一页/下一页之后需要向后端发送的请求，要求发送请求页数（page）和每页显示数量。</p>
<p>同时优化首次加载页面数据展示条数：全部数据最多展示数据10条。</p>
<pre><code>async created() {
    const response = await this.$http.get(&quot;http://localhost:3000/projects&quot;);
    const data = response.data
    this.total = data.length
    this.projects = data.slice(0, 10)
    this.replicas =  data.slice(0, 10)
  }
</code></pre>
<p>分页效果预览：</p>
<figure data-type="image" tabindex="50"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/QZdmkzecRJVoJD8m8U6Nj0wiWHHiLEY5q3Uvnvrd.png" alt="image.png" loading="lazy"></figure>
<h2 id="7-完成项目详细信息页面并实现页面跳转">7. 完成项目详细信息页面并实现页面跳转</h2>
<h3 id="1-建-projectdetail-组件">1- 建 ProjectDetail 组件</h3>
<p>在 components 目录下新建文件 ProjectDetail.vue，修改为如下代码：</p>
<pre><code>&lt;template&gt;
  &lt;el-container class=&quot;detail-form-container&quot;&gt;
    &lt;el-header&gt;&lt;h1&gt;项目具体信息&lt;/h1&gt;&lt;/el-header&gt;
  &lt;/el-container&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return { 
    }
  }
};
&lt;/script&gt;
</code></pre>
<h3 id="2-点击表格中每一行的我有方案后页面能够跳转至detail组件">2- 点击表格中每一行的“我有方案”后页面能够跳转至detail组件</h3>
<p>打开 DisplayTable.vue 文件，写openDetailPage方法，代码如下：</p>
<pre><code>&lt;script&gt;
export default {
  name: &quot;DisplayTable&quot;,
  ..
  methods: {
    openDetailPage(row) {
      this.$router.push({
        path: `/projects/${row.id}`,
        params: { id: row.id },
      });
    },
    ...
};
&lt;/script&gt;
</code></pre>
<p>该方法利用绑定在 main.js 里的 VueRouter 实例对象进行路由跳转，但此时我们还没有这样一个路由规则：<code>/projects/:id</code>，以及对应的要显示的组件定义，因此我们需要在 main.js 里添加一条新的路由规则，打开 main.js 添加以下代码：</p>
<pre><code>const routes = [
  ...
  { path: '/projects/:id', component: ProjectDetail }
]
</code></pre>
<p>即可将我们已经添加的 ProjectDetail.vue 和这个新的路由规则对应起来，projects/:id 中的 :id 并不指代具体名称，而是表示一个占位符，意思是任何符合 :id 规则的字符串、数字、字符串+数字组合都匹配这个规则。</p>
<p>该步骤完成后页面大致显示如下：</p>
<figure data-type="image" tabindex="51"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/FlvmkLbCm85l3574EppfsLyXgkSWLiKyCCkgJvzD.png" alt="效果图" loading="lazy"></figure>
<figure data-type="image" tabindex="52"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/cNe0BGDp4pBfp8JzlfngYLHQ0JVdfcnZD5keZl7P.png" alt="效果图" loading="lazy"></figure>
<h3 id="3-在detail组件中访问后端结构获取项目的详细信息">3- 在detail组件中访问后端结构获取项目的详细信息</h3>
<p>跳转到 Detail 组件之后我们需要根据项目编号请求具体的某个项目的数据，在 ProjectDetail.vue 中添加以下代码：</p>
<pre><code>&lt;script&gt;
export default {
  data() {
    return {
      project: {
        id: 0,
        name: &quot;&quot;,
        category: 0,
        description: &quot;&quot;,
        expectation: &quot;&quot;,
      }
    };
  },
  async created() {
    const id = this.$route.params.id;
    const response = await this.$http.get(
      `http://localhost:3000/projects/${id}`
    );
    this.project = { ...this.project, ...response.data };
  },
};
&lt;/script&gt;
</code></pre>
<p>由于对应的路由规则是 projects/:id，因此我们可以获取对应的 ID，然后根据这个 ID 在后端查询相应的数据。</p>
<h3 id="4-在detail组件中利用-element-ui-的form组件及input组件展示表格中具体被点击条目的详细数据">4- 在detail组件中利用 Element-UI 的Form组件及Input组件展示表格中具体被点击条目的详细数据</h3>
<p>上一步完成之后我们已经拥有了后端返回的具体某一个项目的具体信息，现在需要显示出这些具体数据，并提供编辑和提交功能，打开 ProjectDetail.vue 文件，添加以下代码：</p>
<pre><code>&lt;template&gt;
  &lt;el-container&gt;
    ...
    &lt;el-form
      :model=&quot;project&quot;
      :rules=&quot;rules&quot;
      ref=&quot;project&quot;
      label-width=&quot;120px&quot;
      class=&quot;detail-form&quot;
    &gt;
      &lt;el-form-item label=&quot;项目编号&quot; prop=&quot;id&quot;&gt;
        &lt;el-input :disabled=&quot;true&quot; v-model=&quot;project.id&quot;&gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;项目名称&quot; prop=&quot;name&quot;&gt;
        &lt;el-input v-model=&quot;project.name&quot;&gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;项目类别&quot; prop=&quot;category&quot;&gt;
        &lt;el-radio-group v-model=&quot;project.category&quot;&gt;
          &lt;el-radio :label=&quot;0&quot;&gt;我提我做&lt;/el-radio&gt;
          &lt;el-radio :label=&quot;1&quot;&gt;我提你做&lt;/el-radio&gt;
        &lt;/el-radio-group&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;项目描述&quot; prop=&quot;description&quot;&gt;
        &lt;el-input
          type=&quot;textarea&quot;
          :rows=&quot;4&quot;
          placeholder=&quot;请输入内容&quot;
          v-model=&quot;project.description&quot;
        &gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item label=&quot;预期成果及收益&quot; prop=&quot;expectation&quot;&gt;
        &lt;el-input
          type=&quot;textarea&quot;
          :rows=&quot;4&quot;
          placeholder=&quot;请输入内容&quot;
          v-model=&quot;project.expectation&quot;
        &gt;&lt;/el-input&gt;
      &lt;/el-form-item&gt;
      &lt;el-form-item&gt;
        &lt;el-button type=&quot;success&quot; @click=&quot;back()&quot;&gt;返回&lt;/el-button&gt;
        &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm('project')&quot;
          &gt;提交&lt;/el-button
        &gt;
      &lt;/el-form-item&gt;
    &lt;/el-form&gt;
  &lt;/el-container&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      project: {
        id: 0,
        name: &quot;&quot;,
        category: 0,
        description: &quot;&quot;,
        expectation: &quot;&quot;,
      },
      rules: {}
    };
  },
  methods: {
    back() {
    },
    submitForm(formName) {
    }
  },
  ...
};
&lt;/script&gt;
</code></pre>
<p><code>&lt;el-form&gt;</code> 是 Element-UI 提供的表单组件，该表单组件提供了基本的数据绑定和验证规则定制化等基本功能，<code>:model=&quot;project&quot;</code> 就可以将已经获取到的后端数据和表单绑定起来，<code>&lt;el-form-item&gt;</code> 是表单内的具体内容，每一条都需要对应 project 定义的具体属性，比如 name id description 等，关于表单的详细信息请参考：<a href="https://element.eleme.io/#/zh-CN/component/form">Element - The world’s most popular Vue UI framework</a>。</p>
<p>此步骤完成后详情页面预览：</p>
<figure data-type="image" tabindex="53"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/d2XtDQkwBuqhwNanlRCUK38AeMaeBhE4DRroteYS.png" alt="image.png" loading="lazy"></figure>
<h3 id="5-改动数据后提交数据并回到前一页面">5- 改动数据后提交数据并回到前一页面</h3>
<p>上一步我们已经添加了一个可以编辑的表单，现在需要实现“返回”和“提交”功能，还是ProjectDetail.vue 文件中，在<code>&lt;script&gt;</code> 中添加以下代码：</p>
<pre><code>methods: {
  back() {
    this.$router.push('/')
  },
  submitForm(formName) {
    const id = this.$route.params.id;
    this.$refs[formName].validate(valid =&gt; {
      if (valid) {
        this.$http.put(`http://localhost:3000/projects/${id}`, this.project, {headers: {
          'Content-Type': 'application/json'
        }}).then(() =&gt; {
          this.$router.push('/');
        });
      } else {
        console.log(&quot;error submit!!&quot;);
        return false;
      }
    });
  }
}
</code></pre>
<p>back 和 submitForm 方法对应 “返回” 和 “提交” 两个按钮的点击事件，back 利用 VueRouter 实现返回到首页的方法，submitForm 稍微复杂一些，请先忽略被注释的部分，<code>this.$http.post</code> 是发送请求数据到后端进行提交，然后 router 返回首页，post 请求请参考以下内容：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST">POST - HTTP | MDN</a>。</p>
<h2 id="8-完成项目详细信息具体字段并进行前端验证">8. 完成项目详细信息具体字段并进行前端验证</h2>
<h3 id="1-利用-element-ui-的-form-组件添加验证">1- 利用 Element-UI 的 Form 组件添加验证</h3>
<p>Element-UI 的 Form 组件已经提供了完善的验证机制，我们需要完成一些设置来完善表单的验证功能，根据 <strong><a href="https://element.eleme.io/#/zh-CN/component/form">Element - The world’s most popular Vue UI framework</a></strong> 提供的 Form Attributes列表：</p>
<figure data-type="image" tabindex="54"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/Qg8IPz7nWcOeNikv9U3qjNCoXg9FKYLRc2Nfr9a1.png" alt="image.png" loading="lazy"></figure>
<p>其中 rules 对应了我们自己设置的验证规则，将上一步注释的代码全部打开，并编辑 <code>&lt;script&gt;</code> 中的内容：</p>
<pre><code>data() {
  return { 
    project: {
        id: 0,
        name: &quot;&quot;,
        category: 0,
        description: &quot;&quot;,
        expectation: &quot;&quot;,
    },
    rules: {
      name: [
        { required: true, message: &quot;请输入项目名称&quot;, trigger: &quot;blur&quot; }
      ],
      description: [
        { required: true, message: &quot;请输入项目描述&quot;, trigger: &quot;blur&quot; }
      ],
      expectation: [
        { required: true, message: &quot;请输入内容&quot;, trigger: &quot;blur&quot; }
      ]
    }
  };
}
</code></pre>
<p>rules 就是我们自己定义的验证规则，required 意思是该字段必须输入，message 代表验证失败之后要显示的 “错误消息”，trigger 表示触发规则的行为，此处的 blur 意思是焦点离开 input 之后立即触发验证，具体请参考：<strong><a href="https://element.eleme.io/#/zh-CN/component/form#zi-ding-yi-xiao-yan-gui-ze">Element - The world’s most popular Vue UI framework</a></strong>。</p>
<p>表单验证触发效果如下：</p>
<figure data-type="image" tabindex="55"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/M9fzXVvvrmtFDUC211V9RZYDX33hfs9lSj91ceoO.png" alt="image.png" loading="lazy"></figure>
<h1 id="移动端项目">移动端项目</h1>
<h2 id="1-项目概览">1. 项目概览</h2>
<p>我们主要通过HTML+CSS+JavaScript技术，带领你开发信用卡积分兑换商城首页移动端的业务需求，效果图如下。我们的成果是完成页面的静态效果，要求尽可能1：1还原，数据不要求从服务端获取，但要求达到不同移动端设备都能适配的效果，且不同移动端设备预览效果差别不要过大。</p>
<figure data-type="image" tabindex="56"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/JWUAiWKaOWhH297ZnWWYw6alY8jDucP727VC0ufB.png" alt="效果图" loading="lazy"></figure>
<p>我们将借助GitHub和Git管理代码，借助VScode开发，通过这个项目让你快速理解前端开发工程师的主要工作及操作流程，进而快速上手工作。</p>
<h2 id="2-分析业务需求及标注">2. 分析业务需求及标注</h2>
<h3 id="2-1-分析业务需求">2-1 分析业务需求</h3>
<p>单从效果图可以看出这是一个移动端的开发需求，如果不确定这点，你可以在实际工作中直接问问设计人员或者产品。移动端需求首先需要考虑的是适配问题，适配不同移动端终端。</p>
<p><strong>1.vh/vw</strong></p>
<p>vw 是相对单位，1vw 表示屏幕宽度的 1%，1vh表示屏幕高度的1%。</p>
<p><strong>2.rem</strong></p>
<p>rem是相对根元素字体的尺寸大小，比如根元素HTML的font-size为100px，那么1rem也就是100px。</p>
<p><strong>3.媒体查询</strong></p>
<p>使用@media检测屏幕尺寸，然后调整页面元素尺寸大小的方案。</p>
<p>本项目采用的是rem方案。rem相对其他两者是使用比较广泛的方案，rem的兼容性高于vh/vw方案，精细度又高于媒体查询方案，你还可以进一步了解各个方案更多的优劣对比。</p>
<h3 id="2-2-标注">2-2 标注</h3>
<p>这里我们将设计稿作为初始化尺寸，之后在此基础上进行适配调整。设计人员选择iPhone6作为基准设计尺寸。</p>
<p>标注的是css像素，标注的对象是视觉稿的设计稿。最初设计提供的是1500*3928的设计稿，这是设计人员出于便于设计的需要放大的结果，我们管这版设计稿叫放大版。因为iPhone 6设备像素比是2，所以实际视觉稿为1500/2=750px，即将设计稿同比缩小二分之一，缩小之后的稿件就是设计稿的开发版，之后在这个基础上进行标注，之后进行开发。开发背后的逻辑参考：<a href="https://github.com/amfe/article/issues/17">使用Flexible实现手淘H5页面的终端适配 · Issue #17 · amfe/article</a>。</p>
<p>标注结果是设计完成的或者在实际工作当中由第三方的标注平台或者标注工具完成。</p>
<h2 id="3-构建主体页面">3. 构建主体页面</h2>
<h3 id="3-1-分析页面html结构">3-1 分析页面HTML结构</h3>
<p>在项目下创建index.html。移动端业务需要保证布局视口等于视觉视口等于理想视口，同时避免用户缩放，参考：<a href="https://zhuanlan.zhihu.com/p/427507738">布局视口，视觉视口，理想视口</a>。因此，需要进行以下设置：</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1,user-scalable=no&quot;&gt;
</code></pre>
<p>这里将效果图分成三部分：头部、内容区和底部。</p>
<ul>
<li>头部：头部包括标题和标题下的幻灯片。</li>
<li>内容区：内容区包括图标导航和积分兑换套餐。</li>
<li>底部：固定底部导航栏。</li>
</ul>
<p>划分效果图：</p>
<figure data-type="image" tabindex="57"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/eM30S0A9zycg8ytxHnIF52Vtwbcdk3kdavk84Giu.png" alt="效果图" loading="lazy"></figure>
<p>综上得出页面大概的HTML结构：</p>
<pre><code>&lt;header class=&quot;header&quot;&gt;
    &lt;h2&gt;&lt;/h2&gt;
    &lt;img class=&quot;header-banner&quot;&gt;
&lt;/header&gt;
&lt;main class=&quot;content&quot;&gt;
    &lt;div class=&quot;content-nav&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;content-goods&quot;&gt;&lt;/div&gt;
&lt;/main&gt;
&lt;footer class=&quot;footer&quot;&gt;
&lt;/footer&gt;
</code></pre>
<h3 id="3-2-各部分开发">3-2 各部分开发</h3>
<p>到这里已经进入了开发阶段，开发阶段开发依据是任务2中提到的设计稿的开发版。首先添加基础样式：</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}
</code></pre>
<p>目的是将不同浏览器的margin和padding打平，之后人为统一设置。其次添加背景图样式：</p>
<pre><code>body {
    background: url(./imgs/blurcolor@2x.png) no-repeat no-repeat;
    background-size: cover;
}
</code></pre>
<p><code>background-size: cover</code>把背景图片放大到适合元素容器的尺寸，图片比例不变，但是要注意，超出容器的部分可能会裁掉。</p>
<p>在进行各部分开发之前，需要学习一个知识点：如何在电脑端打开移动端预览效果。首先是打开浏览器的开发者工具。Window系统可以右键网页，之后点击最后一项的检查即可；还可以直接按组合键：<code>alt + shift + i</code>。打开之后，选择开发者工具左上角的移动端图标即可，即可浏览当前网页的移动端效果。</p>
<h4 id="3-2-1-开发头部">3-2-1 开发头部</h4>
<p>头部HTML代码：</p>
<pre><code>&lt;header class=&quot;header&quot;&gt;
    &lt;h2&gt;信用卡积分兑换商城&lt;/h2&gt;
    &lt;img class=&quot;header-banner&quot; src=&quot;./imgs/banner@2x.png&quot;&gt;
&lt;/header&gt;
</code></pre>
<p>头部CSS：</p>
<pre><code>.header-banner {
    width: 100%;
}

.header h2 {
    height: 110px;
    text-align: center;
    line-height: 110px;
    font-size: 37px;
}
</code></pre>
<p><strong>预览效果如下图：</strong></p>
<figure data-type="image" tabindex="58"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/QgmzH1DLmdmRQelDMdWGmk7ohIt6uk4EoRhFv4Pl.png" alt="效果图" loading="lazy"></figure>
<h4 id="3-2-2-开发内容区">3-2-2 开发内容区</h4>
<p>头部内容的图标导航和积分兑换套餐均采用弹性盒子布局，也即display:flex。具体开发中，四个图标一行，均匀分布在一行上。积分兑换套餐竖向列举，每个之间竖向有一定间距；在实际最终的效果上还会加上无限加载效果。</p>
<p>HTML</p>
<pre><code>&lt;main class=&quot;content&quot;&gt;
    &lt;div class=&quot;content-nav&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x.png&quot;&gt;
                &lt;span&gt;本卡专区&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(2).png&quot;&gt;
                &lt;span&gt;汽车用品&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(4).png&quot;&gt;
                &lt;span&gt;潮流数码&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(6).png&quot;&gt;
                &lt;span&gt;户外运动&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(1).png&quot;&gt;
                &lt;span&gt;箱包饰品&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(3).png&quot;&gt;
                &lt;span&gt;摄影器材&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(5).png&quot;&gt;
                &lt;span&gt;电子礼券&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(7).png&quot;&gt;
                &lt;span&gt;全部商品&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;content-goods&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/商品／单品-图片1@2x.png&quot;&gt;
                &lt;p&gt;Galaxy Z系列 5折券&lt;/p&gt;
                &lt;p&gt;50积分&lt;/p&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/商品／单品-图片1@2x(2).png&quot;&gt;
                &lt;p&gt;Galaxy Note20系列&lt;/p&gt;
                &lt;p&gt;10000积分&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/商品／单品-图片1@2x(1).png&quot;&gt;
                &lt;p&gt;Galaxy Note10系列&lt;/p&gt;
                &lt;p&gt;80积分&lt;/p&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/商品／单品-图片1@2x(3).png&quot;&gt;
                &lt;p&gt;Galaxy Note20系列&lt;/p&gt;
                &lt;p&gt;50积分&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/main&gt;
</code></pre>
<p>CSS</p>
<pre><code>.content {
    padding-bottom: 200px;
}

.content .content-nav {
    padding: 48px;
}

.content .content-nav .item {
    display: flex;
    justify-content: space-between;
}

.content .content-nav .item+.item {
    margin-top: 48px;
}

.content .content-nav .item .unit {
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.content .content-nav .item span {
    margin-top: 20px;
    color: rgba(0, 0, 0, 0.65);
    text-align: center;
    font-size: 28px;
}

.content .content-goods {
    padding-left: 40px;
    padding-right: 40px;
}

.content .content-goods .item {
    display: flex;
    justify-content: space-between;
}

.content .content-goods .item .unit:first-child {
    margin-bottom: 22px;
}

.content .content-goods .item .unit {
    width: 324px;
    height: 432px;
    box-sizing: border-box;
    background: #FFFFFF;
    border-radius: 16px;
    border: 1px solid rgba(0, 0, 0, 0.1);
    padding: 24px;
}

.content .content-goods .item .unit img {
    display: block;
}

.content .content-goods .item .unit p:first-of-type {
    margin-top: 24px;
    color: rgba(0, 0, 0, 0.85);
}

.content .content-goods .item .unit p:last-of-type {
    margin-top: 12px;
    color: #3642FF;
}

.content .content-goods .item .unit p {
    font-size: 28px;
}
</code></pre>
<p><strong>预览效果如下图：</strong></p>
<figure data-type="image" tabindex="59"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/CQXnVxhULW74kIFGk69JRp9Dz9I0zMs4qQG1TCHE.gif" alt="效果图" loading="lazy"></figure>
<p>上述预览效果是在屏幕尺寸750，设备像素比为2下的效果。后面添加了自适应之后，你可以手动调整屏幕尺寸进而查看不同尺寸下的网页预览效果。当然也可以调整设备像素比值进行预览。</p>
<h4 id="3-2-3-开发底部">3-2-3 开发底部</h4>
<p>底部同样采用弹性盒子布局。同时底部固定在屏幕底部。</p>
<p>HTML</p>
<pre><code>&lt;footer class=&quot;footer&quot;&gt;
    &lt;div class=&quot;active&quot;&gt;
        &lt;img src=&quot;./imgs/Icon ／ ic_home@2x.png&quot;&gt;
        &lt;p&gt;首页&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;img src=&quot;./imgs/Icon-other@2x.png&quot;&gt;
        &lt;p&gt;分类&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;img src=&quot;./imgs/Icon-other@2x(1).png&quot;&gt;
        &lt;p&gt;订单&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;img src=&quot;./imgs/Icon-other@2x(2).png&quot;&gt;
        &lt;p&gt;我的&lt;/p&gt;
    &lt;/div&gt;
&lt;/footer&gt;
</code></pre>
<p>CSS</p>
<pre><code>.footer {
    width: 100%;
    position: fixed;
    bottom: 0;
    height: 100px;
    background: #FFFFFF;
    box-shadow: 0px -1px 8px 0px rgba(0, 0, 0, 0.06);
    display: flex;
    justify-content: space-around;
}

.footer div {
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center
}

.footer div p {
    text-align: center;
    font-size: 24px;
    color: #000000;
}

.footer div.active p {
    color: #3642FF;
}
</code></pre>
<p><strong>预览效果如下图：</strong></p>
<figure data-type="image" tabindex="60"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/HOKNkxnZVWU1txBNuY4PAEco6oedQfbHFFnFZNIj.png" alt="效果图" loading="lazy"></figure>
<h4 id="总体预览效果">总体预览效果</h4>
<figure data-type="image" tabindex="61"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/pSRLc8KRZPL3FQrgFEekfHfV6h0a2reNyzD41Tx5.gif" alt="效果图" loading="lazy"></figure>
<h4 id="总参考代码">总参考代码</h4>
<p>HTML</p>
<pre><code>&lt;header class=&quot;header&quot;&gt;
    &lt;h2&gt;信用卡积分兑换商城&lt;/h2&gt;
    &lt;img class=&quot;header-banner&quot; src=&quot;./imgs/banner@2x.png&quot;&gt;
&lt;/header&gt;
&lt;main class=&quot;content&quot;&gt;
    &lt;div class=&quot;content-nav&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x.png&quot;&gt;
                &lt;span&gt;本卡专区&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(2).png&quot;&gt;
                &lt;span&gt;汽车用品&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(4).png&quot;&gt;
                &lt;span&gt;潮流数码&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(6).png&quot;&gt;
                &lt;span&gt;户外运动&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(1).png&quot;&gt;
                &lt;span&gt;箱包饰品&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(3).png&quot;&gt;
                &lt;span&gt;摄影器材&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(5).png&quot;&gt;
                &lt;span&gt;电子礼券&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/编组@2x(7).png&quot;&gt;
                &lt;span&gt;全部商品&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;content-goods&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/商品／单品-图片1@2x.png&quot;&gt;
                &lt;p&gt;Galaxy Z系列 5折券&lt;/p&gt;
                &lt;p&gt;50积分&lt;/p&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/商品／单品-图片1@2x(2).png&quot;&gt;
                &lt;p&gt;Galaxy Note20系列&lt;/p&gt;
                &lt;p&gt;10000积分&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/商品／单品-图片1@2x(1).png&quot;&gt;
                &lt;p&gt;Galaxy Note10系列&lt;/p&gt;
                &lt;p&gt;80积分&lt;/p&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/商品／单品-图片1@2x(3).png&quot;&gt;
                &lt;p&gt;Galaxy Note20系列&lt;/p&gt;
                &lt;p&gt;50积分&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/main&gt;
&lt;footer class=&quot;footer&quot;&gt;
    &lt;div class=&quot;active&quot;&gt;
        &lt;img src=&quot;./imgs/Icon ／ ic_home@2x.png&quot;&gt;
        &lt;p&gt;首页&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;img src=&quot;./imgs/Icon-other@2x.png&quot;&gt;
        &lt;p&gt;分类&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;img src=&quot;./imgs/Icon-other@2x(1).png&quot;&gt;
        &lt;p&gt;订单&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;img src=&quot;./imgs/Icon-other@2x(2).png&quot;&gt;
        &lt;p&gt;我的&lt;/p&gt;
    &lt;/div&gt;
&lt;/footer&gt;
</code></pre>
<p>CSS</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}

body {
    background: url(./imgs/blurcolor@2x.png) no-repeat no-repeat;
    background-size: cover;
}

.header-banner {
    width: 100%;
}

.header h2 {
    height: 110px;
    text-align: center;
    line-height: 110px;
    font-size: 37px;
}

.content {
    padding-bottom: 200px;
}

.content .content-nav {
    padding: 48px;
}

.content .content-nav .item {
    display: flex;
    justify-content: space-between;
}

.content .content-nav .item+.item {
    margin-top: 48px;
}

.content .content-nav .item .unit {
    display: flex;
    flex-direction: column;
    justify-content: center;
}
</code></pre>
<h2 id="4-解决适配问题">4. 解决适配问题</h2>
<h3 id="4-1-利用rem解决尺寸大小问题">4-1 <strong>利用rem解决尺寸大小问题</strong></h3>
<h4 id="4-1-1-初始化改造">4-1-1 初始化改造</h4>
<p>在750px尺寸下，我们规定html元素字体大小为100px，之后据此改为css样式中的尺寸大小。将px为单位的尺寸改为rem为单位。换算公式：现在所有的px尺寸除以100就为rem值。修改后的css样式：</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}

body {
    background: url(./imgs/blurcolor@2x.png) no-repeat no-repeat;
    background-size: cover;
}

.header-banner {
    width: 100%;
}

.header h2 {
    height: 1.1rem;
    text-align: center;
    line-height: 1.1rem;
    font-size: 0.37rem;
}

.content {
    padding-bottom: 2rem;
}

.content .content-nav {
    padding: 0.48rem;
}

.content .content-nav .item {
    display: flex;
    justify-content: space-between;
}

.content .content-nav .item+.item {
    margin-top: 0.48rem;
}

.content .content-nav .item .unit {
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.content .content-nav .item .unit img {
    width: 1.12rem;
    height: 1.12rem;
}

.content .content-nav .item span {
    margin-top: 0.2rem;
    color: rgba(0, 0, 0, 0.65);
    text-align: center;
    font-size: 0.28rem;
    font-weight: 400;
}

.content .content-goods {
    padding-left: 0.4rem;
    padding-right: 0.4rem;
}

.content .content-goods .item {
    display: flex;
    justify-content: space-between;
}

.content .content-goods .item .unit:first-child {
    margin-bottom: 0.22rem;
}

.content .content-goods .item .unit {
    width: 3.24rem;
    height: 4.32rem;
    box-sizing: border-box;
    background: #FFFFFF;
    border-radius: 0.16rem;
    border: 1px solid rgba(0, 0, 0, 0.1);
    padding: 0.24rem;
}

.content .content-goods .item .unit img {
    width: 2.76rem;
    height: 2.76rem;
    display: block;
}

.content .content-goods .item .unit p:first-of-type {
    margin-top: 0.24rem;
    color: rgba(0, 0, 0, 0.85);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.content .content-goods .item .unit p:last-of-type {
    margin-top: 0.12rem;
    color: #3642FF;
}

.content .content-goods .item .unit p {
    font-size: 0.28rem;
}

.footer {
    width: 100%;
    position: fixed;
    bottom: 0;
    height: 1rem;
    background: #FFFFFF;
    box-shadow: 0px -1px 8px 0px rgba(0, 0, 0, 0.06);
    display: flex;
    justify-content: space-around;
}

.footer div {
    height: 100%;
    display: flex;
    justify-content: center;
    flex-direction: column;
}

.footer div p {
    text-align: center;
    font-size: 0.24rem;
    color: #000000;
}

.footer div img {
    width: 0.48rem;
    height: 0.48rem;
}

.footer div.active p {
    color: #3642FF;
}
</code></pre>
<p>同时将html根元素的字体大小改为100px：</p>
<pre><code>&lt;html lang=&quot;en&quot; style=&quot;font-size:100px;&quot;&gt;
...
&lt;/html&gt;
</code></pre>
<p>预览如下：</p>
<figure data-type="image" tabindex="62"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/axsaDrSbOiYPZdj4duvRUnON9yICFA8YPDf9g8zM.gif" alt="效果图" loading="lazy"></figure>
<h4 id="4-1-2-动态js自适应">4-1-2 动态js自适应</h4>
<p>上述改造只实现了屏幕尺寸为750px的情况。要想解决适配问题，需要满足当屏幕尺寸变大或者缩小时。html字体大小动态改变，为了解决这个问题，这里使用JavaScript实现。引入如下代码：</p>
<pre><code>(function (doc, win) {
    var docEl = doc.documentElement,
        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
        recalc = function () {
            var clientWidth = docEl.clientWidth;
            if (!clientWidth) return;
            docEl.style.fontSize = 100 * (clientWidth / 750) + 'px'; // 默认1:1时候是750
        };

    if (!doc.addEventListener) return;
    win.addEventListener(resizeEvt, recalc, false);
    doc.addEventListener('DOMContentLoaded', recalc, false);
})(document, window)
</code></pre>
<p>同时将其放在head结束标签的前面。这段代码的意思是：初始化的DOMContentLoaded执行recalc调整根元素字体大小，进而适配响应尺寸手机。如果在移动端触发orientationchange事件；如果在Web端，当屏幕尺寸变化时触发resize。之后调整页面元素尺寸，适配屏幕尺寸变化。上述750是设计稿的初始宽度值，如果设计稿为500或者375可以将其改为对应值。</p>
<p>重要的是理解设计到开发的原理。初始值参照的是1:1设计稿的尺寸。</p>
<p>预览如下：</p>
<figure data-type="image" tabindex="63"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/jnbmV6gncYkVYq6erH8dmR91kZAL1HNJu7PkizMt.gif" alt="效果图" loading="lazy"></figure>
<h3 id="4-2-利用img属性解决图片适配问题">4-2 <strong>利用img属性解决图片适配问题</strong></h3>
<p>rem解决了页面元素的尺寸变化，解决了主要的适配问题。但依然存在问题：不同设备像素比下采用同样尺寸的图片其视觉效果是不一样的，也就是实际不同手机下视觉效果不同统一。为了解决这个问题，这里采用img标签元素的属性srcset解决。参考：<a href="https://blog.csdn.net/u011927449/article/details/107444454">img标签-srcset属性_会做饭的技术男的博客-CSDN博客_img srcset</a>。</p>
<p>修改上述HTML：</p>
<pre><code>&lt;header class=&quot;header&quot;&gt;
    &lt;h2&gt;信用卡积分兑换商城&lt;/h2&gt;
    &lt;img class=&quot;header-banner&quot; src=&quot;./imgs/banner@2x.png&quot; srcset=&quot;./imgs/banner@2x.png 2x,./imgs/banner@3x.png 3x&quot;&gt;
&lt;/header&gt;
&lt;main class=&quot;content&quot;&gt;
    &lt;div class=&quot;content-nav&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/unique@2x.png&quot; srcset=&quot;./imgs/unique@2x.png 2x,./imgs/unique@3x.png 3x&quot;&gt;
                &lt;span&gt;本卡专区&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/car@2x.png&quot; srcset=&quot;./imgs/car@2x.png 2x,./imgs/car@3x.png 3x&quot;&gt;
                &lt;span&gt;汽车用品&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/digital@2x.png&quot; srcset=&quot;./imgs/digital@2x.png 2x,./imgs/digital@3x.png 3x&quot;&gt;
                &lt;span&gt;潮流数码&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/sport@2x.png&quot; srcset=&quot;./imgs/sport@2x.png 2x,./imgs/sport@3x.png 3x&quot;&gt;
                &lt;span&gt;户外运动&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/bag@2x.png&quot; srcset=&quot;./imgs/bag@2x.png 2x,./imgs/bag@3x.png 3x&quot;&gt;
                &lt;span&gt;箱包饰品&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/photo@2x.png&quot; srcset=&quot;./imgs/photo@2x.png 2x,./imgs/photo@3x.png 3x&quot;&gt;
                &lt;span&gt;摄影器材&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/card@2x.png&quot; srcset=&quot;./imgs/card@2x.png 2x,./imgs/card@3x.png 3x&quot;&gt;
                &lt;span&gt;电子礼券&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/goods@2x.png&quot; srcset=&quot;./imgs/goods@2x.png 2x,./imgs/goods@3x.png 3x&quot;&gt;
                &lt;span&gt;全部商品&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;content-goods&quot;&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/backz@2x.png&quot; srcset=&quot;./imgs/backz@2x.png 2x,./imgs/backz@3x.png 3x&quot;&gt;
                &lt;p&gt;Galaxy Z系列 5折券&lt;/p&gt;
                &lt;p&gt;50积分&lt;/p&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/phone@2x.png&quot; srcset=&quot;./imgs/phone@2x.png 2x,./imgs/phone@3x.png 3x&quot;&gt;
                &lt;p&gt;Galaxy Note20系列&lt;/p&gt;
                &lt;p&gt;10000积分&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/battery@2x.png&quot; srcset=&quot;./imgs/battery@2x.png 2x,./imgs/battery@3x.png 3x&quot;&gt;
                &lt;p&gt;Galaxy Note10系列&lt;/p&gt;
                &lt;p&gt;80积分&lt;/p&gt;
            &lt;/div&gt;
            &lt;div class=&quot;unit&quot;&gt;
                &lt;img src=&quot;./imgs/back20@2x.png&quot; srcset=&quot;./imgs/back20@2x.png 2x,./imgs/back20@3x.png 3x&quot;&gt;
                &lt;p&gt;Galaxy Note20系列&lt;/p&gt;
                &lt;p&gt;50积分&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/main&gt;
&lt;footer class=&quot;footer&quot;&gt;
    &lt;div class=&quot;active&quot;&gt;
        &lt;img src=&quot;./imgs/home@2x.png&quot; srcset=&quot;./imgs/home@2x.png 2x,./imgs/home@3x.png 3x&quot;&gt;
        &lt;p&gt;首页&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;img src=&quot;./imgs/kindof@2x.png&quot; srcset=&quot;./imgs/kindof@2x.png 2x,./imgs/kindof@3x.png 3x&quot;&gt;
        &lt;p&gt;分类&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;img src=&quot;./imgs/order@2x.png&quot; srcset=&quot;./imgs/order@2x.png 2x,./imgs/order@3x.png 3x&quot;&gt;
        &lt;p&gt;订单&lt;/p&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;img src=&quot;./imgs/my@2x.png&quot; srcset=&quot;./imgs/my@2x.png 2x,./imgs/my@3x.png 3x&quot;&gt;
        &lt;p&gt;我的&lt;/p&gt;
    &lt;/div&gt;
&lt;/footer&gt;
</code></pre>
<p>以上代码当设备像素比&lt;=2，采用@2x也就是2倍图片；当设备像素比&gt;2采用@2x也就是3倍图片。这主要考虑到大尺寸时候使用@1x也就是1倍图失真严重。</p>
<h3 id="4-3-利用媒体查询解决背景图片适配问题">4-3 <strong>利用媒体查询解决背景图片适配问题</strong></h3>
<p>这里采用媒体查询检测设备像素比然后修改背景图片，参考：<a href="https://www.shejidaren.com/css-device-pixel-ratio.html">CSS 或 srcset 让浏览器自动切换 1X/2X/3X 图像 | 设计达人</a>，添加如下CSS：</p>
<pre><code>/* 如果设备像素大于等于2，则用2倍图 */
@media screen and (-webkit-min-device-pixel-ratio: 2),
screen and (min--moz-device-pixel-ratio: 2) {
    body {
        background: url(./imgs/blurcolor@2x.png) no-repeat no-repeat;
    }
}

/* 如果设备像素大于等于3，则用3倍图 */
@media screen and (-webkit-min-device-pixel-ratio: 3),
screen and (min--moz-device-pixel-ratio: 3) {
    body {
        background: url(./imgs/blurcolor@3x.png) no-repeat no-repeat;
    }
}
</code></pre>
<h3 id="4-4-其他rem动态自适应方案">4-4 其他rem动态自适应方案</h3>
<p>还可以使用阿里出的[GitHub - amfe/lib-flexible: 可伸缩布局方案]。但是目前官方已经指出可以放弃这种方案，建议使用vh/vw做自适应。</p>
<p>关于vh/vw自适应可以参考：<a href="https://blog.csdn.net/weixin_39939012/article/details/80734727">再聊移动端页面的适配_蜗牛不会跑~的博客-CSDN博客_再聊移动端页面的适配</a>。实质是单位转换的方式问题，rem使用的html根元素大小变化，vh/wh使用的是屏幕尺寸的变化。</p>
<h3 id="4-5-代码优化">4-5 代码优化</h3>
<h4 id="4-5-1-优化1px边框问题">4-5-1 优化1px边框问题</h4>
<p>对于设备像素比不是1的Retina屏，1px效果会被放大。添加如下css，解决这个问题。</p>
<pre><code>@media screen and(-webkit-min-device-pixel-ratio：2),
screen and (min--moz-device-pixel-ratio: 2) {
    .content .content-goods .item .unit {
        border: 0.5px solid rgba(0, 0, 0, 0.1);
    }
}

@media screen and(-webkit-min-device-pixel-ratio: 3),
screen and (min--moz-device-pixel-ratio: 3) {
    .content .content-goods .item .unit {
        border: 0.3333px solid rgba(0, 0, 0, 0.1);
    }
}
</code></pre>
<h4 id="4-5-1-设置最小尺寸">4-5-1 设置最小尺寸</h4>
<p>当屏幕尺寸很小时，虽然有自适应方案，但布局依然会变形，这时可以设置最小屏幕宽度，如果小于320不再缩小。修改JavaScript：</p>
<pre><code>(function (doc, win) {
    const docEl = doc.documentElement,
        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
        recalc = function () {
            let clientWidth = docEl.clientWidth;
            if (!clientWidth) return;
            // 如果小于320不在缩小
            clientWidth = clientWidth &lt; 320 ? 320 : clientWidth
            docEl.style.fontSize = 100 * (clientWidth / 750) + 'px';
        };

    if (!doc.addEventListener) return;
    win.addEventListener(resizeEvt, recalc, false);
    doc.addEventListener('DOMContentLoaded', recalc, false);
})(document, window)
</code></pre>
<h3 id="4-6-移动端预览">4-6 移动端预览</h3>
<p>这里的移动端是荣耀30手机，当然其他手机也可以的。</p>
<p>首先通过已经安装的npm安装anywhere这个nodejs包。打开命令行控制台，输入<code>npm install anywhere -g</code>。anywhere是一个可以在当前文件目录下开启web服务器的nodejs包。关于anywhere更多详情：<a href="https://www.npmjs.com/package/anywhere">anywhere</a>。</p>
<p>之后在商城首页html文件所在文件夹下打开命令行控制台，输入anywhere 9090，9090是端口号。随即浏览器会打开新的tab窗口，之后打开开发者工具切换到移动端预览状态，之后访问我们的订单页面。</p>
<figure data-type="image" tabindex="64"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/P454IvoynqcQPuUbZrjpuVuySq6RnaqpnXzRBbpp.png" alt="效果图" loading="lazy"></figure>
<blockquote>
<p>注意：如果你的文件默认是index.html，浏览器打开的就是这个文件；如果不是这个文件名，则需要手动切换，比如我的移动端页面为mobile.html，所以我的访问地址为：http://192.168.1.3:9090/mobile.htm。</p>
</blockquote>
<p>将你的这个地址发到手机上，通过微信、钉钉或者其他聊天工具，还可以手动在手机浏览器地址栏输入。为了保证打开这个网址时能够正确预览到页面，需要保证当前手机和电脑处于同一网络下，比如同一wifi下。手机微信打开后预览效果如下：</p>
<figure data-type="image" tabindex="65"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/AftUhekHcuG26KjAFGSsrm83Xi5gLt7OXeXA040J.png" alt="效果图" loading="lazy"></figure>
<figure data-type="image" tabindex="66"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0615/admin/RWjIi62cVkhTgbRgKXoIEgAJhk6Nj4G9YSQfgAsa.png" alt="img" loading="lazy"></figure>
<h1 id="一体化审核平台项目">一体化审核平台项目</h1>
<h2 id="1-项目概览-2">1. 项目概览</h2>
<p>本项目以提升实际动手能力为核心，使用Vue2、Vue Router、Element-ui组件库、Axios等搭建项目。</p>
<p>为了方便循序渐进学习，本项目拆分为5个任务：</p>
<p>任务1：初始化vue2工程，安装Element-ui、axios等依赖</p>
<p>任务2：封装axios使用拦截器拦截数据处理数据</p>
<p>任务3: 开发一体化审核平台首页</p>
<p>任务4：开发一体化审核平台流程待处理菜单</p>
<p>任务5：优化项目管理平台</p>
<p><strong>各个任务之间的关联：</strong></p>
<p>创建项目是第一步，然后安装Element-UI、Vue-router和axios等依赖，以便后面开发使用。之后封装axios，以便后面调用接口使用。这些准备好之后开始具体功能开发：开发首页、开发流程待处理菜单页。最后是整个项目的优化。</p>
<h3 id="你将获得什么">你将获得什么？</h3>
<ol>
<li>学习创建vue2项目</li>
<li>学习使用vue相关Api</li>
<li>学习Element-ui</li>
<li>学习Axios的封装以及Mock数据</li>
<li>学习Vue Router</li>
<li>学习Vue项目优化</li>
</ol>
<h2 id="2-封装axios">2. 封装axios</h2>
<h3 id="2-1-封装各种常用http请求方法">2-1 封装各种常用http请求方法</h3>
<p>在src目录下创建config文件夹，在config文件夹下创建ajax.js文件，写入下面代码：</p>
<pre><code class="language-js">import axios from 'axios'

const qs = require('qs')
/**
 * axios的get请求
 * @param {*} dataParams 
 * @returns 
 */
export const ajaxGetData = dataParams =&gt; {
  return axios.get(dataParams.url, { params: dataParams.params })
}

/**
 * axios的delete请求
 * @param {*} dataParams 
 * @returns 
 */
export const ajaxDeleteData = dataParams =&gt; {
  return axios.delete(dataParams.url, { params: dataParams.params })
}
/**
 * axios的post请求之一，用于上传文件
 * @param {*} dataParams 
 * @returns 
 */
export const ajaxPostFormData = dataParams =&gt; {
  return axios({
    method: 'post',
    url: dataParams.url,
    data: dataParams.params,
    headers: {
      'Content-Type': 'multipart/form-data'
    }
  })
}

/**
 * delete的json数据请求
 * @param {*} dataParams 
 * @returns 
 */
export const ajaxDeleteJson = (dataParams) =&gt; {
  return axios({
    url: dataParams.url,
    method: 'delete',
    data: dataParams.params,
    headers: {
      'Content-Type': 'application/json;charset=UTF-8'
    }
  })
}

/**
 * post普通请求
 * @param {*} dataParams 
 * @returns 
 */
export const ajaxPostData = dataParams =&gt; {
  return axios.post(dataParams.url, qs.stringify(dataParams.params))
}

/**
 * put的json请求
 * @param {*} dataParams 
 * @returns 
 */
export const ajaxPutJson = dataParams =&gt; {
  const axiosConfig = {
    headers: {
      'Content-Type': 'application/json;charset=UTF-8'
    }
  }
  return axios.put(dataParams.url, dataParams.params, axiosConfig)
}

/**
 * post的json请求
 * @param {*} dataParams 
 * @returns 
 */
export const ajaxPostJson = dataParams =&gt; {
  const axiosConfig = {
    headers: {
      'Content-Type': 'application/json;charset=UTF-8'
    }
  }
  return axios.post(dataParams.url, dataParams.params, axiosConfig)
}
</code></pre>
<p>备注：上述代码封装了常用的http请求：get、post、postJson等等。</p>
<h3 id="2-2-实现axios请求拦截器"><strong>2-2 实现axios请求拦截器</strong></h3>
<p>封装请求方法之后利用拦截器对请求错误请求进行处理，下面是请求拦截器。</p>
<pre><code class="language-js">import axios from 'axios'

/**
 * 全部请求拦截器处理
 */
const pendingRequests = new Map()
axios.interceptors.request.use(function (config) {
  const params = config.params || config.data
  const requestKey = `${config.url}/${JSON.stringify(params)}&amp;request_type=${config.method}`
  if (pendingRequests.has(requestKey)) {
    config.cancelToken = new axios.CancelToken((cancel) =&gt; {
      // cancel(`重复的请求被主动拦截: ${requestKey}`)
    })
  } else {
    pendingRequests.set(requestKey, config)
    config.requestKey = requestKey
  }
  return config
},
function (error) {
  pendingRequests.clear()
  return Promise.reject(error)
}
)
</code></pre>
<p>备注：上述代码对axios的请求做全局拦截。同时使用Map保存当前请求的url，作为请求的唯一表示。如果前端发出相同请求，且上一次请求与本次一致，则取消当前请求。该设置可以有效防止前端重复发出的请求，也可以预防表单的重复提交。</p>
<h3 id="2-3-实现axios响应拦截器"><strong>2-3 实现axios响应拦截器</strong></h3>
<p>下面是响应拦截器。</p>
<pre><code class="language-js">import axios from 'axios'
import { Message } from 'element-ui'

const dealCode = (response) =&gt; {
  const code = response.data.code
  if(code !== 200) {
    Message({
      message: response.data.msg,
      type: 'warning'
    })
    return Promise.reject(response.data)
  }
  return response.data
}

/**
 * 全局响应拦截器
 */
const pendingRequests = new Map()
axios.interceptors.response.use(response =&gt; {
  const requestKey = response.config.requestKey
  pendingRequests.delete(requestKey)
  return dealCode(response)
}, error =&gt; {
  pendingRequests.clear()
  if (axios.isCancel(error)) {
    const message = error &amp;&amp; error.response &amp;&amp; error.response.data
    Message({
      message: message || '接口或网络异常',
      type: 'error'
    })
    return Promise.reject(error)
  }
  if (error) {
    Message({
      message: error.message === 'Network Error' ? '接口或网络异常' : error.message,
      type: 'error'
    })
    return Promise.reject(error)
  }
  return Promise.reject(error)
})
</code></pre>
<p>备注：上述代码对axios响应做了全局封装。同时对清除Map中缓存的请求唯一标识。同时对响应过来的状态码和数据格式做了统一处理。</p>
<h3 id="2-4-课后练习">2-4 课后练习</h3>
<p>当请求发生错误时，尝试重新请求，最大请求次数3次，之后放弃请求。参考：<a href="https://www.cnblogs.com/echolife/p/11390141.html">axios 设置接口retry次数与间隔时间 - echolife - 博客园</a>。</p>
<h2 id="3-开发一体化审核平台首页">3. 开发一体化审核平台首页</h2>
<h3 id="3-1-开发首页前准备">3-1 开发首页前准备</h3>
<p>你需要在开发之前将vue初始化工程创建的文件修改，以及修改vue-router配置。我们修改src目录下app.vue文件代码，app.vue是首页文件，可以直接通过http://localhost:8080访问到</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &quot;app&quot;,
  components: {},
};
&lt;/script&gt;

&lt;style lang=&quot;scss&quot;&gt;
* {
  margin: 0px;
  padding: 0px;
}

#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: #2c3e50;
}
body {
  background-color: #efeaed;
}
&lt;/style&gt;
</code></pre>
<p>备注：其中css样式设置所有元素的padding和margin为0，是为了统一不同浏览器的两个值的默认值。vue-router的配置文件代码：</p>
<pre><code>import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)

let routes = [
{
  path: '/home',
  icon: 'Management',
  name: '审批中心主页',
  component: null,
  children: []
},
{
  path: '/todo',
  icon: 'List',
  name: '流程待处理',
  component: null,
  children: []
}];

const router = new VueRouter({
  mode: 'history',
  routes
})

export default router
</code></pre>
<p>备注：上面写了两个没有组件或者没有页面的路径以便于后续使用，组件后续添加。之后删除位于src目录下工程初始化创建时创建的AboutView文件。</p>
<h3 id="3-2-开发首页-页面分析">3-2 开发首页-页面分析</h3>
<p>终于到了开发页面的环节，先看下开发后的效果或者设计稿：</p>
<figure data-type="image" tabindex="67"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/h3wKHTKcZBsllzaRLFPyDpE9Uop6EdU4aC7Fj5Wx.png" alt="image.png" loading="lazy"></figure>
<p>这里我将页面划分为上下两部分，其中下又分为左右两部分。</p>
<figure data-type="image" tabindex="68"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/zHF5AOnBVDiD0ee8GJHrpNODOw2FCzsQS1HnoT6I.png" alt="image.png" loading="lazy"></figure>
<p>其中上部分也就是顶部导航固定。下部分的左侧导航栏固定，下部分右侧部分也就是内容区使用margin-left实现其位置。</p>
<h3 id="3-3-开发首页-开发顶部导航">3-3 开发首页-开发顶部导航</h3>
<p>按照3-2的任务分析，开始开发。使用固定定位结合flex布局开发项目顶部导航，代码如下：</p>
<pre><code>&lt;template&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;header&gt;
          &lt;div class=&quot;logo&quot;&gt;
            &lt;i class=&quot;el-icon-discover&quot; style=&quot;display:block;width: 20px; height: 20px; margin-right: 8px&quot;&gt;&lt;/i&gt;
            &lt;span&gt;兔子审核&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class=&quot;slogo&quot;&gt;
            &lt;p class=&quot;line&quot;&gt;&lt;/p&gt;
            &lt;p class=&quot;slogo-content&quot;&gt;一体化审核平台！&lt;/p&gt;
          &lt;/div&gt;
          &lt;div class=&quot;userinfo&quot;&gt;
            &lt;el-dropdown trigger=&quot;hover&quot; @command=&quot;logout&quot;&gt;
                &lt;i class=&quot;el-icon-user&quot; style=&quot;color:#fff;font-size:16px;&quot;&gt;&lt;/i&gt;
                &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
                  &lt;el-dropdown-item&gt;我的消息&lt;/el-dropdown-item&gt;
                  &lt;el-dropdown-item&gt;设置&lt;/el-dropdown-item&gt;
                  &lt;el-dropdown-item command=&quot;logout&quot; divided
                    &gt;退出登录&lt;/el-dropdown-item
                  &gt;
                &lt;/el-dropdown-menu&gt;
            &lt;/el-dropdown&gt;
          &lt;/div&gt;
        &lt;/header&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data() {
        return {
        }
    },
    methods: {
    }
}

&lt;/script&gt;

&lt;style scoped lang=&quot;scss&quot;&gt;
.container {
    header {
        position: fixed;
        top: 0;
        height: 48px;
        line-height: 48px;
        width: 100%;
        background: #1e80ff;
        color: #fff;
        z-index: 1000;
        display: flex;

        .logo {
            height: 100%;
            width: 100%;
            display: flex;
            align-items: center;
            width: 200px;
            padding-left: 8px;
            font-weight: bold;

            span {
                font-size: 16px;
            }
        }

        .slogo {
            flex: 1;
            display: flex;
            align-items: center;

            p.line {
                height: 20px;
                background-color: #ccc;
                width: 1px;
            }

            p.slogo-content {
                margin-left: 8px;
                color: #fff;
            }
        }

        .userinfo {
            display: flex;
            align-items: center;
            padding-right: 16px;
            flex: 1;
            justify-content: flex-end;

            .avatar {
                width: 24px;
                height: 24px;
                cursor: pointer;
                color: #fff;
            }
        }

    }
}
&lt;/style&gt;
</code></pre>
<p>备注：上述代码采用固定定位结合flex布局实现。预览效果</p>
<figure data-type="image" tabindex="69"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/qCDmUvAv6vpGj3Sq8KAdcx7IXNR9DTAKAGvl9ZJq.png" alt="image.png" loading="lazy"></figure>
<h3 id="3-4-开发首页-开发左侧导航">3-4 开发首页-开发左侧导航</h3>
<p>按照从上到下，从左到右的总体开发原则。先进行左侧导航开发，左侧导航使用固定定位，并使用elment-ui的导航组件添加导航。具体使用的是menu菜单，详情见：<a href="https://element.eleme.cn/#/zh-CN/component/menu">组件 | Element</a>。</p>
<h4 id="3-4-1-开发无内容的左侧导航">3-4-1 开发无内容的左侧导航</h4>
<p>我们修改app.vue文件，增加代码</p>
<pre><code>&lt;template&gt;
    &lt;div class=&quot;container&quot;&gt;
        ...
        &lt;aside class=&quot;nav&quot;&gt;
        
        &lt;/aside&gt; 
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data() {
        return {
        }
    },
    methods: {
    }
}

&lt;/script&gt;

&lt;style scoped lang=&quot;scss&quot;&gt;
    // 增加nav类
    .nav {
        position: fixed;
        top: 48px;
        background-color: #fff;
        bottom: 0;
        width: 208px;
    }
}
&lt;/style&gt;
</code></pre>
<p>备注：上述代码采用了固定定位。预览效果</p>
<figure data-type="image" tabindex="70"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/kRtjTTQibb46ylhKUxVcMEN4e6xbBQ2NOPNRZGuQ.png" alt="image.png" loading="lazy"></figure>
<h4 id="3-4-2-使用vue-router配置生成左侧导航">3-4-2 使用vue-router配置生成左侧导航</h4>
<p>左侧导航具体实现使用element-ui的el-menu组件，其配置参数可以写死，也可以使用vue-router配置动态生成导航。因为我已经写好了vue-router文件，这里就直接实现动态生成导航，修改app.vue文件，添加如下代码：</p>
<pre><code>&lt;template&gt;
    &lt;div class=&quot;container&quot;&gt;
        ……
        &lt;aside class=&quot;nav&quot;&gt;
            &lt;!-- 添加代码 --&gt;
            &lt;el-menu :default-openeds=&quot;['/']&quot; :default-active=&quot;$route.path&quot; router class=&quot;el-menu-vertical-demo&quot;
                :collapse=&quot;isCollapse&quot;&gt;
                &lt;template v-for=&quot;item in $router.options.routes&quot; :key=&quot;item.name&quot;&gt;
                    &lt;el-sub-menu :index=&quot;item.path&quot;
                        v-if=&quot;item.children &amp;&amp; item.children.length &gt; 0&quot;&gt;
                        &lt;template slot=&quot;title&quot;&gt;
                            &lt;i :class=&quot;[item.icon]&quot;&gt;&lt;/i&gt;
                            &lt;span&gt;{{ item.name }}&lt;/span&gt;
                        &lt;/template&gt;
                        &lt;template v-for=&quot;child in item.children&quot; :key=&quot;child.name&quot;&gt;
                            &lt;el-menu-item :index=&quot;child.path&quot;&gt;
                                {{ child.name }}&lt;/el-menu-item&gt;
                        &lt;/template&gt;
                    &lt;/el-sub-menu&gt;
                    &lt;el-menu-item :index=&quot;item.path&quot; v-else&gt;
                         &lt;i :class=&quot;[item.icon]&quot;&gt;&lt;/i&gt;
                        &lt;template slot=&quot;title&quot;&gt;{{ item.name }}&lt;/template&gt;
                    &lt;/el-menu-item&gt;
                &lt;/template&gt;
            &lt;/el-menu&gt;
        &lt;/aside&gt; 
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>备注：这里主要借助了vue内置的api（$router.options.routes）结合el-menu实现导航的遍历输出</p>
<h3 id="3-5-开发首页-设置右侧内容区域位置以及设置路由占位符">3-5 开发首页-设置右侧内容区域位置以及设置路由占位符</h3>
<p>在页面分析中我们提到顶部导航和左侧导航内容都是相对不变的。在实际中只有右侧内容区发生变化。变化的部分对应的是访问路径的改变，所以我们可以在这里增加路由占位符。修改App.vue文件内容，增加router-view组件：</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;header&gt;
      &lt;div class=&quot;logo&quot;&gt;
        &lt;i class=&quot;el-icon-discover&quot; style=&quot;display:block;width: 20px; height: 20px; margin-right: 8px&quot;&gt;&lt;/i&gt;
        &lt;span&gt;兔子审核&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;slogo&quot;&gt;
        &lt;p class=&quot;line&quot;&gt;&lt;/p&gt;
        &lt;p class=&quot;slogo-content&quot;&gt;一体化审核平台！&lt;/p&gt;
      &lt;/div&gt;
      &lt;div class=&quot;userinfo&quot;&gt;
        &lt;el-dropdown trigger=&quot;hover&quot;&gt;
          &lt;i class=&quot;el-icon-user&quot; style=&quot;color:#fff;font-size:16px;&quot;&gt;&lt;/i&gt;
          &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
            &lt;el-dropdown-item&gt;我的消息&lt;/el-dropdown-item&gt;
            &lt;el-dropdown-item&gt;设置&lt;/el-dropdown-item&gt;
            &lt;el-dropdown-item divided&gt;退出登录&lt;/el-dropdown-item&gt;
          &lt;/el-dropdown-menu&gt;
        &lt;/el-dropdown&gt;
      &lt;/div&gt;
    &lt;/header&gt;
    &lt;aside class=&quot;nav&quot;&gt;
      &lt;el-menu :default-openeds=&quot;['/']&quot; :default-active=&quot;$route.path&quot; router class=&quot;el-menu-vertical-demo&quot;&gt;
        &lt;template v-for=&quot;item in $router.options.routes&quot; :key=&quot;item.name&quot;&gt;
          &lt;el-sub-menu :index=&quot;item.path&quot; v-if=&quot;item.children &amp;&amp; item.children.length &gt; 0&quot;&gt;
            &lt;template slot=&quot;title&quot;&gt;
              &lt;i :class=&quot;[item.icon]&quot;&gt;&lt;/i&gt;
              &lt;span&gt;{{ item.name }}&lt;/span&gt;
            &lt;/template&gt;
            &lt;template v-for=&quot;child in item.children&quot; :key=&quot;child.name&quot;&gt;
              &lt;el-menu-item :index=&quot;child.path&quot;&gt;
                {{ child.name }}&lt;/el-menu-item&gt;
            &lt;/template&gt;
          &lt;/el-sub-menu&gt;
          &lt;el-menu-item :index=&quot;item.path&quot; v-else&gt;
            &lt;i :class=&quot;[item.icon]&quot;&gt;&lt;/i&gt;
            &lt;template slot=&quot;title&quot;&gt;{{ item.name }}&lt;/template&gt;
          &lt;/el-menu-item&gt;
        &lt;/template&gt;
      &lt;/el-menu&gt;
    &lt;/aside&gt;
    &lt;aside class=&quot;content&quot;&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/aside&gt;
    &lt;/aside&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
    };
  },
  methods: {},
};
&lt;/script&gt;

&lt;style scoped lang=&quot;scss&quot;&gt;
.container {
  header {
    position: fixed;
    top: 0;
    height: 48px;
    line-height: 48px;
    width: 100%;
    background: #1e80ff;
    color: #fff;
    z-index: 1000;
    display: flex;

    .logo {
      height: 100%;
      width: 100%;
      display: flex;
      align-items: center;
      width: 200px;
      padding-left: 8px;
      font-weight: bold;

      span {
        font-size: 16px;
      }
    }

    .slogo {
      flex: 1;
      display: flex;
      align-items: center;

      p.line {
        height: 20px;
        background-color: #ccc;
        width: 1px;
      }

      p.slogo-content {
        margin-left: 8px;
        color: #fff;
      }
    }

    .userinfo {
      display: flex;
      align-items: center;
      padding-right: 16px;
      flex: 1;
      justify-content: flex-end;

      .avatar {
        width: 24px;
        height: 24px;
        cursor: pointer;
        color: #fff;
      }
    }
  }

  .nav {
    position: fixed;
    top: 48px;
    background-color: #fff;
    bottom: 0;
    width: 208px;
  }

  .content {
    margin-left: 213px;
    margin-top: 53px;
  }
}
&lt;/style&gt;
</code></pre>
<p>最终预览效果</p>
<figure data-type="image" tabindex="71"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/S1hKTZfRckLlZI6eiWeXP2kuF36Iztsla4nckqwh.png" alt="image.png" loading="lazy"></figure>
<h3 id="3-6-开发审批中心主页">3-6 开发审批中心主页</h3>
<p>到这里开始真正开发路由对应的页面了。代码写在初始化工程时创建的HomeView.vue文件中，如下：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    &lt;div class=&quot;breadcrumb&quot;&gt;审批中心主页&lt;/div&gt;
    &lt;el-row :gutter=&quot;10&quot;&gt;
      &lt;el-col :span=&quot;5&quot;
        &gt;&lt;div class=&quot;grid-content same&quot;&gt;流程合计： 5&lt;/div&gt;&lt;/el-col
      &gt;
      &lt;el-col :span=&quot;5&quot;&gt;&lt;div class=&quot;grid-content same&quot;&gt;已处理：2&lt;/div&gt;&lt;/el-col&gt;
      &lt;el-col :span=&quot;5&quot;&gt;&lt;div class=&quot;grid-content same&quot;&gt;待处理：3&lt;/div&gt;&lt;/el-col&gt;
      &lt;el-col :span=&quot;9&quot;
        &gt;&lt;div class=&quot;grid-content four&quot;&gt;
          &lt;p&gt;
            &lt;i class=&quot;el-icon-message-solid&quot; style=&quot;color:#67c23a&quot;&gt;&lt;/i&gt;
            &lt;span&gt;消息提醒&lt;/span&gt;
          &lt;/p&gt;
          &lt;div class=&quot;mes-box&quot;&gt;
            &lt;p&gt;
              &lt;span
                &gt;
                &lt;i class=&quot;el-icon-info info-icon&quot;&gt;&lt;/i&gt;
                &lt;span class=&quot;mes&quot;&gt;消息1&lt;/span&gt; &lt;/span
              &gt;&lt;span class=&quot;mes&quot;&gt;xx1&lt;/span&gt;
            &lt;/p&gt;
            &lt;p&gt;
              &lt;span
                &gt;
                &lt;i class=&quot;el-icon-info info-icon&quot;&gt;&lt;/i&gt;
                &lt;span class=&quot;mes&quot;&gt;消息2&lt;/span&gt; &lt;/span
              &gt;&lt;span class=&quot;mes&quot;&gt;xx2&lt;/span&gt;
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;&lt;/el-col
      &gt;
    &lt;/el-row&gt;
    &lt;el-row :gutter=&quot;10&quot; class=&quot;echart-box&quot;&gt;
      &lt;el-col :span=&quot;12&quot;&gt;
        &lt;el-card class=&quot;box-card&quot;&gt;
          &lt;template slot=&quot;header&quot;&gt;
            &lt;div class=&quot;card-header&quot;&gt;
              &lt;span&gt;近一年任务累计统计图&lt;/span&gt;
            &lt;/div&gt;
          &lt;/template&gt;
          &lt;div class=&quot;stack-line echart&quot;&gt;&lt;/div&gt;
        &lt;/el-card&gt;
      &lt;/el-col&gt;
      &lt;el-col :span=&quot;12&quot;&gt;
        &lt;el-card class=&quot;box-card&quot;&gt;
          &lt;template slot=&quot;header&quot;&gt;
            &lt;div class=&quot;card-header&quot;&gt;
              &lt;span&gt;业务详细占比图&lt;/span&gt;
            &lt;/div&gt;
          &lt;/template&gt;
          &lt;div class=&quot;doughnut echart&quot;&gt;&lt;/div&gt; &lt;/el-card
      &gt;&lt;/el-col&gt;
    &lt;/el-row&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import * as echarts from &quot;echarts&quot;;

export default {
  name: &quot;HomeView&quot;,
  methods: {
    darwEchart (dom, option) {
      const chartDom = document.querySelector(dom);
      const myChart = echarts.init(chartDom);
      option &amp;&amp; myChart.setOption(option);
      return myChart;
    },
    darwEchartStackLine(){
      const option = {
        tooltip: {
          trigger: &quot;axis&quot;,
        },
        legend: {
          data: [&quot;流程合计&quot;, &quot;已处理&quot;, &quot;待处理&quot;],
        },
        grid: {
          left: &quot;3%&quot;,
          right: &quot;7%&quot;,
          bottom: &quot;3%&quot;,
          containLabel: true,
        },
        xAxis: {
          name: &quot;月份&quot;,
          type: &quot;category&quot;,
          // boundaryGap: false,
          data: [
            &quot;2021-10&quot;,
            &quot;2021-11&quot;,
            &quot;2021-12&quot;,
            &quot;2022-1&quot;,
            &quot;2022-2&quot;,
            &quot;2022-3&quot;,
            &quot;2022-4&quot;,
            &quot;2022-5&quot;,
            &quot;2022-6&quot;,
            &quot;2022-7&quot;,
          ],
        },
        yAxis: {
          name: &quot;任务量&quot;,
          type: &quot;value&quot;,
        },
        series: [
          {
            name: &quot;流程合计&quot;,
            type: &quot;line&quot;,
            stack: &quot;Total&quot;,
            data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          },
          {
            name: &quot;已处理&quot;,
            type: &quot;line&quot;,
            stack: &quot;Total&quot;,
            data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          },
          {
            name: &quot;待处理&quot;,
            type: &quot;line&quot;,
            stack: &quot;Total&quot;,
            data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
          },
        ],
      };
      this.darwEchart(&quot;div.stack-line&quot;, option);
    },
    darwEchartDoughnut(){
      const option = {
        tooltip: {
          trigger: &quot;item&quot;,
        },
        legend: {
          orient: &quot;vertical&quot;,
          left: &quot;left&quot;,
          
        },
        series: [
          {
            name: &quot;Access From&quot;,
            type: &quot;pie&quot;,
            radius: &quot;50%&quot;,
            data: [
              { value: 1048, name: &quot;授信审核&quot; }
            ],
            emphasis: {
              itemStyle: {
                shadowBlur: 10,
                shadowOffsetX: 0,
                shadowColor: &quot;rgba(0, 0, 0, 0.5)&quot;,
              },
            },
          },
        ],
      };
      this.darwEchart(&quot;div.doughnut&quot;, option);
    }
  },
  mounted(){
    this.darwEchartStackLine();
    this.darwEchartDoughnut();
  }
};
&lt;/script&gt;
&lt;style lang=&quot;scss&quot; scoped&gt;
.home {
  overflow: hidden;
}
.same {
  background-color: #fff;
  display: flex;
  padding-left: 10px;
  height: 100px;
  align-items: center;
  font-size: 12px;
}
.four {
  background-color: #fff;
  height: 100px;
  padding: 10px;
  box-sizing: border-box;
  position: relative;
  &gt; p {
    display: flex;
    align-items: center;
    justify-content: center;
    span {
      margin-left: 5px;
    }
  }
  .mes-box {
    position: absolute;
    bottom: 10px;
    left: 10px;
    right: 10px;

    p {
      display: flex;
      justify-content: space-between;
      .info-icon {
        color: #e6a23c;
        font-size: 12px;
      }
      .mes {
        font-size: 12px;
      }

      span:first-child {
        display: flex;
        align-items: center;
        .mes {
          margin-left: 5px;
        }
      }
    }
  }
}
.echart-box {
  margin-top: 5px;
  .echart {
    height: 300px;
  }
  ::v-deep .el-card__header {
    padding: 0;
    .card-header {
      padding: 5px 10px;
      background-color:   #c6e2ff;
      span {
        font-size: 14px;
        border-left: 4px solid #409EFF;
        padding-left: 5px;
      }
    }
  }

}

.breadcrumb {
  margin-bottom: 5px;
  background-color: #fff;
  padding: 10px;
}
&lt;/style&gt;
</code></pre>
<p>备注：上述代码使用了element-ui的el-card和el-row组件。使用echarts绘制图例。</p>
<p>配置对应的vue-router，同时将根路由重定向到/home，同时为了不显示根路由配置，需要隐藏根路由的路由配置，这里给路由配置添加新参数hidden，hidden:true表示隐藏。</p>
<pre><code class="language-js">import {
  createRouter,
  createWebHashHistory
} from 'vue-router'
import HomeView from '../views/HomeView.vue'

let routes = [{
  path: '/',
  redirect: '/home',
  children: [],
  hidden: true
},
{
  path: '/home',
  icon: 'Management',
  name: '审批中心主页',
  component: HomeView,
  children: []
},
{
  path: '/todo',
  icon: 'List',
  name: '流程待处理',
  component: null,
  children: []
}];

const router = createRouter({
  history: createWebHashHistory(),
  routes
})
export default router
</code></pre>
<p>注意：因为路由配置增加了新参数hidden，所以前面3-4-2任务中动态生成的左边导航需要重写，如下：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    ……
    &lt;aside class=&quot;nav&quot;&gt;
      &lt;!-- 添加代码 --&gt;
      &lt;el-menu :default-openeds=&quot;['/']&quot; :default-active=&quot;$route.path&quot; router class=&quot;el-menu-vertical-demo&quot;
        :collapse=&quot;isCollapse&quot;&gt;
        &lt;template v-for=&quot;item in $router.options.routes&quot;&gt;
          &lt;el-sub-menu :index=&quot;item.path&quot; :key=&quot;item.name&quot;
            v-if=&quot;!item.hidden &amp;&amp; item.children &amp;&amp; item.children.length &gt; 0&quot;&gt;
            &lt;template slot=&quot;title&quot;&gt;
              &lt;i :class=&quot;[item.icon]&quot;&gt;&lt;/i&gt;
              &lt;span&gt;{{ item.name }}&lt;/span&gt;
            &lt;/template&gt;
            &lt;template v-for=&quot;child in item.children&quot;&gt;
              &lt;el-menu-item :index=&quot;child.path&quot; :key=&quot;child.name&quot; v-if=&quot;!child.isPermisson&quot;&gt;
                {{ child.name }}&lt;/el-menu-item&gt;
            &lt;/template&gt;
          &lt;/el-sub-menu&gt;
          &lt;el-menu-item :index=&quot;item.path&quot; :key=&quot;item.name&quot; v-else-if=&quot;!item.hidden &amp;&amp; !item.isPermisson&quot;&gt;
            &lt;i :class=&quot;[item.icon]&quot;&gt;&lt;/i&gt;
            &lt;template slot=&quot;title&quot;&gt;{{ item.name }}&lt;/template&gt;
          &lt;/el-menu-item&gt;
        &lt;/template&gt;
      &lt;/el-menu&gt;
    &lt;/aside&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>预览</p>
<figure data-type="image" tabindex="72"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/EwLsoEW3v2bEiVTqaRPG1yVElvsJ4JYSCblHt5uj.png" alt="image.png" loading="lazy"></figure>
<h3 id="3-7-课后练习">3-7 课后练习</h3>
<p>练习使用动态路由：<a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html">带参数的动态路由匹配 | Vue Router</a>。</p>
<h2 id="4-开发一体化审核平台流程待处理">4. 开发一体化审核平台流程待处理</h2>
<h3 id="4-1-增加流程待处理菜单路由配置"><strong>4-1 增加流程待处理菜单路由配置</strong></h3>
<p>效果图中的流程待处理菜单一共有5个页面。在src目录下views文件夹下创建ToDo.vue、HandleTask.vue、FlowView.vue、SeeLog.vue、LogDetail.vue文件，分别作为流程待处理、处理任务、流程视图、查看日志和日志详情页面文件，同时修改vue-router配置，添加相应配置。同时隐藏处理任务、流程视图、查看日志和日志详情页面。</p>
<pre><code class="language-js">import Vue from 'vue'
import VueRouter from 'vue-router'

import HomeView from '../views/HomeView.vue'
import ToDo from '../views/ToDo.vue'
import Error from '../views/Error.vue'
import LogDetail from '../views/LogDetail.vue'
import FlowView from '../views/FlowView.vue'
import HandleTask from '../views/HandleTask.vue'
import SeeLog from '../views/SeeLog.vue'

Vue.use(VueRouter)

let routes = [{
  path: '/',
  redirect: '/home',
  children: [],
  hidden: true
},
{
  path: '/home',
  icon: 'Management',
  name: '审批中心主页',
  component: HomeView,
  children: []
},
{
  path: '/todo',
  icon: 'List',
  name: '流程待处理',
  component: ToDo,
  children: []
},{
  path: '/handletask',
  icon: 'List',
  name: '处理任务',
  component: HandleTask,
  hidden: true,
  children: []
},{
  path: '/flowview',
  icon: 'List',
  name: '流程视图',
  component: FlowView,
  children: [],
  hidden: true
},{
  path: '/seelog',
  icon: 'List',
  name: '查看日志',
  component: SeeLog,
  children: [],
  hidden: true

},{
  path: '/logdetail',
  icon: 'List',
  name: '日志详情',
  component: LogDetail,
  children: [],
  hidden: true

}];

const router = new VueRouter({
  mode: 'history',
  routes
})
export default router
</code></pre>
<h3 id="4-2-使用element-ui组件开发页面"><strong>4-2 使用Element-ui组件开发页面</strong></h3>
<h4 id="4-2-1-开发流程待处理页面">4-2-1 开发流程待处理页面</h4>
<p>主要使用element-ui的el-button、el-table和el-Pagination组件，开发后代码：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;search-box&quot;&gt;
      &lt;el-form :inline=&quot;true&quot; :model=&quot;filters&quot; class=&quot;demo-form-inline&quot;&gt;
        &lt;el-form-item label=&quot;客户号&quot;&gt;
          &lt;el-input
            clearable
            v-model=&quot;filters.customerCode&quot;
            placeholder=&quot;客户号&quot;
          /&gt;
        &lt;/el-form-item&gt;
        &lt;el-form-item&gt;
          &lt;el-button
            type=&quot;primary&quot;
            @click=&quot;onSubmit&quot;
            :loading=&quot;loading.btnLoading&quot;
            &gt;搜索&lt;/el-button
          &gt;
        &lt;/el-form-item&gt;
      &lt;/el-form&gt;
    &lt;/div&gt;
    &lt;el-table
      :data=&quot;tableData&quot;
      stripe
      style=&quot;width: 100%&quot;
      v-loading=&quot;loading.listLoading&quot;
    &gt;
      &lt;el-table-column type=&quot;index&quot; width=&quot;50&quot; label=&quot;序号&quot; /&gt;

      &lt;el-table-column prop=&quot;projectCode&quot; label=&quot;项目编号&quot; width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;customerCode&quot; label=&quot;客户号&quot; width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;customer&quot; label=&quot;客户名称&quot; width=&quot;120&quot; /&gt;
      &lt;el-table-column
        prop=&quot;flowtemplateType&quot;
        label=&quot;流程模板类型&quot;
        width=&quot;120&quot;
      /&gt;
      &lt;el-table-column prop=&quot;projectName&quot; label=&quot;项目名称&quot; width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;flowType&quot; label=&quot;流程类型&quot; min-width=&quot;120&quot; /&gt;

      &lt;el-table-column fixed=&quot;right&quot; label=&quot;操作&quot; width=&quot;360&quot;&gt;
        &lt;template  slot-scope=&quot;{row}&quot;&gt;
          &lt;el-button link type=&quot;primary&quot; @click=&quot;gotoHandleTask&quot; size=&quot;small&quot;&gt;
            处理任务
          &lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot; @click=&quot;gotoFlowView&quot; size=&quot;small&quot;&gt;
            流程视图
          &lt;/el-button&gt;
          &lt;el-button link type=&quot;primary&quot; @click=&quot;gotoSeeLog&quot; size=&quot;small&quot;&gt;
            查看日志
          &lt;/el-button&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
    &lt;el-pagination
      layout=&quot;total, sizes, prev, pager, next, jumper&quot;
      :currentPage=&quot;page&quot;
      :page-size=&quot;pageSize&quot;
      @current-change=&quot;handleCurrentChange&quot;
      @size-change=&quot;sizeChange&quot;
      :page-sizes=&quot;[10, 20, 40, 50]&quot;
      :total=&quot;total&quot;
      class=&quot;pagination&quot;
    &gt;
    &lt;/el-pagination&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;

import api from &quot;./api/&quot;;

export default {
  data() {
    return {
      total: 0,
      page: 1,
      pageSize: 10,
      loading: {
        listLoading: false,
        btnLoading: false,
      },
      tableData: [
        {
          projectCode: &quot;2016-05-03&quot;,
          customerCode: &quot;Tom&quot;,
          customer: &quot;No. 189, Grove St, Los Angeles&quot;,
          flowtemplateType: &quot;&quot;,
          projectName: &quot;&quot;,
          flowType: &quot;&quot;,
        },
      ],
      filters: {
        customerCode: ''
      },
    };
  },
  methods: {
    handleCurrentChange(){
      this.getTodoListData()
    },
    sizeChange(){
      this.getTodoListData()
    },
    onSubmit(){
      this.loading.btnLoading = true;
      this.page = 1;
      this.pageSize = 10;
      this.getTodoListData();
    },
    gotoHandleTask(){
      this.$router.push(&quot;/handletask&quot;);
    },
    gotoFlowView(){
      this.$router.push(&quot;/seelog&quot;);
    },
    gotoSeeLog(){
      this.$router.push(&quot;/seelog&quot;);
    },
    getTodoListData(){
      let para = {
        page: this.page,
        code: this.filters.customerCode,
        pageSize: this.pageSize,
      };
      this.loading.listLoading = true;

      api
        .getTodoListPage(para)
        .then((res) =&gt; {
          this.tableData = res.projects;
          this.total = res.total;
        })
        .finally(() =&gt; {
          this.loading.btnLoading = false;
          this.loading.listLoading = false;
        });
    }
  },
  mounted(){
    this.getTodoListData()
  }
};
&lt;/script&gt;
&lt;style lang=&quot;scss&quot; scoped&gt;
.container {
  background: #fff;
  overflow: hidden;
  padding: 10px;
  .pagination {
    clear: both;
    margin-top: 10px;
    padding-bottom: 10px;
    float: right;
  }
}
&lt;/style&gt;
</code></pre>
<p>对应api文件接口：</p>
<pre><code class="language-js">import { ajaxGetData, ajaxPostData, ajaxPostJson, ajaxPutJson, ajaxDeleteJson } from '@/config/ajax'
const api = {
  getTodoListPage (params) {
    return ajaxGetData({ url: `/todo/listpage`, params: params })
  }
}
export default api
</code></pre>
<p>对应mock查询接口为：</p>
<pre><code class="language-js">import axios from 'axios';
import MockAdapter from 'axios-mock-adapter';
import { Projects  } from './project';
let _Project = Projects
export default {
  /**
   * mock bootstrap
   */
  bootstrap() {
    let mock = new MockAdapter(axios);

    //获取项目列表（分页）
    mock.onGet('/todo/listpage').reply(config =&gt; {
      let {page, code, pageSize} = config.params;
      let mockProjects = _Project.filter(project =&gt; {
        if (code &amp;&amp; project.projectName.indexOf(code) == -1) return false;
        return true;
      });
      let total = mockProjects.length;
      mockProjects = mockProjects.filter((u, index) =&gt; index &lt; pageSize * page &amp;&amp; index &gt;= pageSize * (page - 1));
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          resolve([200, {
            code: 200,
            total: total,
            projects: mockProjects
          }]);
        }, 500);
      });
    });

  }
};
</code></pre>
<p>备注：./project文件数据可以查看项目后的参考代码</p>
<p>预览效果如下:</p>
<figure data-type="image" tabindex="73"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/0vpF0r9nS18NFCfhUQDrr1zvt2rSnxpFzjCRJmDX.png" alt="image.png" loading="lazy"></figure>
<h4 id="4-2-2-开发处理任务页面">4-2-2 开发处理任务页面</h4>
<p>主要使用element-ui的el-tabs、el-button组件，开发后代码：</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;tab-box&quot;&gt;
      &lt;el-tabs v-model=&quot;activeName&quot; class=&quot;tabs&quot;&gt;
        &lt;el-tab-pane label=&quot;客户信息&quot; name=&quot;first&quot;&gt;
          &lt;el-button type=&quot;primary&quot;&gt;单一客户基本信息&lt;/el-button&gt;
          &lt;div class=&quot;table-box&quot;&gt;
            &lt;h4&gt;单一客户信息&lt;/h4&gt;
            &lt;table&gt;
              &lt;tr&gt;
                &lt;td&gt;客户信息&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;子系统绑定ID&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
              &lt;/tr&gt;
              &lt;tr&gt;
                &lt;td&gt;客户类型&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;客户子系统&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
              &lt;/tr&gt;
              &lt;tr&gt;
                &lt;td&gt;证件类型&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;证件号码&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
              &lt;/tr&gt;
              &lt;tr&gt;
                &lt;td&gt;行业分类&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
                &lt;td&gt;客户状态&lt;/td&gt;
                &lt;td&gt;&lt;/td&gt;
              &lt;/tr&gt;
            &lt;/table&gt;
          &lt;/div&gt;
        &lt;/el-tab-pane&gt;
      &lt;/el-tabs&gt;
      &lt;div class=&quot;back-box&quot;&gt;
        &lt;i class=&quot;el-icon-arrow-left&quot;&gt;&lt;/i&gt;
        &lt;el-button @click=&quot;backPage&quot; type=&quot;text&quot;&gt;返回&lt;/el-button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      activeName: &quot;first&quot;,
    };
  },
  methods: {
    backPage() {
      this.$router.back();
    },
  },
};
&lt;/script&gt;
&lt;style lang=&quot;scss&quot; scoped&gt;
.container {
  padding: 10px;
  padding-top: 0;
  background-color: #fff;
  .table-box {
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      td {
        border: 1px solid #d4d7de;
        width: 25%;
        height: 24px;
        vertical-align: middle;
        text-align: right;
        padding-right: 5px;
        font-size: 12px;
      }
      td:nth-child(2n + 1) {
        background: #e4e7ed;
      }
    }
    h4 {
      font-size: 13px;
      border-left: 4px solid #409eff;
      padding-left: 5px;
      margin-top: 10px;
    }
  }
  .tab-box {
    display: flex;
    .back-box {
      width: 100px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      .el-button {
        padding-left: 0;
      }
    }
    .tabs {
      flex: 1;
    }
  }
}
&lt;/style&gt;
</code></pre>
<p>备注：主要使用了table布局</p>
<p>预览效果如下:</p>
<figure data-type="image" tabindex="74"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/oLuSy7uY1XXoZPh0GlB5SJQPTUoaswzSkPb3kav4.png" alt="image.png" loading="lazy"></figure>
<h4 id="4-2-3-开发流程视图页面">4-2-3 开发流程视图页面</h4>
<p>主要使用element-ui的el-tabs和table原生组件，开发后代码：</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;tab-box&quot;&gt;
      &lt;div class=&quot;name&quot;&gt;工作流程&lt;/div&gt;
      &lt;div class=&quot;back-box&quot;&gt;
        &lt;i class=&quot;el-icon-arrow-left&quot;&gt;&lt;/i&gt;
        &lt;el-button @click=&quot;backPage&quot; type=&quot;text&quot;&gt;返回&lt;/el-button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;th&gt;阶段&lt;/th&gt;
        &lt;th&gt;职能&lt;/th&gt;
        &lt;th&gt;操作人&lt;/th&gt;
        &lt;th&gt;职位&lt;/th&gt;
        &lt;th&gt;机构&lt;/th&gt;
        &lt;th&gt;完成时间&lt;/th&gt;
        &lt;th&gt;停留时间（天）&lt;/th&gt;
        &lt;th&gt;联系方式&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td rowspan=&quot;3&quot;&gt;发起&lt;/td&gt;
        &lt;td&gt;客户经理&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td width=&quot;10%&quot;&gt;
          中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行
        &lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td width=&quot;8%&quot;&gt;&lt;el-button type=&quot;text&quot;&gt;发送短信&lt;/el-button&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;公司秘书&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;
          中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行
        &lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;el-button type=&quot;text&quot;&gt;发送短信&lt;/el-button&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;业务审核人&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;
          中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行
        &lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;el-button type=&quot;text&quot;&gt;发送短信&lt;/el-button&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;秘书&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;
          中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行中国人民银行
        &lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td width=&quot;8%&quot;&gt;
          &lt;el-button type=&quot;text&quot;&gt;发送短信&lt;/el-button&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;尽责&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;投票&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;审批&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;批复&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;结束&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
        &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
    &lt;div class=&quot;btn-box&quot;&gt;
      &lt;el-button type=&quot;primary&quot;&gt;查看人员历史&lt;/el-button&gt;
      &lt;el-button type=&quot;primary&quot;&gt;查询系统建设授权结果&lt;/el-button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
  &lt;script&gt;
export default {
  data() {
    return {
      activeName: &quot;first&quot;,
    };
  },
  methods: {
    backPage() {
      this.$router.back();
    },
  },
};
&lt;/script&gt;
  &lt;style lang=&quot;scss&quot; scoped&gt;
.container {
  padding: 10px;
  padding-top: 0;
  background-color: #fff;
  .btn-box {
    text-align: center;
    margin-top: 10px;
  }
  table {
    width: 100%;
    border: 1px solid #909399;
    td {
      border: 1px solid #909399;
      border-collapse: collapse;
      text-align: center;
      font-size: 12px;
    }
    th {
      background-color: #e6e8eb;
      font-size: 12px;
      height: 30px;
    }
  }
  .tab-box {
    display: flex;
    align-items: center;
    justify-content: space-between;
    .name {
      font-size: 13px;
      border-left: 4px solid #409eff;
      padding-left: 5px;
    }
    .back-box {
      width: 100px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      .el-button {
        padding-left: 0;
      }
    }
    .tabs {
      flex: 1;
    }
  }
}
&lt;/style&gt;
</code></pre>
<p>备注：主要使用table布局</p>
<p>预览效果如下:</p>
<figure data-type="image" tabindex="75"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/Xul25YpLhqYSbsYMS51rmXGoW5UUw8aueIEDUE0M.png" alt="image.png" loading="lazy"></figure>
<h4 id="4-2-4-开发日志信息页面">4-2-4 开发日志信息页面</h4>
<p>主要使用element-ui的el-table和el-button组件，开发后代码：</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;tab-box&quot;&gt;
      &lt;div&gt;日志信息总条数：{{ total }}&lt;/div&gt;
      &lt;div class=&quot;back-box&quot;&gt;
        &lt;i class=&quot;el-icon-arrow-left&quot;&gt;&lt;/i&gt;
        &lt;el-button @click=&quot;backPage&quot; type=&quot;text&quot;&gt;返回&lt;/el-button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;el-table :data=&quot;tableData&quot; stripe style=&quot;width: 100%&quot; v-loading=&quot;loading.listLoading&quot;&gt;
      &lt;el-table-column type=&quot;index&quot; width=&quot;50&quot; label=&quot;序号&quot; /&gt;

      &lt;el-table-column prop=&quot;projectCode&quot; label=&quot;项目编号&quot; width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;handler&quot; label=&quot;处理人&quot; width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;handlerBank&quot; label=&quot;处理人所在银行&quot; width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;handlerOrgan&quot; label=&quot;处理人所在机构&quot; width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;handlerDepart&quot; label=&quot;处理人所在部门&quot; min-width=&quot;120&quot; /&gt;

      &lt;el-table-column prop=&quot;handletime&quot; label=&quot;开始处理时间&quot; width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;handleFinishtime&quot; label=&quot;处理完成时间&quot; min-width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;sector&quot; label=&quot;环节&quot; min-width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;handleRes&quot; label=&quot;处理结论&quot; min-width=&quot;120&quot; /&gt;
      &lt;el-table-column prop=&quot;sectorRes&quot; label=&quot;环节处理标识&quot; min-width=&quot;120&quot; /&gt;

      &lt;el-table-column fixed=&quot;right&quot; label=&quot;操作&quot; width=&quot;240&quot;&gt;
        &lt;template slot-scope=&quot;{ row }&quot;&gt;
          &lt;el-button link type=&quot;primary&quot; @click=&quot;gotoLogDetail(row)&quot; size=&quot;small&quot;&gt;
            查看详情
          &lt;/el-button&gt;
        &lt;/template&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
    &lt;el-pagination layout=&quot;total, sizes, prev, pager, next, jumper&quot; :currentPage=&quot;page&quot; :page-size=&quot;pageSize&quot;
      @current-change=&quot;handleCurrentChange&quot; @size-change=&quot;sizeChange&quot; :page-sizes=&quot;[10, 20, 40, 50]&quot; :total=&quot;total&quot;
      class=&quot;pagination&quot;&gt;
    &lt;/el-pagination&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import api from &quot;./api/&quot;;

export default {
  data() {
    return {
      total: 0,
      pageSize: 10,
      page: 1,
      loading: {
        listLoading: false,
      },
      tableData: [
        {
          projectCode: &quot;2016-05-03&quot;,
          handler: &quot;Tom&quot;,
          handlerBank: &quot;No. 189, Grove St, Los Angeles&quot;,
          handlerOrgan: &quot;&quot;,
          handlerDepart: &quot;&quot;,
          handletime: &quot;&quot;,
          handleFinishtime: &quot;&quot;,
          sector: &quot;&quot;,
          handleRes: &quot;&quot;,
          sectorRes: &quot;&quot;,
        },
      ],
    };
  },
  methods: {
    sizeChange() {
      this.getLogListPage();
    },
    handleCurrentChange() {
      this.getLogListPage();
    },
    gotoLogDetail(row) {
      this.$router.push({
        path: &quot;/logdetail&quot;,
        query: {
          id: row.projectCode,
        },
      });
    },
    backPage() {
      this.$router.back();
    },
    getLogListPage() {
      let para = {
        page: this.page,
        pageSize: this.pageSize,
      };
      this.loading.listLoading = true;

      api
        .getLogListPage(para)
        .then((res) =&gt; {
          this.tableData = res.logs;
          this.total = res.total;
        })
        .finally(() =&gt; {
          this.loading.listLoading = false;
        });
    },
  },
  mounted() {
    this.getLogListPage();
  },
};
&lt;/script&gt;
&lt;style lang=&quot;scss&quot; scoped&gt;
.container {
  background: #fff;
  overflow: hidden;
  padding: 10px;

  .tab-box {
    display: flex;
    justify-content: space-between;

    .back-box {
      width: 100px;
      display: flex;
      justify-content: center;
      align-items: center;

      .el-button {
        padding-left: 0;
      }
    }

    .tabs {
      flex: 1;
    }
  }

  .pagination {
    clear: both;
    margin-top: 10px;
    padding-bottom: 10px;
    float: right;
  }
}
&lt;/style&gt;
</code></pre>
<p>对应api接口：</p>
<pre><code>import { ajaxGetData, ajaxPostData, ajaxPostJson, ajaxPutJson, ajaxDeleteJson } from '@/config/ajax'
const api = {
  getLogListPage (params) {
    return ajaxGetData({ url: `/log/listpage`, params: params })
  }
}
export default api
</code></pre>
<p>对应mock查询接口为：</p>
<pre><code>//获取用户列表（分页）
    mock.onGet('/log/listpage').reply(config =&gt; {
      let {page, pageSize} = config.params;
      let mockLogs = _Logs.filter(user =&gt; {
        return true;
      });
      let total = mockLogs.length;
      mockLogs = mockLogs.filter((u, index) =&gt; index &lt; pageSize * page &amp;&amp; index &gt;= pageSize * (page - 1));
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          resolve([200, {
            code: 200,
            total: total,
            logs: mockLogs
          }]);
        }, 500);
      });
    });
</code></pre>
<p>预览效果如下:</p>
<figure data-type="image" tabindex="76"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/Wel48Geo7PtsIMDF3Dc0Y1oEF01FnfkprdTZH4vr.png" alt="image.png" loading="lazy"></figure>
<h4 id="4-2-5-开发日志详情页面">4-2-5 开发日志详情页面</h4>
<p>主要使用element-ui的el-row和el-form组件，开发后代码：</p>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;tab-box&quot;&gt;
      &lt;div&gt;日志信息详情&lt;/div&gt;
      &lt;div class=&quot;back-box&quot;&gt;
        &lt;i class=&quot;el-icon-arrow-left&quot;&gt;&lt;/i&gt;
        &lt;el-button @click=&quot;backPage&quot; type=&quot;text&quot;&gt;返回&lt;/el-button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;el-form label-position=&quot;left&quot; v-loading=&quot;loading&quot; disabled label-width=&quot;100px&quot; :model=&quot;ruleForm&quot;&gt;
      &lt;el-row :gutter=&quot;24&quot;&gt;
        &lt;el-col :span=&quot;6&quot;&gt;&lt;/el-col&gt;
        &lt;el-col :span=&quot;6&quot;&gt;
          &lt;el-form-item label=&quot;项目编号&quot;&gt;
            &lt;el-input v-model=&quot;ruleForm.projectCode&quot; /&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;处理人&quot;&gt;
            &lt;el-input v-model=&quot;ruleForm.handler&quot; /&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;处理人所在机构&quot;&gt;
            &lt;el-input v-model=&quot;ruleForm.handlerOrgan&quot; /&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;开始处理时间&quot;&gt;
            &lt;el-input v-model=&quot;ruleForm.handletime&quot; /&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;环节完成标识&quot;&gt;
            &lt;el-input v-model=&quot;ruleForm.sectorRes&quot; /&gt;
          &lt;/el-form-item&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;6&quot;&gt;
          &lt;el-form-item label=&quot;环节&quot;&gt;
            &lt;el-input v-model=&quot;ruleForm.sector&quot; /&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;处理人所在银行&quot;&gt;
            &lt;el-input v-model=&quot;ruleForm.handlerBank&quot; /&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;处理人所在部门&quot;&gt;
            &lt;el-input v-model=&quot;ruleForm.handlerDepart&quot; /&gt;
          &lt;/el-form-item&gt;
          &lt;el-form-item label=&quot;处理完成时间&quot;&gt;
            &lt;el-input v-model=&quot;ruleForm.handleFinishtime&quot; /&gt;
          &lt;/el-form-item&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;6&quot;&gt;&lt;/el-col&gt;
      &lt;/el-row&gt;
    &lt;/el-form&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import api from &quot;./api/&quot;;

export default {
  components: {},
  data() {
    return {
      loading: false,
      ruleForm: {
        projectCode: &quot;&quot;,
        handler: &quot;&quot;,
        handlerBank: &quot;&quot;,
        handlerOrgan: &quot;&quot;,
        handlerDepart: &quot;&quot;,
        handletime: &quot;&quot;,
        handleFinishtime: &quot;&quot;,
        sector: &quot;&quot;,
        handleRes: &quot;&quot;,
        sectorRes: &quot;&quot;,
      },
    };
  },
  methods: {
    backPage() {
      this.$router.back();
    },
    getLogDetail() {
      let para = {
        projectCode: this.route.query.id || &quot;&quot;,
      };
      this.loading = true;
      api
        .getLogDetail(para)
        .then((res) =&gt; {
          this.ruleForm = res.log;
        })
        .finally(() =&gt; {
          this.loading = false;
        });
    },
  },
  mounted() {
    this.getLogDetail();
  },
};
&lt;/script&gt;
&lt;style lang=&quot;scss&quot; scoped&gt;
.container {
  padding: 10px;
  padding-top: 0;
  background-color: #fff;
  overflow: hidden;

  .tab-box {
    display: flex;
    align-items: center;
    justify-content: space-between;

    .back-box {
      width: 100px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;

      .el-button {
        padding-left: 0;
      }
    }

    .tabs {
      flex: 1;
    }
  }
}
&lt;/style&gt;
</code></pre>
<p>对应api接口：</p>
<pre><code>import { ajaxGetData, ajaxPostData, ajaxPostJson, ajaxPutJson, ajaxDeleteJson } from '@/config/ajax'
const api = {
  getLogDetail (params) {
    return ajaxGetData({ url: `/log/detail`, params: params })
  }
}
export default api
</code></pre>
<p>对应mock查询接口为：</p>
<pre><code>//获取日志详情
    mock.onGet('/log/detail').reply(config =&gt; {
      let {projectCode} = config.params;
      let mockLog = _Logs.find(user =&gt; {
        return user.projectCode === projectCode
      });

      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          resolve([200, {
            log: mockLog,
            code: 200
          }]);
        }, 500);
      });
    });
</code></pre>
<p>预览效果如下：</p>
<figure data-type="image" tabindex="77"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/ZaP4gQaWqLHXvIA9C4iaebfR8KwiCUkWs9gady46.png" alt="image.png" loading="lazy"></figure>
<h2 id="5-优化一体化审核平台">5. 优化一体化审核平台</h2>
<h3 id="5-1-引入不同开发环境下环境配置">5-1 引入不同开发环境下环境配置</h3>
<p>不同开发环境下后端服务地址是不一致的，为此我们可以使用vue-cli提供的不同环境下配置不同环境变量，标记常量在不同环境下配置不同的后端服务地址。详情：<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html">模式和环境变量 | Vue CLI</a>。</p>
<figure data-type="image" tabindex="78"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/RzjCrSrSwBF509CpC8Ux03FhNWyVNwzZHUWQWMLD.png" alt="效果图" loading="lazy"></figure>
<p>同时修改package.js文件</p>
<pre><code>&quot;scripts&quot;: {
    &quot;serve&quot;: &quot;vue-cli-service serve --mode development&quot;,
    &quot;build&quot;: &quot;vue-cli-service build&quot;,
    &quot;build:prod&quot;: &quot;vue-cli-service build --mode production&quot;,
    &quot;build:test&quot;: &quot;vue-cli-service build --mode test&quot;,
    &quot;lint&quot;: &quot;vue-cli-service lint&quot;
  },
</code></pre>
<p>备注：serve是本地开发环境，build:prod是生产环境，build:test是测试环境。</p>
<h3 id="5-2-利用vueconfigjs优化项目">5-2 利用vue.config.js优化项目</h3>
<p>添加Gzip压缩，减小文件大小。这样同等网络条件下可以加快拉取服务端资源，进而加快渲染。修改vue.config.js文件。</p>
<pre><code>const { defineConfig } = require('@vue/cli-service')
const CompressionWebpackPlugin = require('compression-webpack-plugin')
const productionGzipExtensions = ['js', 'css']

module.exports = defineConfig({
  lintOnSave: false,
  productionSourceMap: false,
  configureWebpack: {
    plugins: [
      new CompressionWebpackPlugin({
        filename: '[path][base].gz',//[file] 会被替换成原始资源。[path] 会被替换成原始资源的路径， [query] 会被替换成查询字符串
        algorithm: 'gzip',//压缩成gzip
        //所有匹配该正则的资源都会被处理。默认值是全部资源。
        test: new RegExp('\\.(' + productionGzipExtensions.join('|') + ')$'),
        threshold: 10240,//只有大小大于该值的资源会被处理。单位是 bytes。默认值是 0。
        minRatio: 0.8//只有压缩率小于这个值的资源才会被处理。默认值是 0.8。
      })
    ]
  }
})
</code></pre>
<h3 id="5-3-其他优化手段">5-3 其他优化手段</h3>
<h4 id="5-3-1-根据不同的开发环境配置不同的source-map">5-3-1 根据不同的开发环境，配置不同的source-map</h4>
<p>生产环境下关闭source-map，改配置默认是开启的。关于source-map知识点：<a href="https://blog.csdn.net/sinat_22480443/article/details/115396135">Source Map_shea_mong的博客-CSDN博客_source-map</a>。生产环境下关闭source-map，可以减少生产环境代码大小，进而加快首次渲染速度。当然你也可以根据你的需要作出合适的选择：<a href="https://www.webpackjs.com/configuration/devtool/">devtool | webpack 中文网</a>。</p>
<pre><code>// 添加
module.exports = defineConfig({
  productionSourceMap: false,
})
</code></pre>
<h4 id="5-3-2-添加错误页面">5-3-2 添加错误页面</h4>
<p>当访问路径无匹配路由时候，统一跳转到一个错误页面。在views目录下添加Error.vue文件作为错误页面。同时vue-router添加相应路由配置，同时配置hidden为true不在左侧导航显示。</p>
<pre><code>let routes = [
  ...
  {
  path: '*',
  component: Error,
  name: '错误页面',
  hidden: true
}];
</code></pre>
<h3 id="5-4-使用谷歌浏览器衡量项目性能">5-4 使用谷歌浏览器衡量项目性能</h3>
<p>那么我们怎么知道项目的渲染性能呢？比如首屏渲染速度，比如SEO，比如性能等。我们可以采用谷歌浏览器的Lighthouse。</p>
<figure data-type="image" tabindex="79"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/Vhp1IXo1wJXfOw6MJu7pj3OF5dWb8yElksbyXpzw.png" alt="image.png" loading="lazy"></figure>
<p>我们目前项目执行npm run build，之后将编译结果放入服务器中，之后访问。使用Lighthouse测试一下结果：</p>
<figure data-type="image" tabindex="80"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/1116/admin/Lx7UvEV4BZ7GiSsebj6aVxcAB5TriJfUwcT5UFyi.png" alt="image.png" loading="lazy"></figure>
<p>谷歌的Lighthouse提供了一种可以量化的网页性能指标，你可以借助此来判断所做的优化动作起了多大的优化作用。</p>
<h1 id="响应式布局">响应式布局</h1>
<h2 id="1-项目导学">1. 项目导学</h2>
<h3 id="你将获得什么-2">你将获得什么</h3>
<ol>
<li>巩固 vue-cli 创建项目</li>
<li>学习 Element UI 的布局</li>
<li>学习 Element UI form 组件</li>
<li>学习 HTTP 请求类型，掌握 Axios 的基本用法</li>
<li>学习浏览器 Cookie、LocalStorage 的相关知识</li>
<li>学习 Vue Router 的基本用法</li>
<li>学习 Element UI 的 menu、progress、table 基础组件</li>
<li>学习 Vue 组件的生命周期和回调函数</li>
</ol>
<h2 id="2-完成登录页面的前端开发">2. 完成登录页面的前端开发</h2>
<h3 id="1-任务说明">1 - 任务说明</h3>
<p><strong>描述</strong>：使用 Element UI 完成登录页面整个前端的开发。</p>
<p><strong>要求</strong>：进一步学习 Element UI 布局、表单组件，学习 Element UI 组件库 ICON 知识。</p>
<p>登录页面的预览效果：</p>
<figure data-type="image" tabindex="81"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/JrNVrzVTJmeSFCa2WyaHnfrg4MidkmOHXBefQlAX.png" alt="img" loading="lazy"></figure>
<blockquote>
<p>切图素材下载：https://jiker.feishu.cn/file/boxcnkZHJbaEt47wO12QJ74nUYd</p>
</blockquote>
<h3 id="2-任务提示">2 - 任务提示</h3>
<h4 id="21-安装相关依赖包">2.1 - 安装相关依赖包</h4>
<p>在项目根目录打开命令行控制台，执行以下命令：</p>
<pre><code>npm install element-ui axios vue-router@3.2.0 json-server  --save
</code></pre>
<p>上述命令使用 npm 安装了 Element-ui、Axios 3.2.0 版本的 vue-router 和 json-server，然后修改 src 目录下的 main.js 文件如下：</p>
<pre><code>import Vue from 'vue'
import VueRouter from 'vue-router'
import axios from 'axios'
import ElementUI from 'element-ui'
import App from './App'
import 'element-ui/lib/theme-chalk/index.css'

Vue.use(VueRouter)
Vue.use(ElementUI)
Vue.config.productionTip = false
Vue.prototype.$http = axios

new Vue({
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
<p>上述代码利用 Vue 的插件机制，安装 vue-router 和 element-ui，同时将 axios 赋值给 Vue 的原型属性<code>$http</code>上，这样我们就可以直接 <code>this.$http</code> 访问到 axios。</p>
<h4 id="22-创建-login-页面添加-login-页面的路由配置">2.2 - 创建 Login 页面添加 Login 页面的路由配置</h4>
<p>在项目 src 文件夹下的 components 的文件夹下，创建 Login.vue 文件作为登录页面，完成类似伪代码，这样就添加了 Login 页面。</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;login&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &quot;Login&quot;,
};
&lt;/script&gt;
&lt;style lang=&quot;scss&quot; scoped&gt;
&lt;/style&gt;
</code></pre>
<p>然后打开 main.js 文件，创建一个数组：<strong>路径和组件映射的数组</strong>，同时为了更好的体验，默认访问路径重定向到 login 页面，然后创建 vueRouter 对象实例。如下所示：</p>
<pre><code>import Vue from 'vue'
import VueRouter from 'vue-router'
import axios from 'axios'
import ElementUI from 'element-ui'
import App from './App'
import 'element-ui/lib/theme-chalk/index.css'

import Login from './components/Login'

Vue.use(VueRouter)
Vue.use(ElementUI)
Vue.config.productionTip = false
Vue.prototype.$http = axios
const routes = [
  {
    path: '/',
    redirect: '/login'
  },
  {
    path: '/login',
    component: Login
  },
]


const router = new VueRouter({
  mode: 'hash',
  routes
})
new Vue({
  router,
  render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
<p>这样之后还需要修改 app.vue 文件，目的是使路由配置发挥作用。注意这里去掉了 app.vue 最初的 style。</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;

export default {
  name: 'App',
  components: {
  }
}
&lt;/script&gt;

&lt;style&gt;
&lt;/style&gt;
</code></pre>
<p>完成上述步骤之后，在命令行中退出之前运行的 npm run serve 命令，重新启动 npm run serve 命令，这样做的目的是保证项目能够加载新创建的文件。然后再次访问<a href="http://localhost:8080/login">http://localhost:8080</a>，就能看到 login 页面了。</p>
<blockquote>
<p>注：如果发现命令行控制台报错，如下图所示。这是因为 vue-cli 创建的工程默认开启了 eslint 语法检查，这是检查的结果提示。</p>
</blockquote>
<figure data-type="image" tabindex="82"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/n7Fc0ccLuYQWIFBWMxcpat11fMyBdmFSr8Ki8fKa.png" alt="img" loading="lazy"></figure>
<p>如果想关闭此提示，可以打开根目录的 vue.config.js；之后修改为如下：</p>
<pre><code>const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  lintOnSave:false // 增加代码
})
</code></pre>
<p>此时页面预览如下：</p>
<figure data-type="image" tabindex="83"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/kcjEanPgKkS6MmOBDYKoQ9FQtFkPXym7JfPG9JUW.png" alt="img" loading="lazy"></figure>
<h4 id="23-完成登录页面的前端开发">2.3 - 完成登录页面的前端开发</h4>
<p>具体到我们的登录页面分成上中下三部分，分别是 Header、Main 和 Footer，类似这样：</p>
<figure data-type="image" tabindex="84"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/T6XBHp77BcLRhe1oFemGUvBWQ5vNVn7Up53Q57Up.png" alt="img" loading="lazy"></figure>
<p>在这里我们使用 Element UI 的布局容器进行页面布局，我们会使用下列组件完成页面的基本结构：<code>&lt;el-container&gt;外层容器</code>。当子元素中包含 <code>&lt;el-header&gt;</code> 或 <code>&lt;el-footer&gt;</code> 时，全部子元素会垂直上下排列，否则会水平左右排列。</p>
<ul>
<li><code>&lt;el-header&gt;</code>顶栏容器。</li>
<li><code>&lt;el-main&gt;</code>主要区域容器。</li>
<li><code>&lt;el-footer&gt;</code>底栏容器。</li>
</ul>
<p>添加代码到 Login.vue 文件中的 template 区域：</p>
<pre><code>&lt;template&gt;
  &lt;el-container&gt;
    &lt;el-header&gt;&lt;/el-header&gt;
    &lt;el-main&gt;&lt;/el-main&gt;
    &lt;el-footer&gt;&lt;/el-footer&gt;
  &lt;/el-container&gt;
&lt;/template&gt;
</code></pre>
<p>上述代码就能帮助我们完成上中下三段的页面结构，具体 Container 布局容器，请参考这里，<a href="https://element.eleme.cn/#/zh-CN/component/container">Element - The world’s most popular Vue UI framework</a>。</p>
<p>接下来我们看看 Element UI 的 Layout 布局知识，<code>&lt;el-row&gt;</code>组件表示一行，<code>&lt;el-col&gt;</code>组件表示一列，有点像表格。默认 Element UI 由 24 分栏构成，我们可以给行添加多列，并制定列的宽度。比如：</p>
<pre><code>&lt;el-row&gt;
  &lt;el-col  :span=&quot;8&quot;&gt;&lt;/el-col&gt;
  &lt;el-col  :span=&quot;8&quot;&gt;&lt;/el-col&gt;
  &lt;el-col  :span=&quot;8&quot;&gt;&lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre>
<p>上面的代码是三列，每列 8 分栏。我们还可以制定每一列的偏移量或者对齐方式，具体教程请看这里<a href="https://element.eleme.cn/#/zh-CN/component/layout">Element - The world’s most popular Vue UI framework</a>。</p>
<p>对于上面的 Login 页面：</p>
<ul>
<li>
<p><strong>Header</strong>：我们可以分成两列，比例为 4:20，左边使用了 Element UI 自带的葡萄图标 el-icon-grape（<a href="https://element.eleme.cn/#/zh-CN/component/icon">Element - The world’s most popular Vue UI framework</a>），右边是概览和文档。</p>
</li>
<li>
<p>Main</p>
<p>：我们分成两行。第一行又分成两列，比例是 12:12，左边使用 el-image 组件展示图片，链接：</p>
<p>https://pan.baidu.com/s/13n0e8V606ZXEqR0onTFLvQ</p>
<p>提取码：u6uf。右边一列又分出 4 行，分别是文字“开始与众不同”“账号”“密码”“记住我”“忘记密码”，最后是登录按钮。</p>
<ul>
<li>第二行又分成三列，每一列中又分成三行，分别是 icon、标语和具体文字，icon 分别是 el-icon-magic-stick、el-icon-s-marketing、el-icon-odometer。大家可以给相应的元素加上 margin-top 或者 margin-buttom 来调整垂直位置。</li>
</ul>
</li>
<li>
<p><strong>Footer</strong>：两行，每行一列，可以制定宽度和居中排列。</p>
</li>
</ul>
<p>完成之后大致就是下面的效果，大家可以对部分内容自行发挥，不强求完全按照实例实现。ElementUI 带有默认样式，但依然需要我们手动给 DOM 元素添加 class 并实现相应的 style，完成局部样式调整。</p>
<figure data-type="image" tabindex="85"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/RZ7l6EVuby4vjNba4AN09vlQbgQzairGLIWc944W.png" alt="img" loading="lazy"></figure>
<p>参考代码：</p>
<pre><code>&lt;template&gt;
  &lt;el-container&gt;
    &lt;el-header&gt;
      &lt;el-row&gt;
        &lt;el-col :span=&quot;4&quot;&gt;
          &lt;p class=&quot;nav-left&quot;&gt;
            &lt;i class=&quot;el-icon-grape&quot;&gt;&lt;/i&gt;&lt;span&gt;订单管理系统&lt;/span&gt;
          &lt;/p&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;20&quot;&gt;
          &lt;p class=&quot;nav-right&quot;&gt;&lt;span&gt;概览&lt;/span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/p&gt;
        &lt;/el-col&gt;
      &lt;/el-row&gt;
    &lt;/el-header&gt;
    &lt;el-main&gt;
      &lt;el-row&gt;
        &lt;el-col :span=&quot;12&quot;&gt;
          &lt;img class=&quot;working&quot; src=&quot;../assets/working.png&quot; /&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;12&quot;&gt;
          &lt;div&gt;
            &lt;h2 style=&quot;color: #409eff&quot;&gt;开始与众不同&lt;/h2&gt;
            &lt;el-form label-width=&quot;&quot; label-position=&quot;left&quot;&gt;
              &lt;el-form-item label=&quot;&quot; class=&quot;password-item&quot;&gt;
                &lt;el-input
                  prefix-icon=&quot;el-icon-user-solid&quot;
                  placeholder=&quot;账号&quot;
                  size=&quot;mini&quot;
                &gt;&lt;/el-input&gt;
              &lt;/el-form-item&gt;
              &lt;el-form-item label=&quot;&quot; class=&quot;password-item&quot;&gt;
                &lt;el-input
                  prefix-icon=&quot;el-icon-lock&quot;
                  placeholder=&quot;密码&quot;
                  show-password
                  size=&quot;mini&quot;
                &gt;&lt;/el-input&gt;
              &lt;/el-form-item&gt;
              &lt;p class=&quot;handle-password&quot;&gt;
                &lt;el-checkbox&gt;
                  &lt;span style=&quot;font-size: 12px; color: #409eff&quot;&gt;记住我&lt;/span&gt;
                &lt;/el-checkbox&gt;
                &lt;el-link href=&quot;/&quot; target=&quot;_blank&quot; type=&quot;primary&quot;&gt;
                &lt;span style=&quot;font-size: 12px;&quot;&gt;忘记密码&lt;/span&gt;&lt;/el-link&gt;
              &lt;/p&gt;
              &lt;p&gt;
                &lt;el-button size=&quot;mini&quot; type=&quot;primary&quot;&gt;登录&lt;/el-button&gt;
              &lt;/p&gt;
            &lt;/el-form&gt;
          &lt;/div&gt;
        &lt;/el-col&gt;
      &lt;/el-row&gt;
      &lt;el-row :gutter=&quot;20&quot; style=&quot;margin-top: 40px&quot;&gt;
        &lt;el-col :span=&quot;8&quot;&gt;
          &lt;div class=&quot;main-intro&quot;&gt;
            &lt;i class=&quot;el-icon-magic-stick el-icon&quot;&gt;&lt;/i&gt;
            &lt;h2 class=&quot;magic-stick&quot;&gt;美观而强大&lt;/h2&gt;
            &lt;p&gt;
              你会发现管理订单从未如此简单，
              无需任何基础立即上手，风格简约不简单，
              多终端自适应，响应快如闪电。
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;8&quot;&gt;
          &lt;div class=&quot;main-intro&quot;&gt;
            &lt;i class=&quot;el-icon-s-marketing el-icon&quot;&gt;&lt;/i&gt;
            &lt;h2 class=&quot;s-marketing&quot;&gt;体验超出预期&lt;/h2&gt;
            &lt;p&gt;
              一种全新的连接用户与服务的方式，能够在微信内便捷的获取、传播，同时具有出众的使用体验。
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;8&quot;&gt;
          &lt;div class=&quot;main-intro&quot;&gt;
            &lt;i class=&quot;el-icon-odometer el-icon&quot;&gt;&lt;/i&gt;
            &lt;h2 class=&quot;odometer&quot;&gt;轻松完成工作&lt;/h2&gt;
            &lt;p&gt;
              绑定支付宝或微信，即可开始线上销售。无论您是单个商品还是上百个商品。都可以轻松实现线上交易。
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/el-col&gt;
      &lt;/el-row&gt;
    &lt;/el-main&gt;
    &lt;el-footer&gt;
      &lt;el-row&gt;
        &lt;el-col&gt;
          &lt;div class=&quot;footer-box&quot;&gt;
            &lt;p&gt;Designed by 前端项目组&lt;/p&gt;
            &lt;p&gt;CopyRight ©2020. All Rights Reserved.&lt;/p&gt;
          &lt;/div&gt;
        &lt;/el-col&gt;
      &lt;/el-row&gt;
    &lt;/el-footer&gt;
  &lt;/el-container&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &quot;Login&quot;,
};
&lt;/script&gt;
&lt;style  scoped&gt;
p {
  padding: 0;
  margin: 0;
}
.nav-left,
.nav-right {
  height: 36px;
  display: flex;
  align-items: center;
}
.nav-left i {
  font-size: 30px;
  color: #409eff;
}
.nav-left span {
  font-size: 16px;
  color: #409eff;
}
.nav-right {
  justify-content: flex-end;
}
.nav-right span + span {
  margin-left: 20px;
}
.working {
  width: 400px;
}
.password-item {
  margin-bottom: 0;
}
.handle-password {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
}
.footer-box {
  text-align: center;
  background-color: #f9fafc;
  font-size: 12px;
}
.el-icon {
  font-size: 30px;
}
.main-intro .el-icon-magic-stick,
h2.magic-stick {
  color: #409eff;
}
.main-intro .el-icon-s-marketing,
h2.s-marketing {
  color: #e6a23c;
}
.main-intro .el-icon-odometer,
h2.odometer {
  color: #67c23a;
}
&lt;/style&gt;
</code></pre>
<h4 id="24-添加-404-页面和路由配置">2.4 - 添加 404 页面和路由配置</h4>
<p>如果用户把 localhost:8080/login 输入成 localhost:8080/<strong>lgoni</strong> 怎么办？我们的路由里面没有配置这个 URL，页面就不知道跳转到哪里了。因此，我们需要再添加一个 404 页面，匹配非正常 URL。</p>
<p>在 src 文件夹下面创建 NotFound.vue，里面写上“404”或者错误页面之类的文字，然后在 main.js 中，在变量 routes 的最后面加上下面的配置，这样当路由从上到下都没有匹配成功的路由时，会自动加载 NotFound 页面。</p>
<pre><code>{
  path: '*',
  name: 'NotFound',
  component: NotFound
}
</code></pre>
<p>NotFound.vue代码：</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;这是404页面&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>同学们可以自己针对性的做优化。</p>
<h3 id="3-课后练习">3 - 课后练习</h3>
<p>进一步优化 404 页面，添加返回首页按钮。</p>
<p>参考代码：</p>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;h4&gt;这是404页面&lt;/h4&gt;
        &lt;el-button @click=&quot;$router.back()&quot; type='primary'&gt;返回上一页&lt;/el-button&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h2 id="3-完成登陆页面的登陆表单">3. 完成登陆页面的登陆表单</h2>
<h3 id="1-任务说明-2">1 - 任务说明</h3>
<p><strong>描述</strong>：完成登录页面的登录表单部分的组件数据绑定和登录前的数据校验。</p>
<p><strong>要求</strong>：学习 Element-UI 组件的数据绑定，以及学会利用<code>$message</code>组件提示验证结果。</p>
<h3 id="2-任务提示-2">2 - 任务提示</h3>
<h4 id="21-给组件绑定数据">2.1 - 给组件绑定数据</h4>
<p>（1）Element UI input 组件</p>
<p>Element UI input 组件就是输入框，<code>&lt;el-input&gt;</code>给我们提供了非常多的功能和形式来完成各种需求，比如文本框、密码框、带图标的文本框等。</p>
<p>在登录页面中，我们使用了下列 input 组件：</p>
<pre><code>&lt;el-form-item label=&quot;&quot; class=&quot;password-item&quot;&gt;
    &lt;el-input
        prefix-icon=&quot;el-icon-user-solid&quot;
        placeholder=&quot;账号&quot;
        size=&quot;mini&quot;&gt;
    &lt;/el-input&gt;
&lt;/el-form-item&gt;
&lt;el-form-item label=&quot;&quot; class=&quot;password-item&quot;&gt;
    &lt;el-input
    prefix-icon=&quot;el-icon-lock&quot;
    placeholder=&quot;密码&quot;
    show-password
    size=&quot;mini&quot;&gt;
    &lt;/el-input&gt;
&lt;/el-form-item&gt;
</code></pre>
<p>（2）Element UI 的 Checkbox 组件</p>
<p>Checkbox 组件可以完成单选和多选，在这里我们用单选就可以了：</p>
<pre><code>&lt;el-checkbox&gt;
    &lt;span style=&quot;font-size: 12px; color: #409eff&quot;&gt;记住我&lt;/span&gt;
&lt;/el-checkbox&gt;
</code></pre>
<p>（3）Element UI 的 Link 组件</p>
<p>Link 组件表示文字链接，可以配置多种颜色，在这里我们不做实现，所以简单配置即可：</p>
<pre><code>&lt;el-link href=&quot;/&quot; target=&quot;_blank&quot; type=&quot;primary&quot;&gt;&lt;span style=&quot;font-size: 12px;&quot;&gt;忘记密码&lt;/span&gt;&lt;/el-link&gt;
</code></pre>
<p>（4）Element UI 的 button 组件</p>
<p>button 组件表示按钮，可以用 round 属性添加圆角矩形的样式：</p>
<pre><code>&lt;el-button size=&quot;mini&quot; round type=&quot;primary&quot;&gt;登录&lt;/el-button&gt;
</code></pre>
<p>当用户在 input 组件输入数据时，我们需要将数据暂时保存下来，这里就需要用到 Vue 里面的绑定数据功能。在 Login.vue 文件里面的 script 部分中，添加 data 方法和相关属性，保存用户输入的信息。</p>
<pre><code>export default {
  name: &quot;Login&quot;,
  data() {
    return {
      ruleForm: {
        username: &quot;&quot;,
        password: &quot;&quot;,
        rememberMe: true,
      },
    };
  },
};
</code></pre>
<p>然后在组件上，使用 v-model 绑定相关数据属性，因为 Vue 是双向绑定的，也就是说当用户在邮箱输入框输入数据之后，“ruleForm.username”也就有了相应的值；反之，假定执行 ruleForm.username=“123” 之后，邮箱输入框也会显示 123，同时我们也可以对 button 组件绑定响应方法。比如，下面我们就对登录按钮绑定了 validForm 方法：</p>
<pre><code>&lt;el-form label-width=&quot;&quot; label-position=&quot;left&quot;&gt;
  &lt;el-form-item label=&quot;&quot; class=&quot;password-item&quot;&gt;
    &lt;el-input
      prefix-icon=&quot;el-icon-user-solid&quot;
      placeholder=&quot;账号&quot;
      v-model=&quot;ruleForm.username&quot;
      size=&quot;mini&quot;
    &gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;el-form-item label=&quot;&quot; class=&quot;password-item&quot;&gt;
    &lt;el-input
      prefix-icon=&quot;el-icon-lock&quot;
      placeholder=&quot;密码&quot;
      show-password
      v-model=&quot;ruleForm.password&quot;
      size=&quot;mini&quot;
    &gt;&lt;/el-input&gt;
  &lt;/el-form-item&gt;
  &lt;p class=&quot;handle-password&quot;&gt;
    &lt;el-checkbox v-model=&quot;ruleForm.rememberMe&quot;&gt;
      &lt;span style=&quot;font-size: 12px; color: #409eff&quot;&gt;记住我&lt;/span&gt;
    &lt;/el-checkbox&gt;
    &lt;el-link href=&quot;/&quot; target=&quot;_blank&quot; type=&quot;primary&quot;
      &gt;&lt;span style=&quot;font-size: 12px&quot;&gt;忘记密码&lt;/span&gt;&lt;/el-link
    &gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;el-button size=&quot;mini&quot; round @click=&quot;validForm&quot; type=&quot;primary&quot;
      &gt;登录&lt;/el-button
    &gt;
  &lt;/p&gt;
&lt;/el-form&gt;
</code></pre>
<p>同时修改<code>&lt;script&gt;&lt;/script&gt;</code>内代码，增加方法：</p>
<pre><code>export default {
  name: &quot;Login&quot;,
  data() {
    return {
      ruleForm: {
        username: &quot;&quot;,
        password: &quot;&quot;,
        rememberMe: true,
      },
    };
  },
  methods: {
      validForm(){

      }
  }
};
</code></pre>
<h4 id="22-完成登录前的前端校验">2.2 完成登录前的前端校验</h4>
<p>当用户点击登录按钮时，需要验证用户是否填写了账号和密码，所以添加 validForm 方法进行验证，如果账号和密码为空，就报出提示信息提示用户填写。提示方式我们采用 Element-UI 自带的 message 组件，具体提示方法为：</p>
<pre><code>export default {
  name: &quot;Login&quot;,
  ...
  methods: {
    validForm() {
      if (
        this.ruleForm.username.length === 0 ||
        this.ruleForm.password.length === 0
      ) {
        this.$message({
          message: &quot;请输入账号和密码&quot;,
          type: &quot;warning&quot;,
        });
      }
    },
  },
};
</code></pre>
<p>Message 详细使用可以参考：<a href="https://element.eleme.cn/#/zh-CN/component/message">Element - The world’s most popular Vue UI framework</a>。</p>
<h2 id="4-实现登陆功能">4. 实现登陆功能</h2>
<h3 id="1-任务说明-3">1 - 任务说明</h3>
<p><strong>描述</strong>：使用 axios 发送 http 请求，并处理登录结果。</p>
<p><strong>要求</strong>：学习使用 axios 发送 post 请求，学习使用<code>$message</code>对正确的和错误的响应给与信息提示。</p>
<h3 id="2-任务提示-3">2 - 任务提示</h3>
<h4 id="21-学习-http-请求使用-axios-发送登录请求">2.1 - 学习 HTTP 请求，使用 Axios 发送登录请求</h4>
<p>接下来我们就要实现登录功能了，在登录时前端会向后端发送 HTTP 请求，相信大家都接触过 HTTP 请求相关知识，在这简单重温一下 HTTP 请求的概念。</p>
<p>HTTP 请求（HTTP Request）就是浏览器发送的数据报文，要求服务器根据请求内容进行回复，回复的内容就叫 HTTP 响应（HTTP Response）。</p>
<p>HTTP 请求分成 HTTP 动作，目标 URL、Header 和 Data。</p>
<p>HTTP 动作是初学者最容易搞错的内容，常用的 HTTP 动作分别有：</p>
<ul>
<li><strong>Get，获取数据</strong></li>
<li><strong>Post，创建数据</strong></li>
<li><strong>Delete，删除数据</strong></li>
<li><strong>Put，更改数据</strong></li>
</ul>
<p>HTTP 响应包含状态码、Header、数据，整体代表后端服务器的应答。在登录时，我们应该向后端发起 Post 请求，后端服务器应该返回状态码 200 表示登录正常，500 表示登录错误。</p>
<blockquote>
<p>阅读这里详细了解 HTTP Request 和 Response，<a href="https://blog.csdn.net/mccand1234/article/details/54577413">HTTP Request 和Response_春天的早晨的博客-CSDN博客</a>。</p>
</blockquote>
<p>接下来我们使用一开始安装的 Axios 发送请求，Axios 提供 get、post 等方法帮助我们完成请求的发送。</p>
<p>然后在 Login.vue 中，修改 validForm 方法，发送请求：</p>
<pre><code>validForm() {
  if (
    this.ruleForm.username.length === 0 ||
    this.ruleForm.password.length === 0
  ) {
    this.$message({
      message: &quot;请输入账号和密码&quot;,
      type: &quot;warning&quot;,
    });
    return;
  }
  // http://localhost:12306/login 是后端服务处理登录的API
  this.$http
    .post(&quot;http://localhost:12306/login&quot;, {
      username: this.username,
      password: this.password,
    })
    .then((response) =&gt; {
      this.$message({
        message: &quot;登录成功&quot;,
        type: &quot;success&quot;,
      });
    })
    .catch((error) =&gt; {
      this.$message({
        message: &quot;登录失败&quot;,
        type: &quot;warning&quot;,
      });
    });
}
</code></pre>
<p>在上面的例子中，我们使用了<code>this.$http.post</code>发送登录请求，在 “then()” 方法里面是登录成功之后的逻辑，在“catch()”方法里面是登录失败之后的逻辑。</p>
<h4 id="22-启动后端服务器响应前端请求">2.2 - 启动后端服务器，响应前端请求</h4>
<p>在这个项目中，我们使用 json-server 包来模拟后端服务器，帮助我们开发。下载 backend.zip 压缩包：<a href="https://assets.jiker.com/_for_plus_sub_project/2023/0706/admin/M05yGojytxDUWzXP92Sy6a1M0HdyTyVn3YIxbGWW.zip">backend (1).zip</a>。解压缩后放入项目目录下，类似下图：</p>
<figure data-type="image" tabindex="86"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/iDD1nmPYlSFI4PAcyMjSvOfU2q4rSKYYBLr0gxJ3.png" alt="image.png" loading="lazy"></figure>
<p>然后编辑 package.json 文件，在 script 中添加 start-backend-server 命令：</p>
<pre><code>&quot;scripts&quot;: {
   &quot;serve&quot;: &quot;vue-cli-service serve&quot;,
   &quot;build&quot;: &quot;vue-cli-service build&quot;,
   &quot;lint&quot;: &quot;vue-cli-service lint&quot;,
   &quot;start-backend-server&quot;: &quot;node ./backend/server.js&quot;
}
</code></pre>
<p><code>&quot;node ./backend/server.js&quot;</code>是运行 backend 下的 server.js，node 是 node.js 执行脚本文件的命令。</p>
<p>接下来新开启一个命令行窗口，在项目文件夹路径下运行命令 <code>npm run start-backend-server</code>，启动后端模拟服务器，看到输出信息：</p>
<figure data-type="image" tabindex="87"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/ljqudvBJWuve9GgJli0PljJoleBgvaeV6FV4jrTc.png" alt="image.png" loading="lazy"></figure>
<p>用浏览器访问 <a href="http://localhost:12306/hello%EF%BC%8C">http://localhost:12306/hello</a>，能看到 {“message”: “Hello”} 的话就说明后端服务启动成功了。</p>
<blockquote>
<p>注意，要确保 npm run serve 和 npm run start-backend-serve 同时运行。然后你就能在页面中测试你的登录功能了。</p>
</blockquote>
<h3 id="3-课后练习-2">3 - 课后练习</h3>
<p>练习使用 axios 的 get、post、put 等功能。</p>
<h2 id="5-在浏览器保存登陆信息">5. 在浏览器保存登陆信息</h2>
<h3 id="1-任务说明-4">1 - 任务说明</h3>
<p><strong>描述</strong>：使用浏览器 LocalStorage 保存登录信息。</p>
<p><strong>要求</strong>：初步了解 Token 的知识，学习浏览器 LocalStorage 和 SessionStorage 的区别。</p>
<h3 id="2-任务提示-4">2 - 任务提示</h3>
<h4 id="21-了解-token-的知识">2.1 - 了解 Token 的知识</h4>
<p>后端的服务器中，正确的用户名密码是’admin/password’，其他登录信息都会失败。当登录成功之后，服务器会返回下面的 json：</p>
<pre><code>{
  &quot;token&quot;: &quot;89e38e0ca1c5857c5f848d49fcb825f72926635a&quot;, 
  &quot;user&quot;: { &quot;id&quot;: &quot;456&quot;, &quot;name&quot;: &quot;张三&quot; }
}
</code></pre>
<p>其中的 Token 就是后端服务器给浏览器的一个凭证，用这个凭证就可以证明该用户已经登录过，因此，我们后面所有的请求都要带上这个 Token。Token 的形式有很多种，我们使用的是随机字符串，当然更加复杂的还有 json web token，看这里了解详细知识，<a href="https://www.zhihu.com/question/36135526">json web token是用来做什么的? - 知乎</a>。</p>
<h4 id="22-学习浏览器-localstorage-和-sessionstorage">2.2 - 学习浏览器 LocalStorage 和 SessionStorage</h4>
<p>我们需要将刚才获取的 Token 存放在浏览器中，以便后续使用，否则页面一旦刷新就找不到 Token 了。常用的浏览器存储有 LocalStorage 和 SessionStorage，它们都是存放 key-value 键值对的，区别是 LocalStorage 一直有有效期，而 SessionStorage 在关闭当前标签页或者浏览器之后内容就失效，显然 SessionStorage 更加安全，在这里我们作为练习用 LocalStorage 就可以了。</p>
<blockquote>
<p>注意，因为 LocalStorage 长期有效，我们可以手动清除 LocalStorage 的值对登录页面进行多次测试。看这里了解更详细的 LocalStorage 资料，<a href="https://juejin.cn/post/6844903631091662855">localStorage和sessionStorage区别 - 掘金</a>。</p>
</blockquote>
<h4 id="23-将-token-存储在-localstorage-中">2.3 - 将 Token 存储在 LocalStorage 中</h4>
<p>在 Login.vue 中，使用 localStorage.setItem 方法将信息存放在 localStorage 里面，修改登录方法如下：</p>
<pre><code>validForm() {
  if (
    this.ruleForm.username.length === 0 ||
    this.ruleForm.password.length === 0
  ) {
    this.$message({
      message: &quot;请输入账号和密码&quot;,
      type: &quot;warning&quot;,
    });
    return;
  }
  // http://localhost:12306/login 是后端服务处理登录的API
  this.$http
    .post(&quot;http://localhost:12306/login&quot;, {
      username: this.ruleForm.username,
      password: this.ruleForm.password,
    })
    .then((response) =&gt; {
      localStorage.setItem(&quot;token&quot;, response.data.token);
      localStorage.setItem(&quot;userId&quot;, response.data.user.id);
      localStorage.setItem(&quot;userName&quot;, response.data.user.name);
      this.$message({
        message: &quot;登录成功&quot;,
        type: &quot;success&quot;,
      });
    })
    .catch((error) =&gt; {
      this.$message({
        message: &quot;登录失败&quot;,
        type: &quot;warning&quot;,
      });
    });
}
</code></pre>
<p>在浏览器里查看 LocalStorage：</p>
<figure data-type="image" tabindex="88"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/ajhW2TY9r5Pz51hWGfd5TXxVhcqgALtAcMVS4GTL.png" alt="image.png" loading="lazy"></figure>
<h3 id="3-课后练习-3">3 - 课后练习</h3>
<p>练习使用 SessionStorage 存储 token 信息。</p>
<p>主要实现代码如下：</p>
<pre><code>...
sessionStorage.setItem(&quot;token&quot;, response.data.token);
sessionStorage.setItem(&quot;userId&quot;, response.data.user.id);
sessionStorage.setItem(&quot;userName&quot;, response.data.user.name);
</code></pre>
<h2 id="6-登陆成功之后跳转至新页面">6. 登陆成功之后跳转至新页面</h2>
<h3 id="1-任务说明-5">1 - 任务说明</h3>
<p><strong>描述</strong>：登录接口成功返回之后跳转到新页面。</p>
<p><strong>要求</strong>：学习 Vue Router，完成新页面路由配置，设置好登录成功之后跳转至新页面。</p>
<h3 id="2-任务提示-5">2 - 任务提示</h3>
<h4 id="21-新增-home-页面">2.1 - 新增 Home 页面</h4>
<p>在 components 下创建 Home.vue 文件：</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;Home Page&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &quot;Home&quot;,
};
&lt;/script&gt;
</code></pre>
<p>在 main.js 添加对应的路由配置：</p>
<pre><code>import Home from './components/Home'
...

const routes = [
  {
    path: '/',
    redirect: '/login'
  },
  {
    path: '/login',
    component: Login
  },
  {
    path: '/home',
    component: Home
  },
  {
    path: '*',
    name: 'NotFound',
    component: NotFound
  }
]
</code></pre>
<h4 id="22-登录成功之后跳转到新页面">2.2 - 登录成功之后跳转到新页面</h4>
<p>打开 Login.vue 文件，在登录成功之后的逻辑中加入 <code>this.$router.push('/home')</code>，这样就完成了跳转，查看 Vue Router 的介绍，<a href="https://router.vuejs.org/zh/guide/">入门 | Vue Router</a>。</p>
<pre><code>methods: {
  validForm() {
    if (
      this.ruleForm.username.length === 0 ||
      this.ruleForm.password.length === 0
    ) {
      this.$message({
        message: &quot;请输入账号和密码&quot;,
        type: &quot;warning&quot;,
      });
      return;
    }
    // http://localhost:12306/login 是后端服务处理登录的API
    this.$http
      .post(&quot;http://localhost:12306/login&quot;, {
        username: this.ruleForm.username,
        password: this.ruleForm.password,
      })
      .then((response) =&gt; {
        localStorage.setItem(&quot;token&quot;, response.data.token);
        localStorage.setItem(&quot;userId&quot;, response.data.user.id);
        localStorage.setItem(&quot;userName&quot;, response.data.user.name);
        this.$message({
          message: &quot;登录成功&quot;,
          type: &quot;success&quot;,
        });
         this.$router.push(&quot;/home&quot;); //跳转
      })
      .catch((error) =&gt; {
        this.$message({
          message: &quot;登录失败&quot;,
          type: &quot;warning&quot;,
        });
      });
  },
},
</code></pre>
<h4 id="23-配置路由信息如果没有登录则跳转至登录页面">2.3 - 配置路由信息，如果没有登录则跳转至登录页面</h4>
<p>如果没有登录，那么访问任何页面都要跳转到登录页面，这就需要我们修改路由的配置信息，加上是否登录的判断。打开 main.js，添加下面代码，我们使用了 Vue Router 导航守卫，详细请看这里，<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫 | Vue Router</a>。</p>
<pre><code>const router = new VueRouter({
  mode: 'hash',
  routes
})

router.beforeEach((to, from, next)=&gt; {
  let logined = localStorage.getItem('token');
  if (to.path == &quot;/login&quot;) { //访问login页面
    if (!logined) {
      next(); //没有登录就正常访问login页面
    } else {
      next(&quot;/home&quot;); //登录了就跳转到Home页面
    }
  } else { //访问的不是login页面
    if (!logined) { //没有登录就跳转到login页面
      next(&quot;/login&quot;);
    } else {
      next(); // 登陆了就正常访问
    }
  }
})
</code></pre>
<h3 id="3-课后练习-4">3 - 课后练习</h3>
<p>练习使用 vue-router 的导航守卫。</p>
<h2 id="7-使用element-ui-组件">7. 使用Element UI 组件</h2>
<h3 id="1-任务说明-6">1 - 任务说明</h3>
<p><strong>描述</strong>：使用 Element UI 组件库完成订单管理系统页面 UI。</p>
<p><strong>要求</strong>：继续学习 Element UI，学习布局、menu 组件、progress 组件、dropdown 组件和 table 组件。</p>
<p>Home 页面完成后的整体预览效果：</p>
<figure data-type="image" tabindex="89"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/GPWpSas8ei9kybg7apmUoulJx6utRnxMiVWjTwku.png" alt="img" loading="lazy"></figure>
<h3 id="2-任务提示-6">2 - 任务提示</h3>
<h4 id="21-完成页面基本布局">2.1 - 完成页面基本布局</h4>
<p>我们首先修改 Home.vue，完成上、左右布局：</p>
<figure data-type="image" tabindex="90"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/G0VCEhIRQkqP6LheBdJDLogBhWWDMYtbBR47Bwzz.png" alt="img" loading="lazy"></figure>
<h4 id="22-完成-header-中的菜单栏">2.2 - 完成 Header 中的菜单栏</h4>
<p>和我们刚才完成的登录菜单栏类似，使用<code>&lt;el-menu&gt;</code>组件完成，仍可参考<a href="https://element.eleme.cn/#/zh-CN/component/menu">Element - The world’s most popular Vue UI framework</a>。</p>
<pre><code>&lt;el-menu
  default-active=&quot;/&quot;
  class=&quot;home-menu&quot;
  mode=&quot;horizontal&quot;
  text-color=&quot;#ffffff&quot;
  active-text-color=&quot;#ffffff&quot;
  :router=&quot;true&quot;
  style=&quot;border: none; background: #409eff&quot;&gt;
  &lt;el-menu-item index=&quot;/&quot;&gt;订单管理&lt;/el-menu-item&gt;
  &lt;el-menu-item index=&quot;/operation-center&quot;&gt;处理中心&lt;/el-menu-item&gt;
  &lt;el-menu-item index=&quot;/platform&quot;&gt;工作台&lt;/el-menu-item&gt;
&lt;/el-menu&gt;
</code></pre>
<p>除此之外，我们可以在 header 右边加上一个用户的名字，同时加入 dropdown 来完成退出功能，退出时只要删除 localStorage 就可以了，<a href="https://element.eleme.cn/#/zh-CN/component/dropdown">Element - The world’s most popular Vue UI framework</a>。</p>
<pre><code>&lt;div class=&quot;nav-right&quot;&gt;
    &lt;el-badge :value=&quot;12&quot; class=&quot;item&quot;&gt;
      &lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;
    &lt;/el-badge&gt;
    &lt;el-dropdown class=&quot;user-dropdown-link&quot;&gt;
      &lt;span class=&quot;username&quot;&gt;
        {{username}}
        &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;
      &lt;/span&gt;
      &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
        &lt;el-dropdown-item
          icon=&quot;el-icon-delete-solid&quot;
          @click.native=&quot;logout&quot;
          &gt;退出&lt;/el-dropdown-item
        &gt;
      &lt;/el-dropdown-menu&gt;
    &lt;/el-dropdown&gt;
  &lt;/div&gt;
</code></pre>
<p>增加 JavaScript 代码，增加 username 和 logout 方法：</p>
<pre><code>export default {
  name: &quot;Home&quot;,
  data() {
    return {
    };
  },
  computed: {
    username(){
      return localStorage.getItem(&quot;userName&quot;);
    },
  },
  methods: {
    logout(){
      localStorage.clear(); // 删除localStorage
      this.$router.push(&quot;/login&quot;); //跳转到登录页面
    },
  },
};
</code></pre>
<p>完成之后类似这样，大家可能会发现我还在 dropdown 的左边加上了通知按钮，用的是 el-badge 实现的，<a href="https://element.eleme.cn/#/zh-CN/component/badge">Element - The world’s most popular Vue UI framework</a>，有兴趣的同学可以试一试，这里不要求大家一定实现出来。</p>
<figure data-type="image" tabindex="91"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/T1uIuAjLLGro9VJfEBv3cSMAuLaZW5or6NWyj55P.png" alt="img" loading="lazy"></figure>
<p>菜单栏整体参考代码：</p>
<pre><code>&lt;el-header class=&quot;header&quot;&gt;
    &lt;el-row&gt;
        &lt;el-col :span=&quot;4&quot;&gt;
            &lt;p class=&quot;nav-left&quot;&gt;
                &lt;i class=&quot;el-icon-grape&quot;&gt;&lt;/i&gt;&lt;span&gt;订单管理系统&lt;/span&gt;
            &lt;/p&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;17&quot;&gt;
            &lt;el-menu default-active=&quot;/&quot; class=&quot;home-menu&quot; mode=&quot;horizontal&quot; text-color=&quot;#ffffff&quot;
                active-text-color=&quot;#ffffff&quot; :router=&quot;true&quot; style=&quot;border: none; background: #409eff&quot;&gt;
                &lt;el-menu-item index=&quot;/&quot;&gt;订单管理&lt;/el-menu-item&gt;
                &lt;el-menu-item index=&quot;/operation-center&quot;&gt;处理中心&lt;/el-menu-item&gt;
                &lt;el-menu-item index=&quot;/platform&quot;&gt;工作台&lt;/el-menu-item&gt;
            &lt;/el-menu&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;3&quot;&gt;
            &lt;div class=&quot;nav-right&quot;&gt;
                &lt;el-badge :value=&quot;12&quot; class=&quot;item&quot;&gt;
                    &lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;
                &lt;/el-badge&gt;
                &lt;el-dropdown class=&quot;user-dropdown-link&quot;&gt;
                    &lt;span class=&quot;username&quot;&gt;
                        {{username}}
                        &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;
                    &lt;/span&gt;
                    &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
                        &lt;el-dropdown-item icon=&quot;el-icon-delete-solid&quot; @click.native=&quot;logout&quot;&gt;退出&lt;/el-dropdown-item&gt;
                    &lt;/el-dropdown-menu&gt;
                &lt;/el-dropdown&gt;
            &lt;/div&gt;
        &lt;/el-col&gt;
    &lt;/el-row&gt;
&lt;/el-header&gt;
</code></pre>
<p>菜单栏参考 css：</p>
<pre><code>.header {
  background-color: #409eff;
  height: 64px !important;
}
.header .nav-left,
.header .nav-right {
  display: flex;
  align-items: center;
}
.header .nav-left i {
  font-size: 30px;
  color: #fff;
}
.header .nav-left span {
  font-size: 16px;
  color: #fff;
}
.header .nav-right {
  height: 64px;
  justify-content: space-between;
}
.header .nav-right .el-icon-message {
  font-size: 24px;
  color: #fff;
}
.header .nav-right .username {
  color: #fff;
}
</code></pre>
<h4 id="23-完成左侧菜单栏">2.3 - 完成左侧菜单栏</h4>
<p>页面左侧同样是菜单栏，和 header 中的相比一个是水平的、一个是垂直的。我们在<code>&lt;el-aside&gt;</code>中添加<code>&lt;el-menu&gt;</code>：</p>
<pre><code>&lt;p class=&quot;menu-name&quot;&gt;菜单&lt;/p&gt;
&lt;el-menu default-active=&quot;1&quot; class=&quot;menu-vertical&quot;&gt;
    &lt;el-menu-item index=&quot;1&quot;&gt;
        &lt;i class=&quot;el-icon-s-data&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;整体数据&lt;/span&gt;
    &lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;2&quot;&gt;
        &lt;i class=&quot;el-icon-s-custom&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;客户管理&lt;/span&gt;
    &lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;3&quot;&gt;
        &lt;i class=&quot;el-icon-map-location&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;地址管理&lt;/span&gt;
    &lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;4&quot;&gt;
        &lt;i class=&quot;el-icon-s-management&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;区域管理&lt;/span&gt;
    &lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;5&quot;&gt;
        &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;部门管理&lt;/span&gt;
    &lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;6&quot;&gt;
        &lt;i class=&quot;el-icon-s-home&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;员工管理&lt;/span&gt;
    &lt;/el-menu-item&gt;
    &lt;el-menu-item index=&quot;7&quot;&gt;
        &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;
        &lt;span slot=&quot;title&quot;&gt;短信通知&lt;/span&gt;
    &lt;/el-menu-item&gt;
&lt;/el-menu&gt;
</code></pre>
<p>参考 css：</p>
<pre><code>.menu-name {
  border-right: solid 1px #e6e6e6;
  margin: 0;
  padding-bottom: 10px;
  padding-left: 60px;
  padding-top: 20px;
  font-weight: bold;
}
</code></pre>
<p>预览如下：</p>
<figure data-type="image" tabindex="92"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/qPKxlxROfV49SQCrTzIRX3OdB9kVq9J7ropWc8Fe.png" alt="img" loading="lazy"></figure>
<h4 id="24-完成关键指标区域">2.4 - 完成关键指标区域</h4>
<p>接下来要对右边的内容区域进行划分，划分成两行。</p>
<p>第一行分成两列，每一列用<code>&lt;el-card&gt;</code>给页面添加两张白色的卡片，卡片上面放上不同类型的进度条表示不同的数据。</p>
<ul>
<li>el-card 参考<a href="https://element.eleme.cn/#/zh-CN/component/card">Element - The world’s most popular Vue UI framework</a>。</li>
<li>el-progress 参考 <a href="https://element.eleme.cn/#/zh-CN/component/progress">Element - The world’s most popular Vue UI framework</a>。</li>
</ul>
<blockquote>
<p>值得注意的是，通过添加方 moneyFormat，我们可以自定义 progress bar 中的文字：</p>
</blockquote>
<pre><code>&lt;el-row :gutter=&quot;60&quot;&gt;
    &lt;el-col :span=&quot;12&quot;&gt;
        &lt;el-card class=&quot;box-card&quot;&gt;
            &lt;div slot=&quot;header&quot;&gt;关键指标&lt;/div&gt;
            &lt;div class=&quot;progress&quot;&gt;
                &lt;el-progress class=&quot;progress-bar&quot; :text-inside=&quot;true&quot; :stroke-width=&quot;20&quot; :percentage=&quot;20&quot;
                    :format=&quot;(val) =&gt; moneyFormat(val, '回款率')&quot; status=&quot;exception&quot;&gt;&lt;/el-progress&gt;
            &lt;/div&gt;
            &lt;div class=&quot;progress&quot;&gt;
                &lt;el-progress class=&quot;progress-bar&quot; :text-inside=&quot;true&quot; :stroke-width=&quot;20&quot; :percentage=&quot;50&quot;
                    :format=&quot;(val) =&gt; moneyFormat(val, '库存')&quot;&gt;&lt;/el-progress&gt;
            &lt;/div&gt;
            &lt;div class=&quot;progress&quot;&gt;
                &lt;el-progress class=&quot;progress-bar&quot; :text-inside=&quot;true&quot; :stroke-width=&quot;20&quot; :percentage=&quot;80&quot;
                    :format=&quot;(val) =&gt; moneyFormat(val, '满意率')&quot; status=&quot;warning&quot;&gt;&lt;/el-progress&gt;
            &lt;/div&gt;
            &lt;div class=&quot;progress&quot;&gt;
                &lt;el-progress class=&quot;progress-bar&quot; :text-inside=&quot;true&quot; :stroke-width=&quot;20&quot; :percentage=&quot;100&quot;
                    :format=&quot;(val) =&gt; moneyFormat(val, '送达率')&quot; status=&quot;success&quot;&gt;&lt;/el-progress&gt;
            &lt;/div&gt;
        &lt;/el-card&gt;
    &lt;/el-col&gt;
    &lt;el-col :span=&quot;12&quot;&gt;
        &lt;el-card class=&quot;box-card&quot;&gt;
            &lt;div slot=&quot;header&quot;&gt;市场占有率&lt;/div&gt;
            &lt;el-progress type=&quot;dashboard&quot; :width=&quot;180&quot; :percentage=&quot;70&quot;&gt;&lt;/el-progress&gt;
        &lt;/el-card&gt;
    &lt;/el-col&gt;
&lt;/el-row&gt;
</code></pre>
<p>上面 moneyFormat 定义如下：</p>
<pre><code>methods: {
  ...
  moneyFormat(val, text) {
    return `${text} ${val}%`;
  }
}
</code></pre>
<p>预览如下：</p>
<figure data-type="image" tabindex="93"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/7de1vI9XYlMWWSTXTgYZheJ3MyO26Uto4qdelEmW.png" alt="image.png" loading="lazy"></figure>
<h4 id="25-完成订单数据表格">2.5 - 完成订单数据表格</h4>
<p>第二行分成两列，每一列用<code>&lt;el-table&gt;</code>给页面添加表格。在 order 列表中，使用<code>&lt;el-table&gt;</code>进行数据展示，<code>el-table</code> 要求绑定数组对象才能进行数据展示。因此，我们要在对象的 data 方法中加入 orders，数据格式为数组。</p>
<pre><code>export default {
  name: &quot;Home&quot;,
  data() {
    return { orders: [] };
  },
  ...
}
</code></pre>
<p>然后绑定到 el-table 中，el-table 具体属性请看<a href="https://element.eleme.cn/#/zh-CN/component/table">Element - The world’s most popular Vue UI framework</a>。</p>
<pre><code>&lt;el-table :data=&quot;orders&quot; height=&quot;500&quot; border stripe&gt;
  &lt;el-table-column prop=&quot;id&quot; label=&quot;订单编号&quot;&gt;&lt;/el-table-column&gt;
  &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot;&gt;&lt;/el-table-column&gt;
  &lt;el-table-column prop=&quot;price&quot; label=&quot;价格&quot;&gt;&lt;/el-table-column&gt;
  &lt;el-table-column prop=&quot;user.name&quot; label=&quot;姓名&quot;&gt;&lt;/el-table-column&gt;
  &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt;&lt;/el-table-column&gt;
  &lt;el-table-column prop=&quot;user.phone&quot; label=&quot;电话&quot;&gt;&lt;/el-table-column&gt;
&lt;/el-table&gt;
</code></pre>
<p><code>&lt;el-table-column&gt;</code>中的 prop 属性的值就对应 orders 数组中的值的结构，比如上面的表格希望 orders 数组中的值最少具有以下结构：</p>
<pre><code>{
      &quot;id&quot;: 1856,
      &quot;date&quot;: &quot;2020-03-10T08:31:03.080Z&quot;,
      &quot;price&quot;: &quot;240.00&quot;,
      &quot;address&quot;: &quot;包 廖头市汪 栋&quot;,
      &quot;user&quot;: {
        &quot;name&quot;: &quot;余 思&quot;,
        &quot;phone&quot;: &quot;3855-93516635&quot;
      }
}
</code></pre>
<p>因为有两个 el-table，需要绑定两个数组，我们可以根据 order 中的 isReturn 属性创建两个 computed 属性，分别代表正常订单 normalOrder 和退款订单 returnOrder：</p>
<pre><code>export default {
  name: &quot;Home&quot;,
  data() {
    return {
        orders: []
    };
  },
  computed: {
    ...
    normalOrder(){
      return this.orders.filter(order =&gt; {
        return !order.isReturn;
      });
    },
    returnOrder(){
      return this.orders.filter(order =&gt; {
        return order.isReturn;
      });
    }
  },
  ...
};
</code></pre>
<p>分别绑定到两个 el-table 上：</p>
<pre><code>&lt;el-table :data=&quot;normalOrder&quot; height=&quot;500&quot; border stripe&gt;...
&lt;el-table :data=&quot;returnOrder&quot; height=&quot;500&quot; border stripe&gt;...
</code></pre>
<p>整体完成后预览效果：</p>
<figure data-type="image" tabindex="94"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/8bnqPP90Vy2xNINNihgWkHPW3Fi5orCF5TT4zCc3.png" alt="image.png" loading="lazy"></figure>
<p>整体参考代码：</p>
<pre><code>&lt;template&gt;
  &lt;el-container&gt;
    &lt;el-header class=&quot;header&quot;&gt;
      &lt;el-row&gt;
        &lt;el-col :span=&quot;4&quot;&gt;
          &lt;p class=&quot;nav-left&quot;&gt;
            &lt;i class=&quot;el-icon-grape&quot;&gt;&lt;/i&gt;&lt;span&gt;订单管理系统&lt;/span&gt;
          &lt;/p&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;17&quot;&gt;
          &lt;el-menu
            default-active=&quot;/&quot;
            class=&quot;home-menu&quot;
            mode=&quot;horizontal&quot;
            text-color=&quot;#ffffff&quot;
            active-text-color=&quot;#ffffff&quot;
            :router=&quot;true&quot;
            style=&quot;border: none; background: #409eff&quot;
          &gt;
            &lt;el-menu-item index=&quot;/&quot;&gt;订单管理&lt;/el-menu-item&gt;
            &lt;el-menu-item index=&quot;/operation-center&quot;&gt;处理中心&lt;/el-menu-item&gt;
            &lt;el-menu-item index=&quot;/platform&quot;&gt;工作台&lt;/el-menu-item&gt;
          &lt;/el-menu&gt;
        &lt;/el-col&gt;
        &lt;el-col :span=&quot;3&quot;&gt;
          &lt;div class=&quot;nav-right&quot;&gt;
            &lt;el-badge :value=&quot;12&quot; class=&quot;item&quot;&gt;
              &lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;
            &lt;/el-badge&gt;
            &lt;el-dropdown class=&quot;user-dropdown-link&quot;&gt;
              &lt;span class=&quot;username&quot;&gt;
                {{username}}
                &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;
              &lt;/span&gt;
              &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;
                &lt;el-dropdown-item
                  icon=&quot;el-icon-delete-solid&quot;
                  @click.native=&quot;logout&quot;
                  &gt;退出&lt;/el-dropdown-item
                &gt;
              &lt;/el-dropdown-menu&gt;
            &lt;/el-dropdown&gt;
          &lt;/div&gt;
        &lt;/el-col&gt;
      &lt;/el-row&gt;
    &lt;/el-header&gt;
    &lt;el-container&gt;
      &lt;el-aside width=&quot;200px&quot;&gt;
        &lt;p class=&quot;menu-name&quot;&gt;菜单&lt;/p&gt;
        &lt;el-menu default-active=&quot;1&quot; class=&quot;menu-vertical&quot;&gt;
          &lt;el-menu-item index=&quot;1&quot;&gt;
            &lt;i class=&quot;el-icon-s-data&quot;&gt;&lt;/i&gt;
            &lt;span slot=&quot;title&quot;&gt;整体数据&lt;/span&gt;
          &lt;/el-menu-item&gt;
          &lt;el-menu-item index=&quot;2&quot;&gt;
            &lt;i class=&quot;el-icon-s-custom&quot;&gt;&lt;/i&gt;
            &lt;span slot=&quot;title&quot;&gt;客户管理&lt;/span&gt;
          &lt;/el-menu-item&gt;
          &lt;el-menu-item index=&quot;3&quot;&gt;
            &lt;i class=&quot;el-icon-map-location&quot;&gt;&lt;/i&gt;
            &lt;span slot=&quot;title&quot;&gt;地址管理&lt;/span&gt;
          &lt;/el-menu-item&gt;
          &lt;el-menu-item index=&quot;4&quot;&gt;
            &lt;i class=&quot;el-icon-s-management&quot;&gt;&lt;/i&gt;
            &lt;span slot=&quot;title&quot;&gt;区域管理&lt;/span&gt;
          &lt;/el-menu-item&gt;
          &lt;el-menu-item index=&quot;5&quot;&gt;
            &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;
            &lt;span slot=&quot;title&quot;&gt;部门管理&lt;/span&gt;
          &lt;/el-menu-item&gt;
          &lt;el-menu-item index=&quot;6&quot;&gt;
            &lt;i class=&quot;el-icon-s-home&quot;&gt;&lt;/i&gt;
            &lt;span slot=&quot;title&quot;&gt;员工管理&lt;/span&gt;
          &lt;/el-menu-item&gt;
          &lt;el-menu-item index=&quot;7&quot;&gt;
            &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;
            &lt;span slot=&quot;title&quot;&gt;短信通知&lt;/span&gt;
          &lt;/el-menu-item&gt;
        &lt;/el-menu&gt;
      &lt;/el-aside&gt;
      &lt;el-main&gt;
        &lt;el-row :gutter=&quot;60&quot;&gt;
          &lt;el-col :span=&quot;12&quot;&gt;
            &lt;el-card class=&quot;box-card&quot;&gt;
              &lt;div slot=&quot;header&quot;&gt;关键指标&lt;/div&gt;
              &lt;div class=&quot;progress&quot;&gt;
                &lt;el-progress
                  class=&quot;progress-bar&quot;
                  :text-inside=&quot;true&quot;
                  :stroke-width=&quot;20&quot;
                  :percentage=&quot;20&quot;
                  :format=&quot;(val) =&gt; moneyFormat(val, '回款率')&quot;
                  status=&quot;exception&quot;
                &gt;&lt;/el-progress&gt;
              &lt;/div&gt;
              &lt;div class=&quot;progress&quot;&gt;
                &lt;el-progress
                  class=&quot;progress-bar&quot;
                  :text-inside=&quot;true&quot;
                  :stroke-width=&quot;20&quot;
                  :percentage=&quot;50&quot;
                  :format=&quot;(val) =&gt; moneyFormat(val, '库存')&quot;
                &gt;&lt;/el-progress&gt;
              &lt;/div&gt;
              &lt;div class=&quot;progress&quot;&gt;
                &lt;el-progress
                  class=&quot;progress-bar&quot;
                  :text-inside=&quot;true&quot;
                  :stroke-width=&quot;20&quot;
                  :percentage=&quot;80&quot;
                  :format=&quot;(val) =&gt; moneyFormat(val, '满意率')&quot;
                  status=&quot;warning&quot;
                &gt;&lt;/el-progress&gt;
              &lt;/div&gt;
              &lt;div class=&quot;progress&quot;&gt;
                &lt;el-progress
                  class=&quot;progress-bar&quot;
                  :text-inside=&quot;true&quot;
                  :stroke-width=&quot;20&quot;
                  :percentage=&quot;100&quot;
                  :format=&quot;(val) =&gt; moneyFormat(val, '送达率')&quot;
                  status=&quot;success&quot;
                &gt;&lt;/el-progress&gt;
              &lt;/div&gt;
            &lt;/el-card&gt;
          &lt;/el-col&gt;
          &lt;el-col :span=&quot;12&quot;&gt;
            &lt;el-card class=&quot;box-card&quot;&gt;
              &lt;div slot=&quot;header&quot;&gt;市场占有率&lt;/div&gt;
              &lt;el-progress
                type=&quot;dashboard&quot;
                :width=&quot;180&quot;
                :percentage=&quot;70&quot;
              &gt;&lt;/el-progress&gt;
            &lt;/el-card&gt;
          &lt;/el-col&gt;
        &lt;/el-row&gt;
        &lt;el-row :gutter=&quot;60&quot;&gt;
          &lt;el-col :span=&quot;12&quot;&gt;
            &lt;h2&gt;正常订单&lt;/h2&gt;
            &lt;el-table :data=&quot;normalOrder&quot; height=&quot;500&quot; border stripe&gt;
              &lt;el-table-column prop=&quot;id&quot; label=&quot;订单编号&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;price&quot; label=&quot;价格&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;user.name&quot; label=&quot;姓名&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;user.phone&quot; label=&quot;电话&quot;&gt;&lt;/el-table-column&gt;
            &lt;/el-table&gt;
          &lt;/el-col&gt;
          &lt;el-col :span=&quot;12&quot;&gt;
            &lt;h2&gt;退款订单&lt;/h2&gt;
            &lt;el-table :data=&quot;returnOrder&quot; height=&quot;500&quot; border stripe&gt;
              &lt;el-table-column prop=&quot;id&quot; label=&quot;订单编号&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;price&quot; label=&quot;价格&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;user.name&quot; label=&quot;姓名&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt;&lt;/el-table-column&gt;
              &lt;el-table-column prop=&quot;user.phone&quot; label=&quot;电话&quot;&gt;&lt;/el-table-column&gt;
            &lt;/el-table&gt;
          &lt;/el-col&gt;
        &lt;/el-row&gt;
      &lt;/el-main&gt;
    &lt;/el-container&gt;
  &lt;/el-container&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: &quot;Home&quot;,
  data() {
    return {
        orders: []
    };
  },
  computed: {
    username(){
      return localStorage.getItem(&quot;userName&quot;);
    },
    normalOrder(){
      return this.orders.filter(order =&gt; {
        return !order.isReturn;
      });
    },
    returnOrder(){
      return this.orders.filter(order =&gt; {
        return order.isReturn;
      });
    }
  },
  methods: {
    logout(){
      localStorage.clear(); // 删除localStorage
      this.$router.push(&quot;/login&quot;); //跳转到登录页面
    },
    moneyFormat(val, text) {
      return `${text} ${val}%`;
    }
  }
};
&lt;/script&gt;
&lt;style scoped&gt;
.header {
  background-color: #409eff;
  height: 64px !important;
}
.header .nav-left,
.header .nav-right {
  display: flex;
  align-items: center;
}
.header .nav-left i {
  font-size: 30px;
  color: #fff;
}
.header .nav-left span {
  font-size: 16px;
  color: #fff;
}
.header .nav-right {
  height: 64px;
  justify-content: space-between;
}
.header .nav-right .el-icon-message {
  font-size: 24px;
  color: #fff;
}
.header .nav-right .username {
  color: #fff;
}
.menu-name {
  border-right: solid 1px #e6e6e6;
  margin: 0;
  padding-bottom: 10px;
  padding-left: 60px;
  padding-top: 20px;
  font-weight: bold;
}
.progress + .progress {
  margin-top: 35px;
}
&lt;/style&gt;
</code></pre>
<h3 id="3-课后练习-5">3 - 课后练习</h3>
<p>练习使用 progress 组件和 dropdown 组件。</p>
<h2 id="8-获取后端表格数据">8. 获取后端表格数据</h2>
<h3 id="1-任务说明-7">1 - 任务说明</h3>
<p><strong>描述</strong>：前端发起请求获取后端数据，然后显示到订单表格中。</p>
<p><strong>要求</strong>：学习 Vue 组件的生命周期，在生命周期钩子方法中发起请求获取数据，巩固 el-table 数据赋值。</p>
<h3 id="2-任务提示-7">2 - 任务提示</h3>
<h4 id="21-学习-vue-组件的生命周期">2.1 - 学习 Vue 组件的生命周期</h4>
<p>每一个组件从创建到消亡都符合 Vue 的生命周期图示，同时提供了一些生命周期钩子方法让开发者可以更方便地操作组件。下图是生命周期图示，具体查看这里，<a href="https://juejin.cn/post/6844903861782577159">Vue生命周期图示解析 - 掘金</a>。</p>
<figure data-type="image" tabindex="95"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/pf10e8Fc8ADBEeBJ6aoXvntNQ5weTfRb2VIirYMO.png" alt="image.png" loading="lazy"></figure>
<h4 id="22-在生命周期钩子函数中发起请求获取数据">2.2 - 在生命周期钩子函数中发起请求获取数据</h4>
<p>我们希望在页面打开的时候，向后台发起请求，获取所有订单数据，然后显示在两个表格中。一般来说，我们希望在组件还没有出现在页面上的时候就发起请求，这样对用户来说体验会更好。</p>
<p>打开 Home.vue，添加 created 方法，我们利用 axios 发送请求。注意获取数据的请求应该是 get，同时 url 是 <a href="http://localhost:12306/api/orders%EF%BC%8C">http://localhost:12306/api/orders</a>，后端要求附加之前获得的 token 表示已经登录，所以我们要添加 headers，符合 “{Authroization: Bearer XXX}” 这样的格式才会通过后端服务器的登录校验。请求成功之后，返回的数据放入 orders 数组中，Vue 会自动检测到数据的变化，同时刷新页面。</p>
<pre><code>export default {
  name: &quot;Home&quot;,
  data() {
    return {
      orders: [],
    };
  },
  ...
  created(){
    this.$http
      .get(&quot;http://localhost:12306/api/orders&quot;, {
        headers: { Authorization: `Bearer ${localStorage.getItem(&quot;token&quot;)}` },
      })
      .then((response) =&gt; {
        this.orders = response.data;
      });
  },
};
</code></pre>
<p>订单数据预览图如下：</p>
<figure data-type="image" tabindex="96"><img src="https://assets.jiker.com/_for_plus_sub_project/2022/0519/admin/y6zCiB1vFwt0CdH37kdKFMZajSiXP7AMAqTxFSax.png" alt="img" loading="lazy"></figure>
<h3 id="3-课后练习-6">3 - 课后练习</h3>
<p>练习使用 Vue 不同生命周期函数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Wechat小程序]]></title>
        <id>https://rowanwang6.github.io/post/wechat-xiao-cheng-xu/</id>
        <link href="https://rowanwang6.github.io/post/wechat-xiao-cheng-xu/">
        </link>
        <updated>2023-03-02T06:31:16.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>基本构成<br>
<img src="https://rowanwang6.github.io/post-images/1677738706283.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java]]></title>
        <id>https://rowanwang6.github.io/post/java/</id>
        <link href="https://rowanwang6.github.io/post/java/">
        </link>
        <updated>2022-08-17T02:34:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第一阶段java基本语法">第一阶段：Java基本语法</h1>
<h2 id="基本数据类型">基本数据类型</h2>
<p>字符类型：必须用单引号且只能有一个字符。<br>
制表符<code>\t</code>：将前一个字符串补空格到8位或8的倍数。<br>
整数：<code>byte, short, int, long</code> long 类型在定义变量时需要在变量值后面加一个L，大小写都可以，但大写易于区分；byte取值范围为-128～127<br>
小数：<code>float, double</code> float 加F 同理<br>
字符：<code>char</code><br>
布尔：<code>boolean</code></p>
<h3 id="隐式转换自动类型提升">隐式转换（自动类型提升）</h3>
<p><strong>规则</strong>：取值范围小转到取值范围大的，并非指占用空间大小。（float取值范围大于long，占用空间小，且能表示小数，但精度不高）<br>
特别的：byte short char会提升为int再计算<br>
<code>byte、short、char&lt;int&lt;long&lt;float&lt;double</code><br>
整型常量，规定为int类型；浮点常量，规定为double类型。<img src="https://rowanwang6.github.io/post-images/1683473847420.jpg" alt="" loading="lazy"></p>
<p><img src="https://rowanwang6.github.io/post-images/1684829141018.png" alt="" loading="lazy"><br>
（1）当把存储范围小的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围大的变量时</p>
<pre><code class="language-java">int i = 'A';//char自动升级为int，其实就是把字符的编码值赋值给i变量了
double d = 10;//int自动升级为double
long num = 1234567; //右边的整数常量值如果在int范围内，编译和运行都可以通过，这里涉及到数据类型转换

//byte bigB = 130;//错误，右边的整数常量值超过byte范围
long bigNum = 12345678912L;//右边的整数常量值如果超过int范围，必须加L，显式表示long类型。否则编译不通过
</code></pre>
<p>（2）当存储范围小的数据类型与存储范围大的数据类型变量一起混合运算时，会按照其中最大的类型运算。</p>
<pre><code class="language-java">int i = 1;
byte b = 1;
double d = 1.0;

double sum = i + b + d;//混合运算，升级为double
</code></pre>
<p><strong>（3）当byte,short,char数据类型的变量进行算术运算时，按照int类型处理。</strong></p>
<pre><code class="language-java">byte b1 = 1;
byte b2 = 2;
byte b3 = b1 + b2;//编译报错，b1 + b2自动升级为int

char c1 = '0';
char c2 = 'A';
int i = c1 + c2;//至少需要使用int类型来接收
System.out.println(c1 + c2);//113 
</code></pre>
<h3 id="强制转换">强制转换</h3>
<pre><code class="language-java">double a = 30.1;
int b = (int) a; // 可能会报错
</code></pre>
<p>&amp; | ^ ! &amp;&amp; ||<br>
&amp;&amp;短路与  如果左边错误 不判断右边 提高效率<br>
||   短路或  如果左边正确 不判断右边 提高效率</p>
<h1 id="第二阶段java面向对象编程">第二阶段：Java面向对象编程</h1>
<h1 id="第三阶段java语言的高级应用">第三阶段：Java语言的高级应用</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS 算法]]></title>
        <id>https://rowanwang6.github.io/post/js-suan-fa/</id>
        <link href="https://rowanwang6.github.io/post/js-suan-fa/">
        </link>
        <updated>2022-08-08T01:17:54.000Z</updated>
        <content type="html"><![CDATA[<p>输入： <code>let str = readline();</code></p>
<h1 id="字符串">字符串</h1>
<h2 id="字符串切片">字符串切片</h2>
<ol>
<li>
<p><code>slice(start, end)</code><br>
只能传入切片开头和结尾的index，不能固定切片长度，index可以为负数，但start不可以大于end；<br>
第一个参数比第二个参数大，结果返回空字符串；<br>
传入参数是负数，slice()会先做运算 test.length + 负数参数。</p>
</li>
<li>
<p><code>substr(start, length)</code><br>
从start开始，返回length长度字符，支持负数，不支持数组。传入参数超过length返回空字符<br>
串；<br>
传入负数，则从字符串的尾部开始算起始位置，-1指最后一个字符，-2指倒数第二个字符；<br>
当传入的第一个参数是负数且它的绝对值超过length，这个负数转化为0，当传入的第二个参数是负数，等价于0，截取0个字符，返回空字符串。</p>
</li>
<li>
<p><code>substring(start, stop)</code><br>
第二个参数==第一个参数，返回空字符串；<br>
传入两个参数，不管在第一还是第二位置，都会将小的参数作为第一个参数，较大的作为第二个参数；<br>
任何一个参数为负数或者NaN的时候，自动将其转换为0；<br>
任何一个参数大于length，按照length处理；<br>
只传入一个参数时，为start。</p>
</li>
<li>
<p><code>split(separator, length)</code></p>
</li>
<li>
<p><code>join(separator)</code></p>
</li>
<li>
<p><code>splice(start, length, …args)</code></p>
</li>
</ol>
<h2 id="字符串填充">字符串填充</h2>
<p><code>string.padEnd(targetLength, padString)</code></p>
<h1 id="进制转换">进制转换</h1>
<p><code>parseInt(num, 16)</code> 转换16进制<br>
<code>Number(string)</code></p>
<pre><code class="language-js">- parseInt(num,8);   //八进制转十进制 
- parseInt(num,16);   //十六进制转十进制 
- parseInt(num).toString(8)  //十进制转八进制 
- parseInt(num).toString(16)   //十进制转十六进制 
- parseInt(num,2).toString(8)   //二进制转八进制 
- parseInt(num,2).toString(16)  //二进制转十六进制 
- parseInt(num,8).toString(2)   //八进制转二
</code></pre>
<h1 id="质数因子">质数因子</h1>
<p>取余，<code>%</code><br>
1.判断终止条件: sqrt(num)<br>
2.本身就是质数的情况<br>
从2开始, 如果余数为0, 继续除当前(包括重复的质因子)就行</p>
<h1 id="数组去重">数组去重</h1>
<p>重复元素在Set中自动被过滤</p>
<pre><code class="language-js">var s = new Set([1, 2, 3, 3, '3']);
s; // Set {1, 2, 3, &quot;3&quot;}
</code></pre>
<h1 id="排序">排序</h1>
<p>sort() 方法中有一个参数，非必填，但是在忽略此参数的情况下，使用sort()排序会默认先调用数组中每一项元素的toString()方法，然后根据首字母的 ASCLL 码值的大小进行排序。</p>
<pre><code class="language-js">//升序 // sort((a,b)=&gt;{return a-b;})
arr.sort(function(x,y){
    retun x-y;
});
//降序
arr.sort(function(x,y){
    retun y-x;
});
</code></pre>
<h1 id="字符串替换">字符串替换</h1>
<p><code>str.replace(/[(a-z)]/g, a =&gt;{...}</code></p>
<pre><code class="language-js">let text = readline();
const arr = ['abc',2,'def',3,'ghi',4,'jkl',5,'mno',6,'pqrs',7,'tuv',8,'wxyz',9]
text = text.replace(/[(a-z)]/g,a =&gt; {
    for(let i=0;i&lt;arr.length;i++){
        if(typeof arr[i] == 'string' &amp;&amp; arr[i].indexOf(a) != -1){
            return arr[i+1]
        }
    }
})
text = text.replace(/([A-Z])/g,a =&gt; {
    if(a == 'Z'){
        return 'a'
    }else {
        return String.fromCharCode(a.toLowerCase().charCodeAt(0)+1)
    }
})
console.log(text)
</code></pre>
<h1 id="统计字符串出现次数">统计字符串出现次数</h1>
<pre><code class="language-js">for (let i = 0; i &lt; str.length; i++) {
  if (obj[str[i]]) obj[str[i]]++;
  else obj[str[i]] = 1;
}// 输入aabcddd  {a:2 b: 1 c:1 d:3}

// 找到出现次数最少的字符串，不拼接它们（删除）
let min = Math.min(...Object.values(obj));
for (let i = 0; i &lt; str.length; i++) {
  if (obj[str[i]] !== min) res += str[i];
}
</code></pre>
<h1 id="素数">素数</h1>
<pre><code class="language-js">function isPrime(num){
    for(let i = 2; i &lt;= Math.sqrt(num); i++){
        if(num % i == 0) return false
    }
    return true
}
</code></pre>
<h1 id="生成-x-y之间的随机整数">生成 [x, y]之间的随机整数</h1>
<pre><code class="language-js">function getRandom(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
console.log(getRandom(1, 10));
//生成 [0, x) 之间的随机数
Math.round(Math.random()*x)
//生成 [x, y) 之间的随机数
Math.round(Math.random()*(y-x)+x)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue.js]]></title>
        <id>https://rowanwang6.github.io/post/vuejs/</id>
        <link href="https://rowanwang6.github.io/post/vuejs/">
        </link>
        <updated>2022-07-20T01:14:55.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="基础">基础</h1>
<h2 id="1-第一个vue案例">1. 第一个Vue案例</h2>
<pre><code class="language-js">  &lt;div id=&quot;root&quot;&gt;
      &lt;h1&gt;Hello，{{name.toUpperCase()}}，{{address}}&lt;/h1&gt;
    &lt;/div&gt;
 
 new Vue({
        el: &quot;#root&quot;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。id选择器，也可以用类选择器。
        data: {
          //data中用于存储数据，数据供el所指定的容器去使用!!，值我们暂时先写成一个对象。
          name: &quot;rowanWang&quot;,
          address: &quot;Suizhou&quot;,
        },
      });
</code></pre>
<p>1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；<br>
2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；<br>
3.root容器里的代码被称为<strong>Vue模板</strong>；<br>
4.Vue实例和容器是一一对应的（类名相同的容器，vue只会接管第一个；多个vue尝试接管同一个容器，也只能第一个vue接管）；<br>
5.真实开发中只有<strong>一个Vue实例</strong>，会配合着组件一起使用；<br>
6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；<br>
7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p>
<blockquote>
<p>注意区分：js表达式 和 js代码(语句)<br>
1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：<br>
(1). a<br>
(2). a+b<br>
(3). demo(1)<br>
(4). x === y ? 'a' : 'b'<br>
2.js代码(语句)<br>
(1). if(){}<br>
(2). for(){}</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h1 id="基础">基础</h1>
<h2 id="1-第一个vue案例">1. 第一个Vue案例</h2>
<pre><code class="language-js">  &lt;div id=&quot;root&quot;&gt;
      &lt;h1&gt;Hello，{{name.toUpperCase()}}，{{address}}&lt;/h1&gt;
    &lt;/div&gt;
 
 new Vue({
        el: &quot;#root&quot;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。id选择器，也可以用类选择器。
        data: {
          //data中用于存储数据，数据供el所指定的容器去使用!!，值我们暂时先写成一个对象。
          name: &quot;rowanWang&quot;,
          address: &quot;Suizhou&quot;,
        },
      });
</code></pre>
<p>1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；<br>
2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；<br>
3.root容器里的代码被称为<strong>Vue模板</strong>；<br>
4.Vue实例和容器是一一对应的（类名相同的容器，vue只会接管第一个；多个vue尝试接管同一个容器，也只能第一个vue接管）；<br>
5.真实开发中只有<strong>一个Vue实例</strong>，会配合着组件一起使用；<br>
6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；<br>
7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p>
<blockquote>
<p>注意区分：js表达式 和 js代码(语句)<br>
1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方：<br>
(1). a<br>
(2). a+b<br>
(3). demo(1)<br>
(4). x === y ? 'a' : 'b'<br>
2.js代码(语句)<br>
(1). if(){}<br>
(2). for(){}</p>
</blockquote>
<!-- more -->
<h2 id="2-模版语法">2. 模版语法</h2>
<p>Vue接管的容器的那一部分html代码叫做vue模版。<br>
模版语法分为插值语法和指令语法。<br>
Vue模板语法有2大类：<br>
<strong>1.插值语法</strong>：</p>
<ul>
<li>功能：用于解析标签体内容。</li>
<li>写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。<br>
<strong>2.指令语法</strong>：</li>
<li>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。</li>
<li>举例：v-bind:href=&quot;xxx&quot; 或  简写为 :href=&quot;xxx&quot;，xxx同样要写js表达式，<br>
且可以直接读取到data中的所有属性。</li>
<li>备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。</li>
</ul>
<pre><code class="language-js">&lt;div id=&quot;main&quot;&gt;
      &lt;h1&gt;Rowan's Vue Project&lt;/h1&gt;
      &lt;hr /&gt;
      &lt;!-- 插值语法 --&gt;
      &lt;p&gt;My name is {{name.toUpperCase()}}, I'm {{age}} years old.&lt;/p&gt;
      &lt;hr /&gt;
      &lt;!-- 指令语法 --&gt;
      &lt;a v-bind:href=&quot;website.url&quot;
        &gt;Please visit my website : {{website.name}}&lt;/a
      &gt;
    &lt;/div&gt;
    &lt;script&gt;
      Vue.config.productionTip = false;
      new Vue({
        el: &quot;#main&quot;,
        data: {
          name: &quot;Rowan&quot;,
          age: 22,
          website: {
            url: &quot;http://rowanwang.tech&quot;,
            name: `Rowan's Page`, //有重名的key，使用多层数据
          },
        },
      });
    &lt;/script&gt;
</code></pre>
<h2 id="3-数据绑定">3. 数据绑定</h2>
<p>Vue中有2种数据绑定的方式：<br>
1.单向绑定(v-bind)：数据只能从data流向页面。<br>
2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。<br>
备注：<br>
并不是所有元素都可以使用v-model或者v-bind<br>
1.双向绑定一般都应用在表单类元素上（如：input、select等）<br>
2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p>
<h2 id="4-el和data的两种写法">4. el和data的两种写法</h2>
<p>data与el的2种写法<br>
1.el有2种写法<br>
(1).new Vue时候配置el属性。<br>
(2).先创建Vue实例，随后再通过vm.$mount('#root')指定el的值。<br>
2.data有2种写法<br>
(1).对象式<br>
(2).函数式<br>
如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。<br>
3.一个重要的原则：<br>
由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了，因为箭头函数没有自己的this。</p>
<pre><code class="language-js">//el的两种写法
/* const v = new Vue({
    //el:'#root', //第一种写法
    data:{
        name:'尚硅谷'
    }
})
console.log(v)
v.$mount('#root') //第二种写法 */

//data的两种写法
new Vue({
    el:'#root',
    //data的第一种写法：对象式
    /* data:{
        name:'尚硅谷'
    } */

    //data的第二种写法：函数式
    data(){  // 是从data:function(){简写而来
        console.log('@@@',this) //此处的this是Vue实例对象
        return{
            name:'尚硅谷'
        }
    }
})
</code></pre>
<h2 id="5-mvvm模型">5. MVVM模型</h2>
<p>Model-View-Viewmodel<br>
<img src="https://rowanwang6.github.io/post-images/1665448532687.png" alt="" loading="lazy"><br>
<img src="https://rowanwang6.github.io/post-images/1665448635904.png" alt="" loading="lazy"><br>
<img src="https://rowanwang6.github.io/post-images/1695113514117.png" alt="" loading="lazy"><br>
MVVM模型</p>
<ol>
<li>M：模型(Model) ：data中的数据</li>
<li>V：视图(View) ：模板代码</li>
<li>VM：视图模型(ViewModel)：Vue实例，一般用<code>vm</code>接收vue实例<br>
观察发现：<br>
1.data中所有的属性，最后都出现在了vm身上。<br>
2.vm身上所有的属性及Vue原型上所有属性，在Vue模板中都可以直接使用。(例如$emit, _isVue等等)</li>
</ol>
<h2 id="6-数据代理">6. 数据代理</h2>
<h3 id="61-回顾objectdefineproperty">6.1 回顾Object.defineProperty</h3>
<p>利用getter和setter实现。</p>
<pre><code class="language-js">let number = 18
let person = {
    name:'张三',
    sex:'男',
}

Object.defineProperty(person,'age',{
    // value:18,
    // enumerable:true, //控制属性是否可以枚举，默认值是false
    // writable:true, //控制属性是否可以被修改，默认值是false
    // configurable:true //控制属性是否可以被删除，默认值是false

    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
    get(){
        console.log('有人读取age属性了')
        return number
    },

    //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值
    set(value){
        console.log('有人修改了age属性，且值是',value)
        number = value
    }
})
// console.log(Object.keys(person))
console.log(person)
</code></pre>
<h3 id="62-数据代理">6.2 数据代理</h3>
<pre><code class="language-js">&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt;
let obj = {x:100}
let obj2 = {y:200}

Object.defineProperty(obj2,'x',{
    get(){
        return obj.x
    },
    set(value){
        obj.x = value
    }
})
</code></pre>
<h3 id="63-vue中的数据代理">6.3 Vue中的数据代理</h3>
<p>1.Vue中的数据代理：<br>
通过vm对象来代理data对象中属性的操作（读/写）<br>
2.Vue中数据代理的好处：<br>
更加方便的操作data中的数据<br>
3.基本原理：<br>
通过Object.defineProperty()把data对象中所有属性添加到vm上。<br>
为每一个添加到vm上的属性，都指定一个getter/setter。<br>
在getter/setter内部去操作（读/写）data中对应的属性。</p>
<h2 id="7-事件处理">7. 事件处理</h2>
<h3 id="71-基本事件处理">7.1 基本事件处理</h3>
<p>事件的基本使用：<br>
1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；<br>
2.事件的回调需要配置在methods对象中，最终会在vm上；<br>
3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；<br>
4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；<br>
5.@click=&quot;demo&quot; 和 @click=&quot;demo($event, args)&quot; 效果一致，但后者可以传参； event.target.innerHTML可以查看button的内容。<br>
6.函数不要写在data里，否则vue会给函数创建没有必要的数据代理；</p>
<h3 id="72-事件修饰符">7.2 事件修饰符</h3>
<pre><code class="language-js">&lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;
</code></pre>
<p>Vue中的事件修饰符：<br>
1.prevent：阻止默认事件（常用）；<br>
2.stop：阻止事件冒泡（常用）；<br>
3.once：事件只触发一次（常用）；<br>
4.capture：使用事件的捕获模式；<br>
5.self：只有event.target是当前操作的元素时才触发事件；<br>
6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p>
<h3 id="73-键盘事件">7.3 键盘事件</h3>
<p>1.Vue中常用的按键别名：<br>
回车 =&gt; enter<br>
删除 =&gt; delete (捕获“删除”和“退格”键)<br>
退出 =&gt; esc<br>
空格 =&gt; space<br>
换行 =&gt; tab (特殊，必须配合keydown去使用)<br>
上 =&gt; up<br>
下 =&gt; down<br>
左 =&gt; left<br>
右 =&gt; right<br>
2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）<br>
3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</p>
<ul>
<li>配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</li>
<li>配合keydown使用：正常触发事件。<br>
4.也可以使用keyCode去指定具体的按键（不推荐）<br>
5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名<br>
6.系统修饰键可以连用<code>@keydown.ctrl.y=&quot;showInfo&quot;</code></li>
</ul>
<h2 id="8-计算属性">8. 计算属性</h2>
<p>data数据内发生改变，vue会重新解析模板，重新调用函数。<br>
计算属性：<br>
1.定义：要用的属性不存在，要通过已有属性计算得来。<br>
2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。<br>
3.get函数什么时候执行？</p>
<ul>
<li>初次读取时会执行一次。</li>
<li>当依赖的数据发生改变时会被再次调用。</li>
</ul>
<p>4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。<br>
5.备注：</p>
<ul>
<li>计算属性最终会出现在vm上，直接读取使用即可。</li>
<li>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</li>
</ul>
<pre><code class="language-js">computed:{
        //完整写法
        /* fullName:{
            get(){
                console.log('get被调用了')
                return this.firstName + '-' + this.lastName
            },
            set(value){
                console.log('set',value)
                const arr = value.split('-')
                this.firstName = arr[0]
                this.lastName = arr[1]
            }
        } */
        //简写
        fullName(){// 并不是函数！ 还是计算出来的属性
            console.log('get被调用了')
            return this.firstName + '-' + this.lastName
        }
    }
</code></pre>
<h2 id="9-监视属性">9. 监视属性</h2>
<h3 id="91-监视属性">9.1 监视属性</h3>
<p>监视属性watch：<br>
1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作<br>
2.监视的属性必须存在，才能进行监视！！<br>
3.监视的两种写法：</p>
<ul>
<li>new Vue时传入watch配置</li>
<li>通过vm.$watch监视</li>
</ul>
<h3 id="92-深度监视">9.2 深度监视</h3>
<p>深度监视：</p>
<ul>
<li>Vue中的watch默认不监测对象内部值的改变（一层）。</li>
<li>配置deep:true可以监测对象内部值改变（多层）。<br>
备注：</li>
<li>Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！</li>
<li>使用watch时根据数据的具体结构，决定是否采用深度监视。</li>
</ul>
<h3 id="93-监视属性简写">9.3 监视属性简写</h3>
<pre><code class="language-js">watch:{
//正常写法
/* isHot:{
    // immediate:true, //初始化时让handler调用一下
    // deep:true,//深度监视
    handler(newValue,oldValue){
        console.log('isHot被修改了',newValue,oldValue)
    }
}, */
//简写
/* isHot(newValue,oldValue){
    console.log('isHot被修改了',newValue,oldValue,this)
} */
}
})

//正常写法
/* vm.$watch('isHot',{
immediate:true, //初始化时让handler调用一下
deep:true,//深度监视
handler(newValue,oldValue){
console.log('isHot被修改了',newValue,oldValue)
}
}) */

//简写
/* vm.$watch('isHot',(newValue,oldValue)=&gt;{
console.log('isHot被修改了',newValue,oldValue,this)
}) */
</code></pre>
<h3 id="94-computed和watch的区别">9.4 computed和watch的区别</h3>
<p>computed和watch之间的区别：<br>
1.computed能完成的功能，watch都可以完成。<br>
2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。<br>
两个重要的小原则：<br>
1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。<br>
2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</p>
<h2 id="10-绑定样式">10. 绑定样式</h2>
<p>绑定样式：</p>
<ol>
<li>class样式<br>
写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。<br>
字符串写法适用于：类名不确定，要动态获取。<br>
对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。<br>
数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</li>
<li>style样式<br>
:style=&quot;{fontSize: xxx}&quot;其中xxx是动态值。<br>
:style=&quot;[a,b]&quot;其中a、b是样式对象。</li>
</ol>
<h2 id="11-条件渲染">11. 条件渲染</h2>
<p>条件渲染：<br>
1.v-if<br>
写法：<br>
(1).v-if=&quot;表达式&quot;<br>
(2).v-else-if=&quot;表达式&quot;<br>
(3).v-else=&quot;表达式&quot;<br>
适用于：切换频率较低的场景。<br>
特点：不展示的DOM元素直接被移除。<br>
注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p>
<p>2.v-show<br>
写法：v-show=&quot;表达式&quot;<br>
适用于：切换频率较高的场景。<br>
特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p>
<p>3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p>
<h2 id="12-列表渲染">12. 列表渲染</h2>
<h3 id="121-基本列表">12.1 基本列表</h3>
<p>v-for指令:<br>
1.用于展示列表数据<br>
2.语法：v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;<br>
3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p>
<h3 id="122-key的原理">12.2 key的原理</h3>
<p>面试题：react、vue中的key有什么作用？（key的内部原理）</p>
<ol>
<li>
<p>虚拟DOM中key的作用：<br>
key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,<br>
随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
</li>
<li>
<p>对比规则：<br>
(1).旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>
①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>
②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。<br>
(2).旧虚拟DOM中未找到与新虚拟DOM相同的key<br>
创建新的真实DOM，随后渲染到到页面。</p>
</li>
<li>
<p>用index作为key可能会引发的问题：</p>
</li>
</ol>
<ul>
<li>若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>
会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</li>
<li>如果结构中还包含输入类的DOM：<br>
会产生错误DOM更新 ==&gt; 界面有问题。</li>
</ul>
<ol start="4">
<li>开发中如何选择key?<br>
1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>
2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>
使用index作为key是没有问题的。</li>
</ol>
<h3 id="123-列表过滤">12.3 列表过滤</h3>
<pre><code class="language-js">//用watch实现
//#region 
/* new Vue({
    el:'#root',
    data:{
        keyWord:'',
        persons:[
            {id:'001',name:'马冬梅',age:19,sex:'女'},
            {id:'002',name:'周冬雨',age:20,sex:'女'},
            {id:'003',name:'周杰伦',age:21,sex:'男'},
            {id:'004',name:'温兆伦',age:22,sex:'男'}
        ],
        filPerons:[]
    },
    watch:{
        keyWord:{
            immediate:true,
            handler(val){
                this.filPerons = this.persons.filter((p)=&gt;{
                    return p.name.indexOf(val) !== -1
                })
            }
        }
    }
}) */
//#endregion

//用computed实现
new Vue({
    el:'#root',
    data:{
        keyWord:'',
        persons:[
            {id:'001',name:'马冬梅',age:19,sex:'女'},
            {id:'002',name:'周冬雨',age:20,sex:'女'},
            {id:'003',name:'周杰伦',age:21,sex:'男'},
            {id:'004',name:'温兆伦',age:22,sex:'男'}
        ]
    },
    computed:{
        filPerons(){
            return this.persons.filter((p)=&gt;{
                return p.name.indexOf(this.keyWord) !== -1
            })
        }
    }
}) 
</code></pre>
<h3 id="124-列表排序">12.4 列表排序</h3>
<pre><code class="language-js">new Vue({
    el:'#root',
    data:{
        keyWord:'',
        sortType:0, //0原顺序 1降序 2升序
        persons:[
            {id:'001',name:'马冬梅',age:30,sex:'女'},
            {id:'002',name:'周冬雨',age:31,sex:'女'},
            {id:'003',name:'周杰伦',age:18,sex:'男'},
            {id:'004',name:'温兆伦',age:19,sex:'男'}
        ]
    },
    computed:{
        filPerons(){
            const arr = this.persons.filter((p)=&gt;{
                return p.name.indexOf(this.keyWord) !== -1
            })
            //判断一下是否需要排序
            if(this.sortType){
                arr.sort((p1,p2)=&gt;{
                    return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age
                })
            }
            return arr
        }
    }
}) 
</code></pre>
<h3 id="125-vue监视数据的总结">12.5 Vue监视数据的总结</h3>
<p>Vue监视数据的原理：</p>
<ol>
<li>
<p>vue会监视data中所有层次的数据。</p>
</li>
<li>
<p>如何监测对象中的数据？<br>
通过setter实现监视，且要在new Vue时就传入要监测的数据。<br>
(1).对象中后追加的属性，Vue默认不做响应式处理<br>
(2).如需给后添加的属性做响应式，请使用如下API：<br>
Vue.set(target，propertyName/index，value) 或<br>
vm.$set(target，propertyName/index，value)</p>
</li>
<li>
<p>如何监测数组中的数据？<br>
通过包裹数组更新元素的方法实现，本质就是做了两件事：<br>
(1).调用原生对应的方法对数组进行更新。<br>
(2).重新解析模板，进而更新页面。</p>
</li>
</ol>
<p>4.在Vue修改数组中的某个元素一定要用如下方法：<br>
1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()<br>
2.Vue.set() 或 vm.$set()</p>
<p>数据劫持：给data分配getter和setter，当有人试图更改数据时，setter出面。// 待补充<br>
特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！</p>
<h2 id="13-收集表单数据">13. 收集表单数据</h2>
<p>收集表单数据：<br>
若：<code>&lt;input type=&quot;text&quot;/&gt;</code>，则v-model收集的是value值，用户输入的就是value值。<br>
若：<code>&lt;input type=&quot;radio&quot;/&gt;</code>，则v-model收集的是value值，且要给标签配置value值。<br>
若：<code>&lt;input type=&quot;checkbox&quot;/&gt;</code><br>
1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>
2.配置input的value属性:<br>
(1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）<br>
(2)v-model的初始值是数组，那么收集的的就是value组成的数组<br>
备注：v-model的三个修饰符：<br>
lazy：失去焦点再收集数据<br>
number：输入字符串转为有效的数字<br>
trim：输入首尾空格过滤</p>
<h2 id="14-过滤器vue3中已移除">14. 过滤器（vue3中已移除）</h2>
<p>过滤器：<br>
定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。<br>
语法：<br>
1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}<br>
2.使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;<br>
备注：<br>
1.过滤器也可以接收额外参数、多个过滤器也可以串联<br>
2.并没有改变原本的数据, 是产生新的对应的数据</p>
<h2 id="15-vue常见的内置指令">15. vue常见的内置指令</h2>
<ul>
<li>v-bind	: 单向绑定解析表达式, 可简写为 <code>:xxx</code></li>
<li>v-model	: 双向数据绑定</li>
<li>v-for  	: 遍历数组/对象/字符串</li>
<li>v-on   	: 绑定事件监听, 可简写为@</li>
<li>v-if 	 	: 条件渲染（动态控制节点是否存存在）</li>
<li>v-else 	: 条件渲染（动态控制节点是否存存在）</li>
<li>v-show 	: 条件渲染 (动态控制节点是否展示)</li>
</ul>
<p>v-text指令：<br>
1.作用：向其所在的节点中渲染文本内容。<br>
2.与插值语法的区别：v-text会替换掉节点中的内容，插值语法{{xx}}则不会（用的更多）。</p>
<p>v-html指令：<br>
1.作用：向指定节点中渲染包含html结构的内容。<br>
2.与插值语法的区别：<br>
(1).v-html会替换掉节点中所有的内容，{{xx}}则不会。<br>
(2).v-html可以识别html结构。<br>
3.严重注意：v-html有安全性问题！！！！<br>
(1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p>
<p>v-cloak指令（没有值）：<br>
1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。<br>
2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。</p>
<p>v-once指令：<br>
1.v-once所在节点在初次动态渲染后，就视为静态内容了。<br>
2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p>
<p>v-pre指令：<br>
1.跳过其所在节点的编译过程。<br>
2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p>
<h2 id="16-vue的自定义指令">16. Vue的自定义指令</h2>
<p>element是绑定的元素，binding是绑定的信息</p>
<pre><code class="language-js">//big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。
big(element, binding) {//相当于只写了bind和update 
    // console.log(&quot;big&quot;, this); //注意此处的this是window
    // console.log('big')
    element.innerText = binding.value * 10;
}
</code></pre>
<pre><code class="language-js">fbind: {
//指令与元素成功绑定时（一上来）
bind(element, binding) {
    element.value = binding.value;
},
//指令所在元素被插入页面时
inserted(element, binding) {
    element.focus();
},
//指令所在的模板被重新解析时
update(element, binding) {
    element.value = binding.value;
},
},
</code></pre>
<p>自定义指令总结：<br>
一、定义语法：<br>
(1).局部指令：</p>
<pre><code class="language-js">new Vue({														
    directives:{指令名:配置对象} 
}) 								
或
new Vue({			
    directives{指令名:回调函数}
})
</code></pre>
<p>(2).全局指令：<br>
Vue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)</p>
<p>二、配置对象中常用的3个回调：<br>
(1).bind：指令与元素成功绑定时调用。<br>
(2).inserted：指令所在元素被插入页面时调用。<br>
(3).update：指令所在模板结构被重新解析时调用。</p>
<p>三、备注：<br>
1.指令定义时不加v-，但使用时要加v-；<br>
2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。大写读不出来，且如果是v-big-number，directives里key要加引号。</p>
<h2 id="17-生命周期">17. 生命周期</h2>
<p>生命周期：<br>
1.又名：生命周期回调函数、生命周期函数、生命周期钩子。<br>
2.是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。<br>
3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。<br>
4.生命周期函数中的this指向是vm 或 组件实例对象。<br>
<img src="https://rowanwang6.github.io/post-images/1665852600838.png" alt="" loading="lazy"></p>
<p>常用的生命周期钩子：<br>
1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。<br>
2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p>
<p>关于销毁Vue实例<br>
1.销毁后借助Vue开发者工具看不到任何信息。<br>
2.销毁后自定义事件会失效，但原生DOM事件依然有效。<br>
3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p>
<h2 id="18-非单文件组件">18. 非单文件组件：</h2>
<p>一个文件中包含有n个组件<br>
Vue中使用组件的三大步骤：<br>
一、定义组件(创建组件)<br>
二、注册组件<br>
三、使用组件(写组件标签)</p>
<p>一、如何定义一个组件？<br>
使用<code>Vue.extend(options)</code>创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；<br>
区别如下：<br>
1.el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。<br>
2.data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。<br>
备注：使用template可以配置组件结构。</p>
<p>二、如何注册组件？<br>
1.局部注册：靠new Vue的时候传入components选项<br>
2.全局注册：靠Vue.component('组件名',组件)</p>
<p>三、编写组件标签：<br>
<code>&lt;school&gt;&lt;/school&gt;</code></p>
<h3 id="181-几个注意点">18.1 几个注意点</h3>
<p>1.关于组件名:<br>
一个单词组成：<br>
第一种写法(首字母小写)：school<br>
第二种写法(首字母大写)：School<br>
多个单词组成：<br>
第一种写法(kebab-case命名)：my-school<br>
第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)<br>
备注：<br>
(1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。<br>
(2).可以使用name配置项指定组件在开发者工具中呈现的名字。</p>
<p>2.关于组件标签:<br>
第一种写法：<school></school><br>
第二种写法：<school/><br>
备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。</p>
<p>3.一个简写方式：<br>
const school = Vue.extend(options) 可简写为：const school = options</p>
<h3 id="182-vue的嵌套">18.2 Vue的嵌套</h3>
<pre><code class="language-js">	//定义student组件
		const student = Vue.extend({
			name:'student',
			template:`
				&lt;div&gt;
					&lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt;	
					&lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt;	
				&lt;/div&gt;
			`,
			data(){
				return {
					name:'尚硅谷',
					age:18
				}
			}
		})
		
		//定义school组件
		const school = Vue.extend({
			name:'school',
			template:`
				&lt;div&gt;
					&lt;h2&gt;学校名称：{{name}}&lt;/h2&gt;	
					&lt;h2&gt;学校地址：{{address}}&lt;/h2&gt;	
					&lt;student&gt;&lt;/student&gt;
				&lt;/div&gt;
			`,
			data(){
				return {
					name:'尚硅谷',
					address:'北京'
				}
			},
			//注册组件（局部）
			components:{
				student
			}
		})

		//定义hello组件
		const hello = Vue.extend({
			template:`&lt;h1&gt;{{msg}}&lt;/h1&gt;`,
			data(){
				return {
					msg:'欢迎来到尚硅谷学习！'
				}
			}
		})
		
		//定义app组件
		const app = Vue.extend({
			template:`
				&lt;div&gt;	
					&lt;hello&gt;&lt;/hello&gt;
					&lt;school&gt;&lt;/school&gt;
				&lt;/div&gt;
			`,
			components:{
				school,
				hello
			}
		})

		//创建vm
		new Vue({
			template:'&lt;app&gt;&lt;/app&gt;',
			el:'#root',
			//注册组件（局部）
			components:{app}
		})
</code></pre>
<h3 id="183-vuecomponent">18.3 VueComponent</h3>
<p>关于VueComponent：<br>
1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。</p>
<p>2.我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，<br>
即Vue帮我们执行的：new VueComponent(options)。</p>
<p>3.特别注意：每次调用Vue.extend，<strong>返回的都是一个全新的VueComponent！！！！</strong></p>
<p>4.关于this指向：<br>
(1).组件配置中：<br>
data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。<br>
(2).new Vue(options)配置中：<br>
data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</p>
<p>5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。<br>
Vue的实例对象，以后简称vm。</p>
<h3 id="184-内置关系">18.4 内置关系</h3>
<p>1.一个重要的内置关系：<code>VueComponent.prototype.__proto__ === Vue.prototype</code><br>
2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</p>
<p>显式原型属性<code>prototype</code>只有函数才可以拥有，new得到的实例只有<code>__proto__</code>隐式原型属性<br>
实例的隐式原型属性，永远指向自己的缔造者的原型对象。</p>
<pre><code class="language-js">	//定义一个构造函数
	 function Demo(){
			this.a = 1
			this.b = 2
		}
		//创建一个Demo的实例对象
		const d = new Demo()

		console.log(Demo.prototype) //显示原型属性

		console.log(d.__proto__) //隐式原型属性

		console.log(Demo.prototype === d.__proto__)

		//程序员通过显示原型属性操作原型对象，追加一个x属性，值为99
		Demo.prototype.x = 99

		console.log('@',d) 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://rowanwang6.github.io/post-images/1665901545808.png" alt="" loading="lazy"></figure>
<h2 id="19-单文件组件">19. 单文件组件</h2>
<p>非单文件样式不能跟着组件走</p>
<h2 id="20-vue脚手架">20. Vue脚手架</h2>
<p>render<br>
关于不同版本的Vue：</p>
<p>1.vue.js与vue.runtime.xxx.js的区别：<br>
(1).vue.js是完整版的Vue，包含：核心功能+模板解析器。<br>
(2).vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</p>
<p>2.因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用<br>
render函数接收到的createElement函数去指定具体内容。</p>
<h3 id="201-vueconfigjs配置文件">20.1 vue.config.js配置文件</h3>
<ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh</li>
</ol>
<h2 id="21-脚手架文件结构">21. 脚手架文件结构</h2>
<p>├── node_modules<br>
├── public<br>
│   ├── favicon.ico: 页签图标<br>
│   └── index.html: 主页面<br>
├── src<br>
│   ├── assets: 存放静态资源<br>
│   │   └── logo.png<br>
│   │── component: 存放组件<br>
│   │   └── HelloWorld.vue<br>
│   │── App.vue: 汇总所有组件<br>
│   │── main.js: 入口文件<br>
├── .gitignore: git版本管制忽略的配置<br>
├── babel.config.js: babel的配置文件<br>
├── package.json: 应用包配置文件<br>
├── README.md: 应用描述文件<br>
├── package-lock.json：包版本控制文件</p>
<h2 id="22-ref属性">22. ref属性</h2>
<ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：</li>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
<h2 id="23-props配置项">23.  props配置项</h2>
<ol>
<li>功能：让组件接收外部传过来的数据</li>
<li>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></li>
<li>接收数据：<br>
第一种方式（只接收）：<code>props:['name'] </code><br>
第二种方式（限制类型）：<code>props:{name:String}</code><br>
第三种方式（限制类型、限制必要性、指定默认值）：</li>
</ol>
<pre><code class="language-js">props:{
name:{
type:String, //类型
required:true, //必要性
default:'老王' //默认值
}
}
</code></pre>
<p>备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中一份，然后去修改 data 中的数据。</p>
<h2 id="24-mixin混合-复用">24. mixin混合 复用</h2>
<ol>
<li>功能：可以把多个组件共用的配置提取成一个混入对象</li>
<li>使用方式：<br>
第一步定义混合：</li>
</ol>
<pre><code>{
data(){....},
methods:{....}
....
}
</code></pre>
<p>第二步使用混入：<br>
​全局混入：<code>Vue.mixin(xxx)</code><br>
​局部混入：<code>mixins:['xxx'] </code></p>
<h2 id="25-插件">25. 插件</h2>
<ol>
<li>功能：用于增强 Vue</li>
<li>本质：包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据。</li>
<li>定义插件：</li>
</ol>
<pre><code class="language-js">对象.install = function (Vue, options) {
// 1. 添加全局过滤器
Vue.filter(....)

// 2. 添加全局指令
Vue.directive(....)

// 3. 配置全局混入(合)
Vue.mixin(....)

// 4. 添加实例方法
Vue.prototype.$myMethod = function () {...}
Vue.prototype.$myProperty = xxxx
}
</code></pre>
<ol start="4">
<li>使用插件：<code>Vue.use()</code></li>
</ol>
<h2 id="26-todolist-案例">26. toDoList 案例</h2>
<ol>
<li>组件化编码流程：<br>
(1).拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突。<br>
​(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</li>
</ol>
<ul>
<li>一个组件在用：放在组件自身即可。</li>
<li>一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。<br>
​(3).实现交互：从绑定事件开始。</li>
</ul>
<ol start="2">
<li>props 适用于：<br>
​(1).父组件 ==&gt; 子组件 通信<br>
(2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数），通过传参形式，将参数传给父</li>
<li>使用 v-model 时要切记：v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！</li>
<li>props 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做。</li>
</ol>
<h2 id="27-浏览器本地存储-webstoragelocalstorage-sessionstorage">27. 浏览器本地存储 webStorage(localStorage, sessionStorage)</h2>
<ol>
<li>存储内容大小一般支持 5MB 左右（不同浏览器可能还不一样）</li>
<li>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</li>
<li>相关 API：</li>
</ol>
<ul>
<li><code>xxxxxStorage.setItem('key', 'value');</code><br>
该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</li>
<li><code>xxxxxStorage.getItem('person');</code><br>
​该方法接受一个键名作为参数，返回键名对应的值。</li>
<li><code>xxxxxStorage.removeItem('key');</code><br>
​该方法接受一个键名作为参数，并把该键名从存储中删除。</li>
<li><code> xxxxxStorage.clear()</code><br>
​该方法会清空存储中的所有数据。</li>
</ul>
<ol start="4">
<li>备注：</li>
</ol>
<ul>
<li>SessionStorage 存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage 存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null。</li>
<li><code>JSON.parse(null)</code>的结果依然是 null。</li>
</ul>
<h2 id="28-组件自定义事件">28. 组件自定义事件</h2>
<ol>
<li>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></li>
<li>使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（<span style="color:red">事件的回调在 A 中</span>）。</li>
<li>绑定自定义事件：</li>
</ol>
<ul>
<li>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code> 或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></li>
<li>第二种方式，在父组件中：</li>
</ul>
<pre><code class="language-js">&lt;Demo ref=&quot;demo&quot;/&gt;
......
mounted(){
    this.$refs.xxx.$on('atguigu',this.test)
}
</code></pre>
<ul>
<li>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</li>
</ul>
<ol start="4">
<li>
<p>触发自定义事件：<code>this.$emit('atguigu',数据)</code></p>
</li>
<li>
<p>解绑自定义事件<code>this.$off('atguigu')</code></p>
</li>
<li>
<p>组件上也可以绑定原生 DOM 事件，需要使用<code>native</code>修饰符。</p>
</li>
<li>
<p>注意：通过<code>this.$refs.xxx.$on('atguigu',回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在 methods 中</span>，<span style="color:red">要么用箭头函数</span>，否则 this 指向会出问题！</p>
</li>
</ol>
<h2 id="29-全局事件总线">29. 全局事件总线</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>安装全局事件总线：</p>
<pre><code class="language-js">new Vue({
	......
	beforeCreate() {
		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
	},
    ......
})
</code></pre>
</li>
<li>
<p>使用事件总线：</p>
<ol>
<li>
<p>接收数据：A 组件想接收数据，则在 A 组件中给$bus 绑定自定义事件，事件的<span style="color:red">回调留在 A 组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.$bus.$on('xxxx',this.demo)
}
</code></pre>
</li>
<li>
<p>提供数据：<code>this.$bus.$emit('xxxx',数据)</code></p>
</li>
</ol>
</li>
<li>
<p>最好在 beforeDestroy 钩子中，用$off 去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="30-消息订阅与发布pubsub">30. 消息订阅与发布（pubsub）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>使用步骤：</p>
<ol>
<li>
<p>安装 pubsub：<code>npm i pubsub-js</code></p>
</li>
<li>
<p>引入: <code>import pubsub from 'pubsub-js'</code></p>
</li>
<li>
<p>接收数据：A 组件想接收数据，则在 A 组件中订阅消息，订阅的<span style="color:red">回调留在 A 组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息
}
</code></pre>
</li>
<li>
<p>提供数据：<code>pubsub.publish('xxx',数据)</code></p>
</li>
<li>
<p>最好在 beforeDestroy 钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="31-nexttick">31. $nextTick</h2>
<ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行。</li>
</ol>
<h2 id="32-vue-封装的过度与动画">32. Vue 封装的过度与动画</h2>
<ol>
<li>
<p>作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li>
<p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" /></p>
</li>
<li>
<p>写法：</p>
<ol>
<li>
<p>准备好样式：</p>
<ul>
<li>元素进入的样式：
<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：
<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li>
<p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置 name 属性：</p>
<pre><code class="language-vue">&lt;transition name=&quot;hello&quot;&gt;
	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;
</code></pre>
</li>
<li>
<p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="33-vue-脚手架配置代理">33. vue 脚手架配置代理</h2>
<h3 id="方法一">方法一</h3>
<p>在 vue.config.js 中添加如下配置：</p>
<pre><code class="language-js">devServer: {
  proxy: &quot;http://localhost:5000&quot;;
}
</code></pre>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二">方法二</h3>
<p>编写 vue.config.js 配置具体代理规则：</p>
<pre><code class="language-js">module.exports = {
  devServer: {
    proxy: {
      &quot;/api1&quot;: {
        // 匹配所有以 '/api1'开头的请求路径
        target: &quot;http://localhost:5000&quot;, // 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: { &quot;^/api1&quot;: &quot;&quot; },
      },
      &quot;/api2&quot;: {
        // 匹配所有以 '/api2'开头的请求路径
        target: &quot;http://localhost:5001&quot;, // 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: { &quot;^/api2&quot;: &quot;&quot; },
      },
    },
  },
};
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
</code></pre>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="34-插槽">34. 插槽</h2>
<h3 id="插槽">插槽</h3>
<ol>
<li>作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。<br>
<img src="https://rowanwang6.github.io/post-images/1666246726348.png" alt="" loading="lazy"></li>
<li>分类：默认插槽、具名插槽、作用域插槽</li>
<li>使用方法</li>
</ol>
<ul>
<li>默认插槽：</li>
</ul>
<pre><code class="language-js">父组件中：
&lt;Category&gt;
            &lt;div&gt;html结构1&lt;/div&gt;
        &lt;/Category&gt;
子组件中：
&lt;template&gt;
&lt;div&gt;
    &lt;!-- 定义插槽 --&gt;
    &lt;slot&gt;插槽默认内容...&lt;/slot&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>具名插槽：</li>
</ul>
<pre><code class="language-js">父组件中：
&lt;Category&gt;
            &lt;template slot=&quot;center&quot;&gt;
            &lt;div&gt;html结构1&lt;/div&gt;
            &lt;/template&gt;

            &lt;template v-slot:footer&gt;
                &lt;div&gt;html结构2&lt;/div&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
&lt;template&gt;
&lt;div&gt;
    &lt;!-- 定义插槽 --&gt;
    &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;
    &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>作用域插槽：</li>
</ul>
<ol>
<li>
<p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定）</p>
</li>
<li>
<p>具体编码：</p>
</li>
</ol>
<pre><code class="language-js">父组件中：
&lt;Category&gt;
        &lt;template scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是ul列表 --&gt;
            &lt;ul&gt;
                &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/template&gt;
    &lt;/Category&gt;

&lt;Category&gt;
        &lt;template slot-scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是h4标题 --&gt;
            &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/h4&gt;
        &lt;/template&gt;
    &lt;/Category&gt;
子组件中：
&lt;template&gt;
&lt;div&gt;
    &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
name: &quot;Category&quot;,
props: [&quot;title&quot;],
//数据在子组件自身
data() {
    return {
    games: [&quot;红色警戒&quot;, &quot;穿越火线&quot;, &quot;劲舞团&quot;, &quot;超级玛丽&quot;],
    };
},
};
&lt;/script&gt;
</code></pre>
<h2 id="35-vuex">35. Vuex</h2>
<p>vuex里 <code>this.$store.commit</code> 调用mutations  <code>this.$store.dispatch</code> 调用actions</p>
<h3 id="1-概念">1. 概念</h3>
<p>在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。<br>
<img src="https://rowanwang6.github.io/post-images/1666407209354.png" alt="" loading="lazy"></p>
<h3 id="2-何时使用">2. 何时使用？</h3>
<p>多个组件需要共享数据时。</p>
<h3 id="3-搭建-vuex-环境">3. 搭建 vuex 环境</h3>
<ol>
<li>
<p>创建文件：<code>src/store/index.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from &quot;vue&quot;;
//引入Vuex
import Vuex from &quot;vuex&quot;;
//应用Vuex插件
Vue.use(Vuex);

//准备actions对象——响应组件中用户的动作 dispatch调用
const actions = {};
//准备mutations对象——修改state中的数据 commit调用
const mutations = {};
//准备state对象——保存具体的数据
const state = {};

//创建并暴露store
export default new Vuex.Store({
  actions,
  mutations,
  state,
});
</code></pre>
</li>
<li>
<p>在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p>
<pre><code class="language-js">......
//引入store
import store from './store'
......

//创建vm
new Vue({
	el:'#app',
	render: h =&gt; h(App),
	store
})
</code></pre>
</li>
</ol>
<h3 id="4-基本使用">4. 基本使用</h3>
<ol>
<li>
<p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from &quot;vue&quot;;
//引入Vuex
import Vuex from &quot;vuex&quot;;
//引用Vuex
Vue.use(Vuex);

const actions = {
  //响应组件中加的动作
  jia(context, value) {
    // console.log('actions中的jia被调用了',miniStore,value)
    context.commit(&quot;JIA&quot;, value);
  },
};

const mutations = {
  //执行加
  JIA(state, value) {
    // console.log('mutations中的JIA被调用了',state,value)
    state.sum += value;
  },
};

//初始化数据
const state = {
  sum: 0,
};

//创建并暴露store
export default new Vuex.Store({
  actions,
  mutations,
  state,
});
</code></pre>
</li>
<li>
<p>组件中读取 vuex 中的数据：<code>$store.state.sum</code></p>
</li>
<li>
<p>组件中修改 vuex 中的数据：<code>$store.dispatch('action中的方法名',数据)</code> 或 <code>$store.commit('mutations中的方法名',数据)</code></p>
<blockquote>
<p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters-的使用">5. getters 的使用</h3>
<ol>
<li>
<p>概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工。</p>
</li>
<li>
<p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<pre><code class="language-js">......

const getters = {
	bigSum(state){
		return state.sum * 10
	}
}

//创建并暴露store
export default new Vuex.Store({
	......
	getters
})
</code></pre>
</li>
<li>
<p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个-map-方法的使用">6. 四个 map 方法的使用</h3>
<ol>
<li>
<p><strong>mapState 方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapState生成计算属性：sum、school、subject（对象写法）
     ...mapState({sum:'sum',school:'school',subject:'subject'}),

    //借助mapState生成计算属性：sum、school、subject（数组写法）
    ...mapState(['sum','school','subject']),
},
</code></pre>
</li>
<li>
<p><strong>mapGetters 方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapGetters生成计算属性：bigSum（对象写法）
    ...mapGetters({bigSum:'bigSum'}),

    //借助mapGetters生成计算属性：bigSum（数组写法）
    ...mapGetters(['bigSum'])
},
</code></pre>
</li>
<li>
<p><strong>mapActions 方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：incrementOdd、incrementWait（对象形式）
    ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})

    //靠mapActions生成：incrementOdd、incrementWait（数组形式）
    ...mapActions(['jiaOdd','jiaWait'])
}
</code></pre>
</li>
<li>
<p><strong>mapMutations 方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：increment、decrement（对象形式）
    ...mapMutations({increment:'JIA',decrement:'JIAN'}),

    //靠mapMutations生成：JIA、JIAN（对象形式）
    ...mapMutations(['JIA','JIAN']),
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化命名空间">7. 模块化+命名空间</h3>
<ol>
<li>
<p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li>
<p>修改<code>store.js</code></p>
<pre><code class="language-javascript">const countAbout = {
  namespaced:true,//开启命名空间
  state:{x:1},
  mutations: { ... },
  actions: { ... },
  getters: {
    bigSum(state){
       return state.sum * 10
    }
  }
}

const personAbout = {
  namespaced:true,//开启命名空间
  state:{ ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    countAbout,
    personAbout
  }
})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取 state 数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState('countAbout',['sum','school','subject']),
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取 getters 数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.getters['personAbout/firstPersonName']
//方式二：借助mapGetters读取：
...mapGetters('countAbout',['bigSum'])
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用 dispatch</p>
<pre><code class="language-js">//方式一：自己直接dispatch
this.$store.dispatch('personAbout/addPersonWang',person)
//方式二：借助mapActions：
...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用 commit</p>
<pre><code class="language-js">//方式一：自己直接commit
this.$store.commit('personAbout/ADD_PERSON',person)
//方式二：借助mapMutations：
...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),
</code></pre>
</li>
</ol>
<h2 id="36-路由">36. 路由</h2>
<ol>
<li>
<p>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</p>
</li>
<li>
<p>前端路由：key 是路径，value 是组件。</p>
</li>
</ol>
<h3 id="1-基本使用">1. <strong>基本使用</strong></h3>
<h3 id="1基本使用">1.基本使用</h3>
<ol>
<li>
<p>安装 vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li>
<p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li>
<p>编写 router 配置项:</p>
<pre><code class="language-js">//引入VueRouter
import VueRouter from &quot;vue-router&quot;;
//引入Luyou 组件
import About from &quot;../components/About&quot;;
import Home from &quot;../components/Home&quot;;

//创建router实例对象，去管理一组一组的路由规则
const router = new VueRouter({
  routes: [
    {
      path: &quot;/about&quot;,
      component: About,
    },
    {
      path: &quot;/home&quot;,
      component: Home,
    },
  ],
});

//暴露router
export default router;
</code></pre>
</li>
<li>
<p>实现切换（active-class 可配置高亮样式）</p>
<pre><code class="language-vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>指定展示位置</p>
<pre><code class="language-vue">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<h3 id="2几个注意点">2.几个注意点</h3>
<ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个 router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3多级路由多级路由">3.多级路由（多级路由）</h3>
<ol>
<li>
<p>配置路由规则，使用 children 配置项：</p>
<pre><code class="language-js">routes: [
  {
    path: &quot;/about&quot;,
    component: About,
  },
  {
    path: &quot;/home&quot;,
    component: Home,
    children: [
      //通过children配置子级路由
      {
        path: &quot;news&quot;, //此处一定不要写：/news
        component: News,
      },
      {
        path: &quot;message&quot;, //此处一定不要写：/message
        component: Message,
      },
    ],
  },
];
</code></pre>
</li>
<li>
<p>跳转（要写完整路径）：</p>
<pre><code class="language-vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
</li>
</ol>
<h3 id="4路由的-query-参数">4.路由的 query 参数</h3>
<ol>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;

&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;
&lt;router-link
  :to=&quot;{
    path: '/home/message/detail',
    query: {
      id: 666,
      title: '你好',
    },
  }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.query.id;
$route.query.title;
</code></pre>
</li>
</ol>
<h3 id="5命名路由">5.命名路由</h3>
<ol>
<li>
<p>作用：可以简化路由的跳转。</p>
</li>
<li>
<p>如何使用</p>
<ol>
<li>
<p>给路由命名：</p>
<pre><code class="language-js">{
  path:'/demo',
  component:Demo,
  children:[
    {
      path:'test',
      component:Test,
      children:[
        {
                      name:'hello' //给路由命名
          path:'welcome',
          component:Hello,
        }
      ]
    }
  ]
}
</code></pre>
</li>
<li>
<p>简化跳转：</p>
<pre><code class="language-vue">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;{ name: 'hello' }&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link
  :to=&quot;{
    name: 'hello',
    query: {
      id: 666,
      title: '你好',
    },
  }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="6路由的-params-参数">6.路由的 params 参数</h3>
<ol>
<li>
<p>配置路由，声明接收 params 参数</p>
<pre><code class="language-js">{
 path:'/home',
 component:Home,
 children:[
   {
     path:'news',
     component:News
   },
   {
     component:Message,
     children:[
       {
         name:'xiangqing',
         path:'detail/:id/:title', //使用占位符声明接收params参数
         component:Detail
       }
     ]
   }
 ]
}
</code></pre>
</li>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;

&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link
  :to=&quot;{
    name: 'xiangqing',
    params: {
      id: 666,
      title: '你好',
    },
  }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
<blockquote>
<p>特别注意：路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置！</p>
</blockquote>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.params.id;
$route.params.title;
</code></pre>
</li>
</ol>
<h3 id="7路由的-props-配置">7.路由的 props 配置</h3>
<p>作用：让路由组件更方便的收到参数</p>
<pre><code class="language-js">{
  name:'xiangqing',
  path:'detail/:id',
  component:Detail,

  //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
  // props:{a:900}

  //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
  // props:true

  //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
  props(route){
    return {
      id:route.query.id,
      title:route.query.title
    }
  }
}
</code></pre>
<h3 id="8router-link的-replace-属性">8.<code>&lt;router-link&gt;</code>的 replace 属性</h3>
<ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9编程式路由导航">9.编程式路由导航</h3>
<ol>
<li>
<p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-js">//$router的两个API
this.$router.push({
  name: &quot;xiangqing&quot;,
  params: {
    id: xxx,
    title: xxx,
  },
});

this.$router.replace({
  name: &quot;xiangqing&quot;,
  params: {
    id: xxx,
    title: xxx,
  },
});
this.$router.forward(); //前进
this.$router.back(); //后退
this.$router.go(); //可前进也可后退
</code></pre>
</li>
</ol>
<h3 id="10缓存路由组件">10.缓存路由组件</h3>
<ol>
<li>
<p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-vue">&lt;keep-alive include=&quot;News&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
</li>
</ol>
<h3 id="11两个新的生命周期钩子">11.两个新的生命周期钩子</h3>
<ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：
<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12路由守卫">12.路由守卫</h3>
<ol>
<li>
<p>作用：对路由进行权限控制</p>
</li>
<li>
<p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li>
<p>全局守卫:</p>
<pre><code class="language-js">//全局前置守卫：初始化时执行、每次路由切换前执行
router.beforeEach((to, from, next) =&gt; {
  console.log(&quot;beforeEach&quot;, to, from);
  if (to.meta.isAuth) {
    //判断当前路由是否需要进行权限控制
    if (localStorage.getItem(&quot;school&quot;) === &quot;atguigu&quot;) {
      //权限控制的具体规则
      next(); //放行
    } else {
      alert(&quot;暂无权限查看&quot;);
      // next({name:'guanyu'})
    }
  } else {
    next(); //放行
  }
});

//全局后置守卫：初始化时执行、每次路由切换后执行
router.afterEach((to, from) =&gt; {
  console.log(&quot;afterEach&quot;, to, from);
  if (to.meta.title) {
    document.title = to.meta.title; //修改网页的title
  } else {
    document.title = &quot;vue_test&quot;;
  }
});
</code></pre>
</li>
<li>
<p>独享守卫:</p>
<pre><code class="language-js">beforeEnter(to,from,next){
 console.log('beforeEnter',to,from)
 if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
   if(localStorage.getItem('school') === 'atguigu'){
     next()
   }else{
     alert('暂无权限查看')
     // next({name:'guanyu'})
   }
 }else{
   next()
 }
}
</code></pre>
</li>
<li>
<p>组件内守卫：</p>
<pre><code class="language-js">//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) {
},
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) {
}
</code></pre>
</li>
</ol>
<h3 id="13路由器的两种工作模式">13.路由器的两种工作模式</h3>
<ol>
<li>对于一个 url 来说，什么是 hash 值？—— #及其后面的内容就是 hash 值。</li>
<li>hash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器。</li>
<li>hash 模式：
<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history 模式：
<ol>
<li>地址干净，美观 。</li>
<li>兼容性和 hash 模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript]]></title>
        <id>https://rowanwang6.github.io/post/javascript/</id>
        <link href="https://rowanwang6.github.io/post/javascript/">
        </link>
        <updated>2022-07-06T08:17:41.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>JavaScript is a high-level, object-oriented, multi-paradigm programming language.<br>
目录:<br>
<a href="#chapter-1">第一章</a><br>
<a href="#chapter-2">第二章</a></p>
</blockquote>
<h1 id="chapter-1">Chapter 1</h1>
<h2 id="1-values-and-variables">1. Values and variables</h2>
<p>Values: Smallest unit in JS, store them in variables.<br>
<code>let firstName = Jonas</code><br>
<code>firstName</code> is a box irl, Jonas is the value in the box.<br>
camelCase 驼峰命名 第一个单词小写，后面的首字母大写</p>
<h2 id="2-senven-primitive-data-type-in-javascript">2. Senven primitive data type in JavaScript</h2>
<ol>
<li>Number: Floating point numbers, used for decimals and integers  <code>let age = 23;</code></li>
<li>String: Sequence of characters, used for text</li>
<li>Boolean: Logical type that only can be <code>true</code> or <code>false</code>, used for taking decision</li>
<li>Undefined: Value taken by a variable that is not yet defined <code>let age;</code></li>
<li>Null: Also means empty value</li>
<li>Symbol(ES2015): Value that is unique and cannot be changed [Not useful for now]</li>
<li>BigInt(ES2020): Larger integers than the Number type can hold</li>
</ol>
<blockquote>
<p>Dynamic Typing: JavaScript can automatically determine the datatype of the value.</p>
</blockquote>
<h2 id="3-let-const-var">3. let, const, var</h2>
<p>let: define mutable variable<br>
const: define immutable variable (constant, no <code>const age;</code> )<br>
var: function scope</p>
<h2 id="4-operators">4. Operators</h2>
<ul>
<li>math: +, -, *, /</li>
<li>assignment:  +=, -=, ++, --, =  <code>x++; //x=x+1</code></li>
<li>comparison: &gt;, &lt;, &lt;=, &gt;=, ==</li>
<li>logic</li>
</ul>
<h3 id="41-precedence">4.1 Precedence</h3>
<p><code>()</code>优先级最高</p>
<h2 id="5-templates-literals-模板文字">5. Templates Literals 模板文字</h2>
<pre><code class="language-JavaScript">const jonasNew = `I'm ${firstName}, a ${year - birthYear} year old ${job}!`;
console.log(jonasNew);
</code></pre>
<pre><code class="language-JavaScript">//这两段输出一样  用反引号可以快速实现多行文字输出
console.log('String with \n\
multiple \n\
lines');

console.log(`String
multiple
lines`);
</code></pre>
<h2 id="6-if_else">6. If_else</h2>
<h2 id="7-type-conversion-and-coercion">7. Type Conversion and Coercion</h2>
<p><code>Number('32') --&gt; 32</code><br>
<code>+</code> 运算符强制转换所有为字符串  <code>2+3+4+'5' 输出为'95'</code><br>
<code>-</code> 运算符强制转换所有为数字</p>
<h2 id="8-truthy-and-falsy-values">8. Truthy and Falsy Values</h2>
<p>5 falsy values: 0, '', undefined, Null, NaN (Not a Number)<br>
<code>Boolean(0) 会变成false</code></p>
<pre><code class="language-JavaScript">const money = 100;$$
if (money) {
  console.log(&quot;Don't spend it all ;)&quot;);
} else {
  console.log('You should get a job!');
}
输出为'You should get a job!'，因为if else 会自动执行boolean化
</code></pre>
<h2 id="9-vs">9. <code>==</code>vs<code>===</code></h2>
<p>lose  strict<br>
<code>==</code> will perform type coercion<br>
<code>'18'==18 True</code><br>
<code>'18'===18 False</code><br>
<code>prompt('What's your favorate number?')</code></p>
<h2 id="10-statements-and-expressions-声明和表达式">10. Statements and Expressions (声明和表达式)</h2>
<p>Expressions: 3+4 能产生一个value<br>
Statements 不能</p>
<h2 id="11-ecmascript-2015-es6-es2015">11. ECMAScript 2015 / ES6 / ES2015</h2>
<p>Huge change. 向后兼容性</p>
<h1 id="hints">Hints</h1>
<ol>
<li>把脚本置于<code>&lt;body&gt;</code>元素的底部，可改善显示速度，因为脚本编译会拖慢显示。</li>
<li>更改 HTML 元素的 innerHTML 属性是在 HTML中显示数据的常用方法。</li>
<li>在 HTML 文档完全加载后使用 document.write() 将删除所有已有的 HTML。</li>
<li>在 HTML 中，JavaScript 程序由 web 浏览器执行。</li>
<li>JavaScript 语句由以下构成：值、运算符、表达式、关键词和注释。</li>
<li>JavaScript 拥有空白折叠。</li>
<li>JavaScript 语句常常通过某个关键词来标识需要执行的 JavaScript 动作。</li>
</ol>
<table>
<thead>
<tr>
<th>关键词</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>break</td>
<td>终止 switch 或循环</td>
</tr>
<tr>
<td>continue</td>
<td>跳出循环并在顶端开始</td>
</tr>
<tr>
<td>debugger</td>
<td>停止执行 JavaScript，并调用调试函数（如果可用）</td>
</tr>
<tr>
<td>do ... while</td>
<td>执行语句块，并在条件为真时重复代码块</td>
</tr>
<tr>
<td>for</td>
<td>标记需被执行的语句块，只要条件为真</td>
</tr>
<tr>
<td>function</td>
<td>声明函数</td>
</tr>
<tr>
<td>if ... else</td>
<td>标记需被执行的语句块，根据某个条件</td>
</tr>
<tr>
<td>return</td>
<td>退出函数</td>
</tr>
<tr>
<td>switch</td>
<td>标记需被执行的语句块，根据不同的情况</td>
</tr>
<tr>
<td>try ... catch</td>
<td>对语句块实现错误处理</td>
</tr>
<tr>
<td>var</td>
<td>声明变量</td>
</tr>
</tbody>
</table>
<ol start="8">
<li>所有 JavaScript 标识符对大小写敏感。变量 lastName 和 lastname，是两个不同的变量。</li>
<li>JavaScript 程序员倾向于使用以小写字母开头的驼峰大小写</li>
<li>ES2015 引入了两个重要的 JavaScript 新关键词：<code>let</code> 和 <code>const</code>。这两个关键字在 JavaScript 中提供了块作用域（Block Scope）变量（和常量）。在 ES2015 之前，JavaScript 只有两种类型的作用域：全局作用域和函数作用域。</li>
<li>局部变量只能在它们被声明的函数内访问（函数作用域）。</li>
</ol>
<pre><code class="language-JavaScript">// 此处的代码不可以使用 carName

function myFunction() {
  var carName = &quot;porsche&quot;;
  // code here CAN use carName
}

// 此处的代码不可以使用 carName
</code></pre>
<ol start="12">
<li>块作用域<br>
可以使用 let 关键词声明拥有块作用域的变量。<br>
在块 {} 内声明的变量无法从块外访问：</li>
</ol>
<pre><code class="language-JavaScript">{ 
  let x = 10;
}
// 此处不可以使用 x
</code></pre>
<p>通过 var 关键词声明的变量没有块作用域。在块 {} 内声明的变量可以从块之外进行访问。</p>
<ol start="13">
<li>使用 var 关键字重新声明变量会带来问题，在块中重新声明变量也将重新声明块外的变量。<br>
使用 let 关键字重新声明变量可以解决这个问题，在块中重新声明变量不会重新声明块外的变量。</li>
</ol>
<pre><code class="language-JS">var x = 10;
// 此处 x 为 10
{ 
  let x = 6;
  // 此处 x 为 6
}
// 此处 x 为 10
</code></pre>
<ol start="14">
<li>
<p>循环作用域<br>
在循环中使用的变量使用 var 会重新声明循环之外的变量。（for var i=... 会改变原来的var）<br>
在循环中使用的变量使用 let 并没有重新声明循环外的变量。<br>
如果在循环中用 let 声明了变量 i，那么只有在循环内，变量 i 才是可见的。</p>
</li>
<li>
<p>在 HTML 中，通过 var 定义的全局变量会成为 window 变量。通过 let 关键词定义的全局变量不属于 window 对象，不可以使用windows.nameTest()</p>
</li>
<li>
<p>允许在程序的任何位置使用 var 重新声明 JavaScript 变量<br>
在相同的作用域，或在相同的块中，通过 let 重新声明一个 var 变量是不允许的<br>
在相同的作用域，或在相同的块中，通过 let 重新声明一个 let 变量是不允许的<br>
在相同的作用域，或在相同的块中，通过 var 重新声明一个 let 变量是不允许的<br>
在不同的作用域或块中，通过 let 重新声明变量是允许的：</p>
</li>
<li>
<p>通过 var 声明的变量会提升到顶端。</p>
</li>
</ol>
<pre><code class="language-JS">// 在此处，您可以使用 carName
var carName;
</code></pre>
<ol start="18">
<li>可以更改常量对象的属性，可以更改常量数组的元素。</li>
<li>位运算符<br>
<img src="file:///Users/rowan/Documents/Gridea/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="img" loading="lazy"></li>
<li>在 JavaScript 中，null 的数据类型是对象。</li>
<li>Null 和 undefined</li>
</ol>
<pre><code class="language-JS">typeof undefined              // undefined
typeof null                   // object
null === undefined            // false
null == undefined             // true
</code></pre>
<ol start="22">
<li>当 JavaScript 到达 return 语句，函数将停止执行。</li>
<li>不使用 () 访问函数将返回函数声明而不是函数结果。</li>
<li>如果通过关键词 &quot;new&quot; 来声明 JavaScript 变量，则该变量会被创建为对象。避免字符串、数值或逻辑对象。他们会增加代码的复杂性并降低执行速度。</li>
<li>replace() 只替换首个匹配，区分大小写。</li>
</ol>
<h1 id="chapter-2">Chapter 2</h1>
<h2 id="1-strict-mode-严格模式">1. Strict Mode 严格模式</h2>
<p><code>'use strict mode'</code> at the first line of the JS file.</p>
<h2 id="2-function-函数">2. Function 函数</h2>
<p>函数就是一个值</p>
<pre><code class="language-JavaScript">function logger ( ) {
    // function body
    }

logger(); // invoking the function 调用函数

// 
// Function declaration  可以在声明前就调用函数(Hoisting 提升)
function calcAge1(birthYeah) {
  return 2037 - birthYeah;
}
const age1 = calcAge1(1991);

// Function expression
const calcAge2 = function (birthYeah) {
  return 2037 - birthYeah;
}
const age2 = calcAge2(1991);

console.log(age1, age2);
</code></pre>
<h3 id="21-function-declaration-and-function-expression-函数声明和函数表达式">2.1 Function Declaration and Function Expression 函数声明和函数表达式</h3>
<pre><code class="language-JavaScript">// Function declaration  可以在声明前就调用函数(Hoisting 提升)
function calcAge1(birthYeah) {
  return 2037 - birthYeah;
}
const age1 = calcAge1(1991);

// Function expression
const calcAge2 = function (birthYeah) {
  return 2037 - birthYeah;
}
const age2 = calcAge2(1991);

console.log(age1, age2);
</code></pre>
<h3 id="22-arrow-function-箭头函数">2.2 Arrow Function 箭头函数</h3>
<p>ES6添加到Javascript</p>
<pre><code class="language-Js">const yearsUntilRetirement = (birthYeah, firstName) =&gt; {
  const age = 2037 - birthYeah;
  const retirement = 65 - age;
  // return retirement;
  return `${firstName} retires in ${retirement} years`;
}

console.log(yearsUntilRetirement(1991, 'Jonas')); console.log(yearsUntilRetirement(1980, 'Bob'));
</code></pre>
<p>Ruturn 在返回值后会立刻退出函数，接下来的语句不会再执行。<br>
<img src="https://rowanwang6.github.io/post-images/1659600985927.png" alt="" loading="lazy"></p>
<h2 id="3-arrays">3. Arrays</h2>
<p><code>push</code> 添加元素在数组末尾<br>
<code>unshift</code> 添加元素在数组开头<br>
数组的push会返回添加前数组的长度 unshift 也会<br>
<code>pop</code> 删除在数组末尾的元素<br>
<code>shift</code> 删除在数组开头的元素<br>
<code>indexOf </code>返回元素在数组的索引<br>
<code>includes </code>元素在数组中则返回true</p>
<h2 id="4-objects">4. Objects</h2>
<p>Order doesn't matter at all.</p>
<pre><code class="language-js">// 创建对象
const jonas = {
  firstName: 'Jonas',
  lastName: 'Schmedtmann',
  age: 2037 - 1991,
  job: 'teacher',
  friends: ['Michael', 'Peter', 'Steven']
};

// 需要先计算属性名时，用括号表示。 其余都可以直接使用点属性表示。
console.log(jonas.lastName);
console.log(jonas[&quot;lastName&quot;]);

// 不可以直接将变量名作为属性名，这个时候需要用括号表示。d
const intersted = prompt(&quot;What do you want to know about Jonas?&quot;);
console.log(jonas.intersted);
console.log(jonas[intersted]);

// 添加属性
jonas.location = 'Portugal';
jonas['twitter'] = '@jonasschmedtman';
console.log(jonas);

</code></pre>
<h2 id="5-loops">5. Loops</h2>
<h3 id="51-for-loops">5.1 For Loops</h3>
<p><code>for</code> loops keep running while condition is TRUE.</p>
<h3 id="52-while-loops">5.2 While Loops</h3>
<p><code>break</code><br>
<code>while(1)</code></p>
<h1 id="chapter-3">Chapter 3</h1>
<h2 id="1-dom-manipulation-操作">1. DOM Manipulation 操作</h2>
<p>Document Object Model   -- Web APIs<br>
<img src="https://rowanwang6.github.io/post-images/1661160483209.png" alt="" loading="lazy"><br>
Whatever is in the HTML document also has to be in the DOM.<br>
The DOM is the complete representation of the HTML document, so that we can manipulate it in complex ways.<br>
<code>modal.classList.remove('hidden');</code><br>
<code>document.getElementById()</code><br>
<code>document.querySelector()</code></p>
<h1 id="chapter-4">Chapter 4</h1>
<h2 id="1-js的特点">1. JS的特点</h2>
<ol>
<li>High-level</li>
<li>Garbage-collected</li>
<li>Interpreted / just-in-time compiled  解释型/实时编译型</li>
<li>Prototyp-based object-oriented</li>
<li>First-class functions</li>
<li>Dynamic</li>
<li>Single-threaded</li>
<li>Non-blocking event loop</li>
</ol>
<h2 id="2-javascript-engine">2. Javascript Engine</h2>
<p>Call stack and  Heap<br>
调用栈：代码实际执行的地方，using Execution Contexts(执行上下文)<br>
堆：一个非结构化的内存池，储存了我们的应用程序需要的所有对象。<br>
<img src="https://rowanwang6.github.io/post-images/1661306889795.png" alt="" loading="lazy"><br>
<img src="https://rowanwang6.github.io/post-images/1661307089300.png" alt="" loading="lazy"></p>
<h2 id="3-execution-contexts-执行上下文">3. Execution Contexts 执行上下文:</h2>
<p><img src="https://rowanwang6.github.io/post-images/1661307779189.png" alt="" loading="lazy"><br>
每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。</p>
<ul>
<li>全局环境：JavaScript代码运行起来会首先进入该环境</li>
<li>函数环境：当函数被调用执行时，会进入当前函数中执行代码</li>
<li>eval（不建议使用，可忽略）<br>
因此在一个JavaScript程序中，必定会产生多个执行上下文，JavaScript引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。https://www.jianshu.com/p/a6d37c77e8db</li>
</ul>
<h3 id="31-whats-inside-execution-contexts">3.1 What's inside Execution Contexts?</h3>
<ul>
<li>Variable Environment 变量环境</li>
<li>Scope chain 作用域链</li>
<li>this Keyword<br>
全局执行上下文Global execution contexts首先被创建(所有函数以外的代码)，然后进入调用栈Call stack，调用函数后，global暂停运行，创建函数的执行上下文入栈，位于栈顶。JS引擎首先执行栈顶的代码，出栈后再继续执行下面的，因为JS是单线程。</li>
</ul>
<h3 id="32-scope-chain">3.2 Scope chain</h3>
<ol>
<li>Global scope 全局作用域</li>
<li>Function scope 函数作用域</li>
<li>Block scope (ES6) 块作用域 花括号里的 <strong>只有let const 有效 var仍然可以在外面访问</strong><br>
<img src="https://rowanwang6.github.io/post-images/1661482373295.png" alt="" loading="lazy"><br>
变量查找 variable lookup 只能查找父作用域  形成作用域链。<br>
作用域链：查找一个变量时先在自己本身作用域中找，当自身作用域中没有时就会一层一层向外找<br>
<img src="https://rowanwang6.github.io/post-images/1661483037005.png" alt="" loading="lazy"></li>
</ol>
<p>##4. Hoisting 提升<br>
<img src="https://rowanwang6.github.io/post-images/1662614381733.png" alt="" loading="lazy"></p>
<h3 id="41-temporal-dead-zonetdz-临时死区">4.1 Temporal Dead Zone(TDZ) 临时死区</h3>
<p>let 和 const 声明的变量不会被提升到作用域顶部，如果在声明前访问这些变量，会导致错误。<br>
这是因为 JavaScript 引擎在扫描代码发现变量声明时，要么将他们提升到作用域顶部（遇到 var 声明），要么将声明放在 TDZ 中（遇到 let 和 const 声明）。访问 TDZ 中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从 TDZ 中移除，然后方可访问。</p>
<h2 id="5-this-keyword">5. <strong>this</strong> keyword</h2>
<p><img src="https://rowanwang6.github.io/post-images/1663121994402.png" alt="" loading="lazy"><br>
<code>this</code>表示当前对象的一个引用。<br>
<code>this</code>的指向：this不是固定不变的，是根据调用的上下文（执行时环境）改变而改变。<br>
如果单独使用，this 表示全局对象。<br>
在方法中，this 表示该方法所属的对象。<br>
在函数中，this 表示全局对象。<br>
在函数中，在严格模式下，this 是未定义的(undefined)，不然也是全局对象windows。<br>
在事件中，this 表示接收事件的元素。(Event listener)</p>
<h3 id="51-this的指向">5.1 this的指向</h3>
<h4 id="511-全局环境">5.1.1 全局环境</h4>
<p>全局环境就是在<code>&lt;script&gt;&lt;/script&gt;</code>里面，这里的this始终指向的是window对象。</p>
<pre><code class="language-js">&lt;script&gt;
    console.log(this); // 全局环境，即window对象下，this -&gt; window 
&lt;/script&gt;
</code></pre>
<h4 id="512-局部环境">5.1.2 局部环境</h4>
<p>严格模式下，函数中的this为undefined；<br>
1）在全局作用域下直接调用函数，this指向window</p>
<pre><code class="language-js">function fun() {
 	console.log(this);
}
fun(); // fun() 实际上是window.fun(), 所以this -&gt; window
</code></pre>
<p>2）对象函数调用，哪个对象调用就指向哪个对象<br>
<strong>箭头函数没有this关键词，this指向父作用域</strong></p>
<pre><code class="language-js">var obj1 = {
    a: 1,
    fun1: function() {
        console.log(this);
    },
    obj2: {
    	fun2: function() {
    		console.log(this);
    	}
    }
}
obj1.fun1(); // fun1由obj调用，所以this -&gt; obj1
obj1.obj2.fun2(); // fun2由obj2调用，所以this -&gt; obj2
</code></pre>
<p>3）new实例化对象，构造函数中的this指向实例对象</p>
<pre><code class="language-js">var Person = function() {
	this.name = &quot;小刘&quot;; // 这里的this -&gt; obj对象
}
var obj = new Person();
</code></pre>
<p>4）事件中的this<br>
在HTML事件句柄中，this指向了接收事件的HTML元素<br>
<code>&lt;button onclick=&quot;this.style.display='none'&quot;&gt;点我我就消失&lt;/button&gt;</code><br>
5）改变this的指向</p>
<h2 id="4-primitives-vs-reference-values-objects">4. Primitives vs. Reference Values (Objects)</h2>
<p><img src="https://rowanwang6.github.io/post-images/1663145378397.png" alt="" loading="lazy"><br>
对象中的变量（属性）储存方式与其他的不同<br>
浅拷贝 <code>const wjCopy = Object.assign({}, wj2);</code><br>
深克隆 Lo-Dash库</p>
<h1 id="chapter-5">Chapter 5</h1>
<h2 id="1-destructuring-arrays-解构数组">1. Destructuring Arrays 解构数组</h2>
<pre><code class="language-js">const arr = [2, 3, 4];
const [x, y, z] = arr;// 2 3 4
const [a, , b] = arr;// 2 4
[a, b] = [b, a];// 不使用临时变量来交换变量值
const [i, , [j, k]] = [2, 3 , [5,6]]; // 2 5 6 解构
const [p=1, q=1, r=1] = [2, 3]; //  2 3 1 数组未知长度解构

///使用初始值来防止有undefined产生
orderDelivery({ starterIndex = 1, mainIndex = 0, time = '20:00', address }) {
    console.log(
      `Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`
    );
  }
</code></pre>
<h2 id="2-spread-operators-扩展运算符">2. Spread Operators 扩展运算符</h2>
<p>扩展运算符可以将数组中的每个元素或对象中的每个键值对取出，并且不能在模板字符串中使用。<br>
只能用于Iterables: arrays, strings, maps, sets. NOT objects</p>
<pre><code class="language-js">const arr = [7, 8, 9];
const badNewArr = [1, 2, arr[0], arr[1], arr[2]];
console.log(badNewArr);//1 2 7 8 9

const newArr = [1, 2, ...arr];
console.log(newArr);//1 2 7 8 9
</code></pre>
<h2 id="3-rest-pattern-and-parameters">3. Rest Pattern and Parameters</h2>
<pre><code class="language-js">// 
const [a, b, ...other] = [1, 2, 3, 4, 5];
console.log(other); // [3, 4 , 5]
</code></pre>
<pre><code class="language-js">// 传入多个参数
const add = function (...numbers) {
  console.log(numbers);
  let sum = 0;
  for (let index = 0; index &lt; numbers.length; index++) {
    sum += numbers[index];
  }
  console.log(sum);
};
add(2, 3); // 5
add(5, 3, 7, 2); // 17
</code></pre>
<h2 id="4-short-circuiting-短路">4. Short Circuiting 短路</h2>
<pre><code class="language-js">console.log('' || 'shit'); // ''是falsy value 输出为shit
console.log(0 || undefined || 1 || 24 || 'shit'); // 输出第一个真值Truthy Value，为1，剩下的短路
console.log(7 &amp;&amp; 0);// 输出为0
console.log(1 || 24 || 0 || 'shit'|| 24);// 输出第一个假值Falsy Value，为0，剩下的短路
console.log(null ?? 2)// null 或 undefined 不会被0 和 ' ' 影响。 输出第一不为null 或undefined的 falsy数
</code></pre>
<h2 id="5-logical-assignment-operators-逻辑分配运算符">5. Logical Assignment Operators 逻辑分配运算符</h2>
<p>Introduced in ES2021</p>
<pre><code class="language-js">const rest1 = {
  name: 'capri',
  numGeust: 20,
};

const rest2 = {
  name: 'La',
  owner: 'wjh',
};

// rest1.numGeust = rest1.numGeust || 10;
rest1.numGeust ||= 10;
// rest2.numGeust = rest2.numGeust || 10;
rest2.numGeust ||= 10;
console.log(rest1);//
console.log(rest2);
</code></pre>
<p><code>??=</code> <code>&amp;&amp;=</code><br>
可以用<code>&amp;&amp;</code>代替if else</p>
<pre><code class="language-js">a&gt;b &amp;&amp; console.log('a&gt;b');
</code></pre>
<h2 id="6-forof-loop">6. forof loop</h2>
<pre><code class="language-js">for (const iterator of object) {
  console.log(iterator);
}
</code></pre>
<h2 id="7-enhanced-object-literals-es6">7. Enhanced Object Literals (ES6)</h2>
<pre><code class="language-js">// 1. 定义对象时，属性可以单独定义然后直接放进去
const property1 = {
    dd: 23
};
const mainObj = {
    property2: 'ddd',
    property1
    // 2. 函数简写
    order: function (index){
        return index;
    },
    // 等于 下面的即去掉function关键词和冒号
    // order (index){
    //     return index;
    // }
    // 3. 计算属性名
    [array[2]] : {
        fds: 2,
    }
}
</code></pre>
<h2 id="8-optional-chaining-可选链">8. Optional Chaining (可选链)</h2>
<p><code>?.</code> 链接运算符，如果前面的都不存在 直接返回undefined</p>
<pre><code class="language-js">console.log(restaurant.openingHours.mon?.open);
console.log(restaurant.openingHours?.mon?.open);
console.log(restaurant.openingHours?.thu?.open);

const user = ['wj', 'xik'];
console.log(user?.[0] ?? 'no'); // wj
const user1 = [];
console.log(user?.[0] ?? 'no'); // no
</code></pre>
<h2 id="9-looping-objects-关于对象的循环">9. Looping objects 关于对象的循环</h2>
<p><code>Object.keys(objName)</code> 键<br>
<code>Object.values(objName)</code> 值<br>
<code>Object.entries(objName)</code>  键值对<br>
<code>obj.property.entries()</code></p>
<h2 id="10-sets-集">10. Sets 集</h2>
<p>没有重复的值，需要传入可迭代(string，array)，没有键值对，没有index(不能写<code>set1[0]</code>)。<br>
主要作用：<br>
<code>const setExample = new Set(iterable)</code></p>
<pre><code class="language-js">const ordersSet = new Set([
  'Pasta',
  'Pizza',
  'Pizza',
  'Risotto',
  'Pasta',
  'Pizza',
]);
console.log(ordersSet);//{'Pasta', 'Pizza', 'Risotto'}
console.log(new Set('Jonas')); //{'J', 'o', 'n', 'a', 's'}
console.log(ordersSet.size); // 3
console.log(ordersSet.has('Pizza')); // true
console.log(ordersSet.has('Bread')); // false
ordersSet.add('Garlic Bread');
ordersSet.add('Garlic Bread');
ordersSet.delete('Risotto');
// ordersSet.clear(); // {}
console.log(ordersSet); // {'Pasta', 'Pizza', 'Garlic Bread'}
// for (const order of ordersSet) console.log(order);

const staff = ['Waiter', 'Chef', 'Waiter', 'Manager', 'Chef', 'Waiter'];
const staffUnique = [...new Set(staff)];
console.log(staffUnique); // ['Waiter', 'Chef', 'Manager']

console.log(
  new Set(['Waiter', 'Chef', 'Waiter', 'Manager', 'Chef', 'Waiter']).size
); // 3

console.log(new Set('jonasschmedtmann').size); // 11，一种计算string的长度的方法
</code></pre>
<h2 id="11-maps-字典">11. Maps 字典</h2>
<p>objects中的key基本上都是string，但maps中的key可以为各种类型（objects arrays maps）</p>
<pre><code class="language-js">const rest = new Map();
rest.set('name', 'Classico Italiano');
rest.set(1, 'Firenze, Italy');
console.log(rest.set(2, 'Lisbon, Portugal'));

rest
  .set('categories', ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'])
  .set('open', 11)
  .set('close', 23)
  .set(true, 'We are open :D')
  .set(false, 'We are closed :(');

console.log(rest.get('name')); // Classico Italiano
console.log(rest.get(true)); // We are open :D
console.log(rest.get(1)); // We are closed :(

const time = 8;
console.log(rest.get(time &gt; rest.get('open') &amp;&amp; time &lt; rest.get('close'))); // time &gt; rest.get('open') &amp;&amp; time &lt; rest.get('close') 如果为真 打印 We are open :D

console.log(rest.has('categories')); // true
rest.delete(2);
// rest.clear();

const arr = [1, 2];
rest.set(arr, 'Test');
// rest.get([1,2]) 会返回undefined因为在堆中，这两个数组不是同一个地址
rest.set(document.querySelector('h1'), 'Heading');
console.log(rest.get(arr));// Test
</code></pre>
<pre><code class="language-js">// Maps: Iteration
const question = new Map([
  ['question', 'What is the best programming language in the world?'],
  [1, 'C'],
  [2, 'Java'],
  [3, 'JavaScript'],
  ['correct', 3],
  [true, 'Correct 🎉'],
  [false, 'Try again!'],
]);
console.log(question);

// Convert object to map
console.log(Object.entries(openingHours));
const hoursMap = new Map(Object.entries(openingHours));
console.log(hoursMap);

// Quiz app
console.log(question.get('question'));
for (const [key, value] of question) {
  if (typeof key === 'number') console.log(`Answer ${key}: ${value}`);
}
// const answer = Number(prompt('Your answer'));
const answer = 3;
console.log(answer);

console.log(question.get(question.get('correct') === answer));

// Convert map to array
console.log([...question]);
// console.log(question.entries());
console.log([...question.keys()]);
console.log([...question.values()]);
</code></pre>
<h2 id="12-which-data-structure">12. Which data structure?</h2>
<p><img src="https://rowanwang6.github.io/post-images/1663576489745.png" alt="" loading="lazy"><br>
<img src="https://rowanwang6.github.io/post-images/1663577904008.png" alt="" loading="lazy"></p>
<h2 id="13-working-with-strings">13. Working with Strings</h2>
<pre><code class="language-js">const airline = 'TAP Air Portugal';
const plane = 'A320';
// position
console.log(airline[2]); // P
console.log('wjsb'[1]); // j
// length method
console.log(airline.length); //16
console.log('wjsb'.length); // 4
// indexOf method
console.log(airline.indexOf('r')); // 6
console.log(airline.lastIndexOf('r')); // 10
console.log(airline.indexOf('Portugal')); // 8
// slice 切片 获得substring [start,end) 结尾不算进去 substring长度 = end - start
console.log(airline.slice(4)); // Air Portugal
console.log(airline.slice(4, 7)); // Air
// 提取第一个单词，以空格的index为end参数
console.log(airline.slice(0, airline.indexOf(' ')));
// 提取最后一个单词，以空格的lastindex + 1为start参数
console.log(airline.slice(airline.lastIndexOf(' ') + 1));
// 是否选到中间座位
const checkMiddleSeat = function (seat) {
// B and E are middle seats
const s = seat.slice(-1);
if (s === 'B' || s === 'E') console.log('You got the middle seat 😬');
  else console.log('You got lucky 😎');
};
checkMiddleSeat('11B');
checkMiddleSeat('23C');
checkMiddleSeat('3E');

const airline = 'TAP Air Portugal';
console.log(airline.toLowerCase()); // tap air portugal
console.log(airline.toUpperCase()); // TAP AIR PORTUGAL

// Fix capitalization in name
const passenger = 'jOnAS';
const passengerLower = passenger.toLowerCase(); // jonas
const passengerCorrect =
  passengerLower[0].toUpperCase() + passengerLower.slice(1);
console.log(passengerCorrect); // Jonas

// tirm method  修剪字符串 去掉空格以及换行符
const email = 'hello@jonas.io';
const loginEmail = '  Hello@Jonas.Io \n';

// const lowerEmail = loginEmail.toLowerCase();
// const trimmedEmail = lowerEmail.trim();
const normalizedEmail = loginEmail.toLowerCase().trim();
console.log(normalizedEmail);
console.log(email === normalizedEmail);

// replace method
const priceGB = '288,97£';
const priceUS = priceGB.replace('£', '$').replace(',', '.');
console.log(priceUS);

const announcement =
  'All passengers come to boarding door 23. Boarding door 23!';

console.log(announcement.replace('door', 'gate'));
console.log(announcement.replaceAll('door', 'gate'));
console.log(announcement.replace(/door/g, 'gate'));

// Booleans
const plane = 'Airbus A320neo';
console.log(plane.includes('A320'));
console.log(plane.includes('Boeing'));
console.log(plane.startsWith('Airb'));

if (plane.startsWith('Airbus') &amp;&amp; plane.endsWith('neo')) {
  console.log('Part of the NEW Airbus family');
}

// Practice exercise
const checkBaggage = function (items) {
  const baggage = items.toLowerCase();

  if (baggage.includes('knife') || baggage.includes('gun')) {
    console.log('You are NOT allowed on board');
  } else {
    console.log('Welcome aboard!');
  }
};

checkBaggage('I have a laptop, some Food and a pocket Knife');
checkBaggage('Socks and camera');
checkBaggage('Got some snacks and a gun for protection');

// Split and join
console.log('a+very+nice+string'.split('+'));
console.log('Jonas Schmedtmann'.split(' '));

const [firstName, lastName] = 'Jonas Schmedtmann'.split(' ');

// join method
const newName = ['Mr.', firstName, lastName.toUpperCase()].join(' ');
console.log(newName);

const capitalizeName = function (name) {
  const names = name.split(' ');
  const namesUpper = [];

  for (const n of names) {
    // namesUpper.push(n[0].toUpperCase() + n.slice(1));
    namesUpper.push(n.replace(n[0], n[0].toUpperCase()));
  }
  console.log(namesUpper.join(' '));
};

capitalizeName('wang xiangkun');
capitalizeName('jonas schmedtmann');

// Padding 填充 padStart(整个字符串的长度，要添加的字符)
const message = 'Go to gate 23!';
console.log(message.padStart(20, '+').padEnd(30, '+'));
console.log('Jonas'.padStart(20, '+').padEnd(30, '+'));

const maskCreditCard = function (number) {
  const str = number + '';
  const last = str.slice(-4);
  return last.padStart(str.length, '*');
};

console.log(maskCreditCard(64637836));
console.log(maskCreditCard(43378463864647384));
console.log(maskCreditCard('334859493847755774747'));

// repeat method
const message2 = 'Bad waether... All Departues Delayed... ';
console.log(message2.repeat(5));

const planesInLine = function (n) {
  console.log(`There are ${n} planes in line ${'🛩'.repeat(n)}`);
};
planesInLine(5);
planesInLine(3);
planesInLine(12);
</code></pre>
<h3 id="装箱"><strong>装箱</strong></h3>
<p>Strings are primitives, why do they have methods? Shouldn't methods only be available on objects such as a race?<br>
JavaScript will automatically behind the scenes convert that string primitive to a string object with the same content. -- boxing</p>
<pre><code class="language-js">// Boxing 装箱
console.log(new String('jonas'));
console.log(typeof new String('jonas')); // object
console.log(typeof new String('jonas').slice(1));// string
</code></pre>
<h1 id="chapter-6-functions">Chapter 6 Functions</h1>
<h2 id="1-how-passing-arguments-works-values-vs-reference-值传递">1. How Passing Arguments Works: Values vs. Reference  值传递</h2>
<p>js中只有按值传递(passing by value)，没有按参考传递(passing by reference)。对传入函数的对象来说，传入的内存地址，也只是一个包含内存地址的值。具体参考<a href="#4-primitives-vs-reference-values-objects">内存章节</a>。</p>
<pre><code class="language-js">const flight = 'LH234';
const jonas = {
  name: 'Jonas Schmedtmann',
  passport: 24739479284,
};

const checkIn = function (flightNum, passenger) {
  flightNum = 'LH999'; //无效 跟形参不是一个地址，只是单纯的复制了值
  passenger.name = 'Mr. ' + passenger.name;// 有效 复制了值，但这个值的内容是地址，因此改变的还是原来heap里的那个jonas对象
};
</code></pre>
<h2 id="2-first-class-functions-函数一等优先-vs-higer-order-functions-高阶函数">2. First-Class functions 函数一等优先 vs Higer-order functions 高阶函数</h2>
<p>First-class Function（头等函数） 当一门编程语言的函数可以被当作变量一样用时，则称这门语言<strong>拥有</strong>头等函数。<br>
js里的函数就是值，可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。函数是js对象中的一种，对象大多数都有方法，例如function.name()。<br>
高阶函数是至少具有下列功能之一的函数: 1. 将一个或多个函数作为<strong>参数</strong>(即过程参数)。 2. 返回一个函数作为结果。 所有其他函数都是一阶函数。<br>
<img src="https://rowanwang6.github.io/post-images/1663741151518.png" alt="" loading="lazy"></p>
<h2 id="3-高阶函数-回调函数">3. 高阶函数 回调函数</h2>
<pre><code class="language-js">const oneWord = function (str) {
  return str.replace(/ /g, '').toLowerCase();
};

const upperFirstWord = function (str) {
  const [first, ...others] = str.split(' ');
  return [first.toUpperCase(), ...others].join(' ');
};

// Higher-order function
const transformer = function (str, fn) { // transformer 调用其他函数，为高阶函数，面对对象编程中重要的一环；调用的function被称为回调函数 callback functions
  console.log(`Original string: ${str}`);
  console.log(`Transformed string: ${fn(str)}`);
  console.log(`Transformed by: ${fn.name}`);
};

transformer('JavaScript is the best!', upperFirstWord);// 回调函数
transformer('JavaScript is the best!', oneWord);// 回调函数
</code></pre>
<h2 id="4-函数返回函数">4. 函数返回函数</h2>
<pre><code class="language-js">const greeterHey = greet('Hey'); // greet()的结果是返回一个函数，所以现在greeterHey也是一个函数，就是greet()返回的那个函数，参数是name。因此greeterHey = function (name) {console.log(`${greeting} ${name}`);};
greeterHey('Jonas'); // Hey Jonas
greeterHey('Steven'); // Hey Steven

greet('Hello')('Jonas'); // Hello Jonas

const greet1 = greeting =&gt; name =&gt; console.log(`${greeting} ${name}`);
greet1('hello')('shit');// hello shit
</code></pre>
<h2 id="5-call-and-apply-method">5. Call and apply method</h2>
<pre><code class="language-js">const lufthansa = {
  airline: 'Lufthansa',
  iataCode: 'LH',
  bookings: [],
  // book: function () {}
  book(flightNum, name) {
    console.log(
      `${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`
    );
    this.bookings.push({
      flight: `${this.iataCode}${flightNum}`,
      name,
    });
  },
};

lufthansa.book(239, 'Jonas Schmedtmann');
lufthansa.book(635, 'John Smith');

const eurowings = {
  airline: 'Eurowings',
  iataCode: 'EW',
  bookings: [],
};

const book = lufthansa.book;
// Does NOT work
// book('123', 'shit');
//this keyword depends on how the function is called.
//所以在这里调用book()，this指向的是window，因此this.airline是undefined，this.iataCode是undefined，this.bookings是undefined

// Call method
book.call(eurowings, 23, 'Sarah Williams'); // 手动设置this指向eurowings，因此this.airline是eurowings，this.iataCode是EW，this.bookings是eurowings.bookings
book.call(lufthansa, 239, 'Mary Cooper');
// lufthansa.book.call(lufthansa, 239, 'Mary Cooper'); 结果与上面一样

// Apply method
const flightData = [583, 'George Cooper'];
book.apply(eurowings, flightData); // apply()的第二个参数是一个数组，其余与call()一样，但由于es6加入了扩展运算符，所以一般不用apply()了，而是用：
book.call(eurowings, ...flightData);
</code></pre>
<h2 id="6-bind-method">6. bind method</h2>
<pre><code class="language-js">// Bind method
book.call(eurowings, 23, 'Sarah Williams');
const bookEW = book.bind(eurowings); // bind()返回一个新的函数，这个函数的this指向bind()的第一个参数.
const bookLH = book.bind(lufthansa);
const bookLH23 = book.bind(lufthansa, 23); // bind()的第二个参数是23，因此调用bookLH23时只需要传入一个参数，即name. 固定函数的第一个传入参数为23
bookLH(23, 'Steven Williams');
bookLH23('Steven Williams');

// With event listeners
lufthansa.planes = 300;
lufthansa.buyPlane = function () {
  console.log(this);
  this.planes++;
  console.log(this.planes);
};
document
  .querySelector('.buy')
  .addEventListener('click', lufthansa.buyPlane.bind(lufthansa));
// .addEventListener('click', lufthansa.buyPlane());? why

// Partial application
const addTax = (rate, value) =&gt; value + value * rate;
console.log(addTax(0.1, 200)); // 220

const addVAT = addTax.bind(null, 0.23); // bind()的第一个参数是null，因为addTax()的this没有用到，所以可以传入null，第二个参数是0.23，即rate

// 用函数return函数写一遍
const addVATrate = function (rate) {
  return function (value) {
    return value + value * rate;
  };
};
const addVAT1 = addVATrate(0.23); //类似解构 固定住rate的值
console.log(addVAT1(100)); //123
</code></pre>
<h2 id="7-immediately-invoked-function-expressionsiife-立即调用函数表达式">7. Immediately Invoked Function Expressions(IIFE) 立即调用函数表达式</h2>
<pre><code class="language-js">// IIFE 立即执行函数
(function () {
  console.log('This will never run again');
  const isPrivate = 23; //私有变量
})();

// console.log(isPrivate); //报错
(() =&gt; console.log('This will ALSO never run again'))(); //立即执行函数 箭头

{
  const isPrivate = 23;
  var notPrivate = 46;
}

// console.log(isPrivate); //报错
console.log(notPrivate); //46
</code></pre>
<h2 id="8-closures-闭包">8. Closures 闭包</h2>
<pre><code class="language-js">// Closures
const secureBooking = function () {
  let passengerCount = 0;
  return function () {
    passengerCount++;
    console.log(`${passengerCount} passengers`);
  };
};

const booker = secureBooking();
booker();
booker();
booker();
</code></pre>
<p><img src="https://rowanwang6.github.io/post-images/1663827787143.png" alt="" loading="lazy"><br>
secureBooking() return function后，它的执行上下文出栈，但secureBooking()出栈后，为什么booker()还能继续访问passengerCount，使它累加？<br>
We can say a closure makes a function remember all the variable that existed at the function's birthplace essentially.<br>
<img src="https://rowanwang6.github.io/post-images/1663829053927.png" alt="" loading="lazy"><br>
<img src="https://rowanwang6.github.io/post-images/1663829275859.png" alt="" loading="lazy"><br>
闭包就像函数的一个背包，里面包含了函数被创建时的环境里的所有的变量。但闭包不能从代码访问，可以用console.dir()看。</p>
<h1 id="chapter-7-arrays">Chapter 7 Arrays</h1>
<h2 id="1-simply-array-methods">1. Simply Array methods</h2>
<pre><code class="language-js">let arr = ['a', 'b', 'c', 'd', 'e'];

// SLICE 切片
console.log(arr.slice(2)); // c d e
console.log(arr.slice(2, 4)); // c d
console.log(arr.slice(-2)); // d e
console.log(arr.slice(-1)); // e
console.log(arr.slice(1, -2)); // b c
console.log(arr.slice()); // a b c d e
console.log([...arr]); // a b c d e
// slice() 和 ...arr 都是浅拷贝 都不会修改原数组

// SPLICE 拼接
// 会修改原数组 而且第二个参数为长度，不是endIndex
// 主要用来删除数组元素
arr.splice(-1); // e
console.log(arr); // a b c d
// arr.splice(, ); // b c
console.log(arr); // a b c
let arr1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
arr1.splice(5, 2); // f g
console.log(arr1); // a b c d e h i j
arr1.splice(5, 2, 'f', 'g'); // 如果第二个参数为0，即可实现插入元素
console.log(arr1); // a b c d e f g j

// REVERSE
// 会修改原数组
arr = ['a', 'b', 'c', 'd', 'e'];
const arr2 = ['j', 'i', 'h', 'g', 'f'];
console.log(arr2.reverse());
console.log(arr2);

// CONCAT concatenate 连接 串联
// 不会修改原数组
const letters = arr.concat(arr2);
console.log(letters);
console.log([...arr, ...arr2]);

// JOIN
console.log(letters.join(' - '));
</code></pre>
<h2 id="2-at-method">2. at() method</h2>
<pre><code class="language-js">// The new at Method
const arr = [23, 11, 64];
console.log(arr[0]);
console.log(arr.at(0));

// getting last array element
console.log(arr[arr.length - 1]);
console.log(arr.slice(-1)[0]);
console.log(arr.at(-1));// 最简洁

console.log('jonas'.at(0));
console.log('jonas'.at(-1));
</code></pre>
<h2 id="3-foreach">3. forEach()</h2>
<pre><code class="language-js">const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];

for (const [i, movement] of movements.entries()) {
  if (movement &gt; 0) {
    console.log(`Movement ${i + 1}: You deposited ${movement}`);
  } else {
    console.log(`Movement ${i + 1}: You withdrew ${Math.abs(movement)}`);
  }
}

// forEach是高阶函数，需要一个回调函数，函数参数是forEach传入的每一个element, index, array. 顺序固定。forEach不会返回任何值，无法break，continue，return
movements.forEach(function (movement, i, arry) {
  if (movement &gt; 0) {
    console.log(`Movement ${i + 1}: You deposited ${movement}`);
  } else {
    console.log(`Movement ${i + 1}: You withdrew ${Math.abs(movement)}`);
  }
});
// 0: function(200)
// 1: function(450)
// 2: function(400)
// ...

// Map
const currencies = new Map([
  ['USD', 'United States dollar'],
  ['EUR', 'Euro'],
  ['GBP', 'Pound sterling'],
]);
// array都是本身，不是每次循环的一列！
currencies.forEach(function (el, i, array) {
  console.log(`${i}: ${el}`);
  console.log(array);
});

// Set
const currenciesUnique = new Set(['USD', 'GBP', 'USD', 'EUR', 'EUR']);
console.log(currenciesUnique);
// 由于Set没有index，为了保持参数的一致性，这里index=value
currenciesUnique.forEach(function (el, i, array) {
  console.log(`${i}: ${el}`);
  console.log(array);
});
</code></pre>
<h2 id="4-data-transformation-map映射-filter-reduce">4. Data Transformation map()映射, filter, reduce</h2>
<figure data-type="image" tabindex="1"><img src="https://rowanwang6.github.io/post-images/1664240537087.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">
// filter
// const deposit = movements.filter(mov =&gt; mov &gt; 0);
const deposit = movements.filter(function (mov) {
  return mov &gt; 0;
});
console.log(movements);
console.log(deposit);

const withdrawals = movements.filter(mov =&gt; mov &lt; 0);
console.log(withdrawals);

// reduce
//accumulator -&gt; snowball 累加
const balance = movements.reduce(function (accumulator, current, index, arr) {
  console.log(index, accumulator);
  return accumulator + current;
}, 0);

// maximum value using reduce
const max = movements.reduce((acc, cur) =&gt; {
  if (acc &gt; cur) return acc;
  else return cur;
}, movements[0]);// 使用reduce来求最大值时，第一个返回值要注意不要设成0
console.log(max);
</code></pre>
<h2 id="5-find-method">5. find() method</h2>
<pre><code class="language-js">// find 返回找到的第一个
const firstWithdrawl = movements.find(el =&gt; el &lt; 0);
console.log(firstWithdrawl);
</code></pre>
<h2 id="6-some-method-and-every-method">6. some() method and every() method</h2>
<pre><code class="language-js">// some() method
// 与includes()不同，some()可以判断条件，比等式范围更大
console.log(movements);
console.log(movements.some(el =&gt; el &gt; 0));// true

// every
console.log(movements.every(el =&gt; el &gt; 0));// false
console.log(movements.every(el =&gt; typeof el === 'number'));// true
</code></pre>
<h2 id="7-flat-and-flatmap">7. flat() and flatMap()</h2>
<pre><code class="language-js">const arr = [1, [2, 3], 4];
const arr1 = [1, [2, 3, [4, 5], 6], 7];
console.log(arr.flat()); //1234
console.log(arr1.flat()); //123[4,5]67
console.log(arr1.flat(2)); //1234567  Depth 参数

// const accountsMovenment = accounts.map(el =&gt; el.movements);
// console.log(accountsMovenment);

// const allMovement = accountsMovenment.flat();
// console.log(allMovement);

// const overalBalance = allMovement.reduce((acc, el) =&gt; acc + el);
// console.log(overalBalance);

// const overalBalance2 = accounts
//   .map(el =&gt; el.movements)
//   .flat()
//   .reduce((acc, el) =&gt; acc + el);
// console.log(overalBalance2);

const overalBalance2 = accounts
  .flatMap(el =&gt; el.movements) // flatMap 只能一层深度， = .map().flat()
  .reduce((acc, el) =&gt; acc + el);
console.log(overalBalance2);
</code></pre>
<h2 id="8-sorting-array">8. Sorting array</h2>
<h1 id="其他">其他</h1>
<p>带sourcemap打包，然后将sourcemap删除掉再上线<br>
跨域问题来自于浏览器的同源策略，即当协议、域名、端口号任意一个不同时，都会引发跨域问题。<br>
<img src="https://rowanwang6.github.io/post-images/1663232537722.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS]]></title>
        <id>https://rowanwang6.github.io/post/css/</id>
        <link href="https://rowanwang6.github.io/post/css/">
        </link>
        <updated>2022-05-05T03:28:59.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code class="language-CSS">#一段CSS代码
&lt;style&gt;
    h1{
        color:red;
        background-color:lightblue;
        text-align:center;
    }
&lt;/style&gt;
</code></pre>
<h2 id="1-css规则-选择器-声明块">1. CSS规则 = 选择器 + 声明块</h2>
<p>CSS（Cascading Style Sheets）层叠样式表</p>
<h3 id="11-选择器">1.1 选择器</h3>
<p>帮助你精准的选中想要的元素(花括号前的内容)</p>
<ol>
<li>ID选择器：选中的是对应id值的元素</li>
</ol>
<pre><code>#test{
    ...
}
</code></pre>
<ol start="2">
<li>元素选择器 用的少</li>
<li><strong>类选择器</strong></li>
</ol>
<pre><code>.red {
            color: red;
        }
</code></pre>
<ol start="4">
<li>
<p>通配符选择器<br>
<code>*{...}</code>: 选中所有元素</p>
</li>
<li>
<p>属性选择器<br>
根据属性名和属性值选中元素</p>
</li>
<li>
<p><strong>伪类选择器</strong><br>
<code>a:hover{color:red}</code><br>
选中某些元素的某种状态<br>
书写顺序：<br>
1）link: 超链接未访问时的状态<br>
2）visited: 超链接访问过后的状态<br>
3）hover: 鼠标悬停状态<br>
4）active：激活状态，鼠标按下状态<br>
爱恨法则：<strong>l</strong>o<strong>v</strong>e <strong>ha</strong>te</p>
</li>
</ol>
<ul>
<li>first-child，选择第一个子元素</li>
<li>first-of-type，选中子元素中第一个指定类型的元素</li>
<li>last-child</li>
<li>nth-child，选中指定的第几个子元素</li>
<li>nth-of-type，选中指定的子元素中第几个某类型的元素</li>
</ul>
<blockquote>
<p>even：关键字，等同于2n<br>
odd: 关键字，等同于2n+1</p>
</blockquote>
<ol start="7">
<li>伪元素选择器<br>
<code>p::before{}</code></li>
</ol>
<ul>
<li>before: 在第一位生成一个无名子元素</li>
<li>after: 在最后一位生成一个无名子元素</li>
<li>first-letter：选中元素中的第一个字母</li>
<li>first-line：选中元素中第一行的文字</li>
<li>selection：选中被用户框选的文字</li>
</ul>
<h4 id="111-选择器的组合">1.1.1 选择器的组合</h4>
<ol>
<li>并且 连写<code>.xxx.xxx</code></li>
<li>后代元素 —— 空格</li>
<li>子元素 —— &gt;</li>
<li>相邻兄弟元素 —— +</li>
<li>后面出现的所有兄弟元素 —— ~</li>
</ol>
<h4 id="112-选择器的并列">1.1.2 选择器的并列</h4>
<p>多个选择器, 用逗号分隔<br>
语法糖</p>
<h3 id="12-声明块">1.2 声明块</h3>
<p>花括号中的内容<br>
声明块中包含很多声明（属性），每一个声明（属性）表达了某一方面的样式</p>
<h2 id="2-css代码书写位置">2. CSS代码书写位置</h2>
<ol>
<li>内部样式表<br>
书写在style元素中（开头）</li>
<li>内联样式表，元素样式表<br>
直接书写在元素的style属性中 <code>&lt;p style=...&gt;</code></li>
<li><strong>外部样式表</strong><br>
将样式书写到独立的css文件中。<br>
<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;</code><br>
1). 外部样式可以解决多页面样式重复的问题<br>
2). 有利于浏览器缓存，从而提高页面响应速度<br>
3). 有利于代码分离（HTML和CSS），更容易阅读和维护</li>
</ol>
<h2 id="3-常见样式声明">3. 常见样式声明</h2>
<ol>
<li>
<p>color<br>
元素内部的文字颜色<br>
<strong>预设值</strong>：定义好的单词<br>
<strong>三原色，色值</strong>：光学三原色（红、绿、蓝），每个颜色可以使用0-255之间的数字来表达，色值。</p>
<pre><code>rgb表示法：(red green blue)
rgb(0, 255, 0)
hex（16进制）表示法：
#红绿蓝
#008C8C
</code></pre>
<p>淘宝红：#ff4400, #f40<br>
黑色：#000000，#000<br>
白色：#ffffff, #fff<br>
红：#ff0000, #f00<br>
绿：#00ff00, #0f0<br>
蓝：#0000ff, #00f<br>
紫：#f0f<br>
青：#0ff<br>
黄：#ff0<br>
灰色：#ccc</p>
</li>
<li>
<p>background-color<br>
元素背景颜色</p>
</li>
<li>
<p>font-size<br>
元素内部文字的尺寸大小<br>
1）px：像素，绝对单位，简单的理解为文字的高度占多少个像素<br>
2）em：相对单位，相对于父元素的字体大小，最终都会换算成数值。<br>
每个元素必须有字体大小，如果没有声明，则直接使用父元素的字体大小，如果没有父元素（html），则使用基准字号。</p>
</li>
</ol>
<blockquote>
<p>user agent，UA，用户代理（浏览器）</p>
</blockquote>
<!-- more -->
<ol start="4">
<li>font-weight<br>
文字粗细程度，可以取值数字，可以取值为预设值</li>
</ol>
<blockquote>
<p>strong，默认加粗。语义上表示强调不可忽略。</p>
</blockquote>
<!-- more -->
<ol start="5">
<li>font-family<br>
文字类型<br>
必须用户计算机中存在的字体才会有效。<br>
使用多个字体，以匹配不同环境（用户电脑中应该会下载一种字体）<br>
sans-serif，非衬线字体-字体边缘无修饰（通用写法，应对用户电脑版本旧）<br>
consolas</li>
<li>font-style<br>
字体样式，通常用它设置斜体</li>
</ol>
<blockquote>
<p>i元素，em元素，默认样式，是倾斜字体; 实际使用中，通常用它表示一个图标（icon）；em表示强调</p>
</blockquote>
<ol start="7">
<li>text-decoration<br>
文本修饰，给文本加线。</li>
</ol>
<blockquote>
<p>a元素<br>
del元素：错误的内容<br>
s元素：过期的内容</p>
</blockquote>
<ol start="8">
<li>text-indent<br>
首行文本缩进</li>
<li>line-height<br>
每行文本的高度，该值越大，每行文本的距离越大。<br>
设置行高为容器的高度，可以让单行文本垂直居中。<br>
行高可以设置为纯数字，表示相对于当前元素的字体大小。</li>
<li>width<br>
宽度</li>
<li>height<br>
高度</li>
<li>letter-space<br>
文字间隙</li>
<li>text-align<br>
元素内部文字的水平排列方式</li>
</ol>
<h3 id="31-更多的样式">3.1 更多的样式</h3>
<h4 id="透明度">透明度</h4>
<ol>
<li>opacity，它设置的是整个元素的透明，它的取值是0 ~ 1</li>
<li>在颜色位置设置alpha通道 <code>rgba(0, 0, 0, 0.5)</code></li>
</ol>
<h4 id="鼠标">鼠标</h4>
<p>使用cursor设置 pointer/ .ico 替换指针图标</p>
<h4 id="盒子隐藏">盒子隐藏</h4>
<ol>
<li>display:none，不生成盒子</li>
<li>visibility:hidden，生成盒子，只是从视觉上移除盒子，盒子仍然占据空间。</li>
</ol>
<h4 id="背景图">背景图</h4>
<h5 id="和img元素的区别">和img元素的区别</h5>
<p>img元素是属于HTML的概念<br>
背景图属于css的概念</p>
<ol>
<li>当图片属于网页内容时，必须使用img元素</li>
<li>当图片仅用于美化页面时，必须使用背景图</li>
</ol>
<h5 id="涉及的css属性">涉及的css属性</h5>
<ol>
<li>
<p>background-image</p>
</li>
<li>
<p>background-repeat<br>
默认情况下，背景图会在横坐标和纵坐标中进行重复</p>
</li>
<li>
<p>background-size<br>
<strong>设置size前，要先写position再写尺寸</strong><br>
预设值：contain、cover，类似于object-fit<br>
数值或百分比<br>
强制拉伸填充图片<code>background-size: 100% 100%;</code></p>
</li>
<li>
<p>background-position<br>
设置背景图的位置。<br>
预设值：left、bottom、right、top、center<br>
数值或百分比<br>
雪碧图（精灵图）（spirit）</p>
</li>
<li>
<p>background-attachment<br>
通常用它控制背景图是否固定。</p>
</li>
<li>
<p>背景图和背景颜色混用</p>
</li>
<li>
<p>速写（简写）background<br>
百分比先写位置再写尺寸</p>
</li>
</ol>
<h2 id="4-层叠">4. <a href="#4-%E5%B1%82%E5%8F%A0">层叠</a></h2>
<p>声明冲突：同一个样式，多次应用到同一个元素（并不是一定要避免）<br>
层叠：解决声明冲突的过程，浏览器自动处理（权重计算）</p>
<h3 id="41-判断步骤">4.1 判断步骤：</h3>
<h3 id="第一步比较重要性">第一步：比较重要性</h3>
<p>重要性从高到底：<br>
1） 作者样式表中的!important样式（尽量不要加）</p>
<ol>
<li>作者样式表中的普通样式</li>
<li>浏览器默认样式表中的样式</li>
</ol>
<blockquote>
<p>作者样式表：开发者书写的样式</p>
</blockquote>
<h3 id="第二步比较特殊性">第二步：比较特殊性</h3>
<p>看选择器<br>
总体规则：选择器选中的范围越窄，越特殊（<code>class</code>比<code>&lt;a&gt;</code>窄）<br>
具体规则：通过选择器，计算出一个4位数（x x x x）</p>
<ol>
<li>千位：如果是内联样式，记1，否则记0 （<code>&lt;a href=&quot;&quot; style=&quot;color:red&quot;&gt;&lt;/a&gt;</code> style为内联样式）</li>
<li>百位：等于选择器中所有id选择器的数量</li>
<li>十位：等于选择器中所有类选择器、属性选择器、伪类选择器的数量</li>
<li>个位：等于选择器中所有元素选择器、伪元素选择器的数量</li>
</ol>
<h3 id="第三步比较源次序">第三步：比较源次序</h3>
<p>代码书写靠后的胜出</p>
<h3 id="42-层叠在开发中的应用">4.2 层叠在开发中的应用</h3>
<ol>
<li>重置样式表<br>
书写一些作者样式，覆盖浏览器的默认样式<br>
重置样式表 -&gt; 浏览器的默认样式<br>
常见的重置样式表：normalize.css、reset.css、meyer.css</li>
<li>爱恨法则（源次序-靠后的胜出）<br>
link &gt; visited &gt; hover &gt; active</li>
</ol>
<h2 id="5-继承">5. 继承</h2>
<p>子元素会继承父元素的某些CSS属性<br>
通常，跟文字内容相关的属性都能被继承</p>
<h2 id="6-属性值的计算过程">6. 属性值的计算过程</h2>
<p>一个元素一个元素依次渲染，顺序按照页面文档的树形目录结构进行<br>
<img src="https://rowanwang6.github.io/post-images/1652004735430.png" alt="" loading="lazy"><br>
渲染每个元素的前提条件：该元素的所有CSS属性必须有值</p>
<p>一个元素，从所有属性都没有值，到所有的属性都有值，这个计算过程，叫做属性值计算过程</p>
<ol>
<li>确定声明值<br>
参考样式表（作者/浏览器样式表）中没有冲突的声明，作为CSS属性值</li>
<li>层叠冲突<br>
对样式表有冲突的声明使用<a href="#4-%E5%B1%82%E5%8F%A0">层叠</a>规则，确定CSS属性</li>
<li>使用继承<br>
对仍然没有值的属性，若可以继承，则继承父元素的值</li>
<li>使用默认值<br>
对仍然没有值的属性，使用默认值（MDN可查）</li>
</ol>
<p>举例</p>
<pre><code class="language-html">    &lt;style&gt;
        div {
            color: red;
        }
    &lt;/style&gt;
    .........
    &lt;body&gt;
    &lt;div&gt;
        &lt;a href=&quot;&quot;&gt;  a元素不会是红色，因为第一步浏览器样式表给了紫色
            举个例子
        &lt;/a&gt;
        &lt;p&gt;     p元素是红色
            p元素
        &lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>特殊的两个CSS取值：</p>
<ul>
<li>inherit：手动（强制）继承，将父元素的值取出应用到该元素</li>
<li>initial：初始值，将该属性设置为默认值</li>
</ul>
<h2 id="7-盒模型">7. 盒模型</h2>
<p>box：盒子，每个元素在页面中都会生成一个矩形区域（盒子）<br>
盒子类型：</p>
<ol>
<li>行盒，display等于inline的元素</li>
<li>块盒，display等于block的元素<br>
行盒在页面中不换行、块盒独占一行</li>
</ol>
<p>display默认值为inline</p>
<p>浏览器默认样式表设置的块盒：容器元素、h1~h6、p</p>
<p>常见的行盒：span、a、img、video、audio</p>
<h3 id="71-盒子的组成部分">7.1 盒子的组成部分</h3>
<p>无论是行盒、还是块盒，都由下面几个部分组成，从内到外分别是：</p>
<ol>
<li>
<p>内容  content<br>
width、height，设置的是盒子内容的宽高<br>
内容部分通常叫做整个盒子的<strong>内容盒 content-box</strong></p>
</li>
<li>
<p>填充(内边距)  padding<br>
盒子边框到盒子内容的距离<br>
padding-left、padding-right、padding-top、padding-bottom</p>
</li>
</ol>
<p>padding: 简写属性<br>
padding: 上 右 下 左 （顺时针）<br>
填充区+内容区 = <strong>填充盒 padding-box</strong></p>
<ol start="3">
<li>
<p>边框  border<br>
边框 = 边框样式 + 边框宽度 + 边框颜色<br>
边框样式：border-style (默认为none)<br>
边框宽度：border-width （默认为0）<br>
边框颜色：border-color<br>
<code>border: 4px dashed red;</code><br>
边框+填充区+内容区 = <strong>边框盒 border-box</strong></p>
</li>
<li>
<p>外边距  margin<br>
边框到其他盒子的距<br>
margin-top、margin-left、margin-right、margin-bottom<br>
速写属性margin</p>
</li>
</ol>
<h3 id="72-盒模型应用">7.2 盒模型应用</h3>
<ol>
<li>改变宽高范围<br>
默认情况下，width和height 设置的是内容盒宽高</li>
</ol>
<blockquote>
<p>页面重构师：将psd文件（设计稿）制作为静态页面<br>
衡量设计稿尺寸的时候，往往使用的是边框盒，但设置width和height，则设置的是内容盒</p>
</blockquote>
<ul>
<li>精确计算</li>
<li>CSS3：box-sizing  <code>box-sizing: border-box</code></li>
</ul>
<ol start="2">
<li>
<p>改变背景覆盖范围<br>
默认情况下，背景覆盖边框盒<br>
可以通过background-clip进行修改</p>
</li>
<li>
<p>溢出处理<br>
overflow，控制内容溢出边框盒后的处理方式<br>
sroll, hidden, auto</p>
</li>
<li>
<p>断词规则<br>
word-break，会影响文字在什么位置被截断换行<br>
normal：普通。CJK（中日韩）字符（文字位置截断），非CJK字符（单词位置截断）<br>
break-all：截断所有。所有字符都在文字处截断<br>
keep-all：保持所有。所有文字都在单词之间截断</p>
</li>
<li>
<p>空白处理<br>
white-space: nowrap 不换行</p>
</li>
</ol>
<pre><code>    &lt;!-- 显示不完来显示三个点，只能控制显示单行文本 --&gt;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
</code></pre>
<p>white-space: pre 不会折叠</p>
<h2 id="8-行盒的盒模型">8. 行盒的盒模型</h2>
<p>常见的行盒：包含具体内容的元素<br>
span、strong、em、i、img、video、audio</p>
<h3 id="81-行盒的显著特点">8.1 行盒的显著特点</h3>
<ol>
<li>
<p>盒子沿着内容延伸</p>
</li>
<li>
<p>行盒不能设置宽、高<br>
调整行盒的宽、高，应该使用字体大小、行高、字体类型，间接调整内容大小。</p>
</li>
<li>
<p>内边距（填充区）<br>
水平方向有效，垂直方向不会实际占据空间（不会挤走别的文字）。</p>
</li>
<li>
<p>边框<br>
水平方向有效，垂直方向不会实际占据空间。</p>
</li>
<li>
<p>外边距<br>
水平方向有效，垂直方向不会实际占据空间。</p>
</li>
</ol>
<h3 id="82-行块盒">8.2 行块盒</h3>
<p>display：inline-block 的盒子</p>
<ol>
<li>不独占一行</li>
<li>盒模型中所有尺寸都有效</li>
</ol>
<h3 id="83-空白折叠">8.3 空白折叠</h3>
<p>空白折叠，发生在行盒（行块盒）内部 或 行盒（行块盒）之间</p>
<h3 id="84-可替换元素-和-非可替换元素">8.4 可替换元素 和 非可替换元素</h3>
<p>大部分元素，页面上显示的结果，取决于元素内容，称为<strong>非可替换元素</strong><br>
少部分元素，页面上显示的结果，取决于元素属性，称为<strong>可替换元素</strong><br>
可替换元素：img、video、audio<br>
绝大部分可替换元素均为行盒。<br>
可替换元素类似于行块盒，盒模型中所有尺寸都有效。<br>
<code>object-fit: contain/cover/fill</code></p>
<h2 id="9-视觉格式化模型常规流-浮动和定位">9. 视觉格式化模型：常规流、浮动和定位</h2>
<p>盒模型：规定单个盒子的规则<br>
视觉格式化模型（布局规则）：页面中的多个盒子排列规则<br>
视觉格式化模型，大体上将页面中盒子的排列分为三种方式：</p>
<ol>
<li>常规流</li>
<li>浮动</li>
<li>定位</li>
</ol>
<h3 id="91-常规流布局">9.1 常规流布局</h3>
<p>常规流布局，或者叫做常规流、文档流、普通文档流、常规文档流。<br>
所有元素，默认情况下，都属于常规流布局。<br>
总体规则：块盒独占一行，行盒水平依次排列<br>
包含块（containing block）：每个盒子都有它的包含块，包含块决定了盒子的排列区域。<br>
绝大部分情况下：盒子的包含块，为其父元素的内容盒</p>
<h4 id="911-块盒">9.1.1 块盒</h4>
<ol>
<li>每个块盒的总宽度，必须刚好等于包含块的宽度<br>
宽度的默认值是auto<br>
margin的取值也可以是auto，默认值0<br>
auto：将剩余空间吸收掉<br>
width吸收能力强于margin<br>
吸收：因为每个块盒的总宽度必须刚好等于包含块的宽度，假如我们的块盒大小远小于包含块，剩余空间需要被“吸收”。<br>
若宽度、边框、内边距、外边距计算后，仍然有剩余空间，该剩余空间被margin-right全部吸收。</li>
</ol>
<p>在常规流中，块盒在其包含快中居中，可以定宽、然后左右margin设置为auto。</p>
<ol start="2">
<li>
<p>每个块盒垂直方向上的auto值<br>
height:auto， 适应内容的高度<br>
margin:auto， 表示0</p>
</li>
<li>
<p>百分比取值<br>
padding、宽、margin可以取值为百分比<br>
以上的所有百分比相对于包含块的<strong>宽度</strong>（margin-top也要按宽度来）。<br>
高度的百分比：<br>
1）包含块的高度是否取决于子元素的高度，设置百分比无效<br>
2）包含块的高度不取决于子元素的高度，百分比相对于父元素高度<br>
<strong>父元素有高度，子元素百分比才有效</strong></p>
</li>
<li>
<p>上下外边距的合并（margin塌陷）<br>
两个常规流块盒，上下外边距相邻，会进行合并。<br>
两个外边距取最大值。</p>
</li>
</ol>
<h4 id="92-常规流练习">9.2 常规流练习</h4>
<ol>
<li>公司的重置样式 reset.css link导入(先重置，再导入我们的css)</li>
<li>给reset.css加一个a样式</li>
<li>1713/1902 = 90%，不设置body的宽高，直接设置article宽度的百分比。</li>
<li><code>margin: 0 auto;</code>块盒居中</li>
<li>所有文字行高都为2 - 行高代码写在body里</li>
<li>link div的margin-bottom和</li>
</ol>
<h3 id="92-浮动">9.2 浮动</h3>
<h4 id="921-应用场景">9.2.1 应用场景</h4>
<ol>
<li>文字环绕</li>
<li>横向排列</li>
</ol>
<h4 id="922-浮动的基本特点">9.2.2 浮动的基本特点</h4>
<p>修改CSS的float`属性值为：</p>
<ul>
<li><code>left</code>：左浮动，元素靠上靠左</li>
<li><code>right</code>：右浮动，元素靠上靠右<br>
默认值为none</li>
</ul>
<ol>
<li>当一个元素浮动后，元素必定为块盒(更改display属性为block)</li>
<li>浮动元素的包含块，和常规流一样，为父元素的内容盒</li>
</ol>
<h4 id="923-盒子尺寸">9.2.3 盒子尺寸</h4>
<ol>
<li>宽度为auto时，适应内容宽度（无内容且不设置宽度就为0）</li>
<li>高度为auto时，与常规流一致，适应内容的高度</li>
<li>margin为auto，相当于为0.</li>
<li>边框、内边距、百分比设置与常规流一样，相对于包含块，父元素的内容盒</li>
</ol>
<h4 id="924-盒子排列">9.2.4 盒子排列</h4>
<ol>
<li>左浮动的盒子靠上靠左排列</li>
<li>右浮动的盒子靠上靠右排列</li>
<li>浮动盒子在包含块中排列时，会避开常规流块盒</li>
<li>常规流块盒在排列时，无视浮动盒子</li>
<li>行盒在排列时，会避开浮动盒子</li>
<li>外边距合并不会发生</li>
</ol>
<blockquote>
<p>如果文字没有在行盒中，浏览器会自动生成一个行盒包裹文字，该行盒叫做匿名行盒。</p>
</blockquote>
<h4 id="925-高度坍塌">9.2.5 高度坍塌</h4>
<p>高度坍塌的根源：常规流盒子的自动高度，在计算时，不会考虑浮动盒子（浮动盒子脱离了常规流）<br>
清除浮动，涉及css属性：clear</p>
<ul>
<li>默认值：none</li>
<li>left：清除左浮动，该元素必须出现在前面所有左浮动盒子的下方</li>
<li>right：清除右浮动，该元素必须出现在前面所有右浮动盒子的下方</li>
<li>both：清除左右浮动，该元素必须出现在前面所有浮动盒子的下方<br>
解决方法：写一个空元素/<code>.clearfix::after</code></li>
</ul>
<h4 id="926-浮动的练习">9.2.6 浮动的练习</h4>
<ol>
<li>激活后hover不变 需要写<code>.mian .nav a.active</code></li>
<li>给浮动元素的子、父元素加上<code>.clearfix::after</code>来避免所有的高度坍塌</li>
<li>......</li>
</ol>
<h3 id="93-定位">9.3 定位</h3>
<p>手动控制元素在包含块中的精确位置<br>
涉及的CSS属性：position</p>
<h4 id="931-position属性">9.3.1 position属性</h4>
<ul>
<li>默认值：static，静态定位（不定位）</li>
<li>relative：相对定位</li>
<li>absolute：绝对定位</li>
<li>fixed：固定定位<br>
一个元素，只要position的取值不是static，认为该元素是一个定位元素。<br>
定位元素会脱离文档流（相对定位除外）</li>
</ul>
<p>一个脱离了文档流的元素：</p>
<ol>
<li>文档流中的元素摆放时，会忽略脱离了文档流的元素</li>
<li>文档流中元素计算自动高度时，会忽略脱离了文档流的元素</li>
</ol>
<h4 id="932-相对定位">9.3.2 相对定位</h4>
<p>不会导致元素脱离文档流，只是让元素在原来位置上进行偏移。<br>
可以通过四个CSS属性对设置其位置：(离原来上下左右位置的偏移量)</p>
<ul>
<li>left</li>
<li>right</li>
<li>top</li>
<li>bottom<br>
盒子的偏移不会对其他盒子造成任何影响。</li>
</ul>
<h4 id="933-绝对定位">9.3.3 绝对定位</h4>
<ol>
<li>宽高为auto，适应内容</li>
<li><strong>包含块变化：找祖先中第一个定位元素，该元素的填充盒（padding-box）为其包含块（content-box）。若找不到，则它的包含块为整个网页（初始化包含块）</strong><br>
left：元素左边离包含块左边的距离</li>
</ol>
<h4 id="934-固定定位">9.3.4 固定定位</h4>
<p>包含块不同：固定为视口（浏览器的可视窗口）<br>
其他情况和绝对定位完全一样。</p>
<h4 id="935-定位下的居中">9.3.5 定位下的居中</h4>
<p>某个方向居中：</p>
<ol>
<li>定宽（高）</li>
<li>将左右（上下）距离设置为0</li>
<li>将左右（上下）margin设置为auto</li>
</ol>
<p>绝对定位和固定定位中，margin为auto时，会自动吸收剩余空间</p>
<h4 id="936-多个定位元素重叠时">9.3.6 多个定位元素重叠时</h4>
<p>堆叠上下文<br>
设置z-index，通常情况下，该值越大，越靠近用户<br>
只有定位元素设置z-index有效<br>
z-index可以是负数，如果是负数，则遇到常规流、浮动元素，则会被其覆盖</p>
<h4 id="937-补充">9.3.7 补充</h4>
<ul>
<li>绝对定位、固定定位元素一定是块盒（相对定位不会改变之前的状态<code>inline/block</code>）</li>
<li>绝对定位、固定定位元素一定不是浮动</li>
<li>没有外边距合并</li>
</ul>
<h4 id="938-定位的练习">9.3.8 定位的练习</h4>
<h5 id="二级菜单">二级菜单</h5>
<ol>
<li>边框不改变盒子的尺寸：<code>box-sizing: border-box;</code></li>
<li>设置行高后，hover加边框会将文字挤下去，需要在hover里同时修改行高为减去边框大小</li>
<li><code>display: none;</code>隐藏一个盒子</li>
</ol>
<h5 id="弹出层">弹出层</h5>
<ol>
<li>希望包含块是视口，选固定定位。</li>
</ol>
<h5 id="轮播图">轮播图</h5>
<p><code>box-sizing:border-box</code>会导致其他高度改变，可以用<code>outline: 1px solid...</code>将边框直接加在外面</p>
<h2 id="10-美化表单元素">10. 美化表单元素</h2>
<h3 id="101-新的伪类">10.1 新的伪类</h3>
<ol>
<li>
<p>focus<br>
元素聚焦时的样式</p>
</li>
<li>
<p>checked<br>
单选或多选框被选中的样式<br>
<code>input:checked+label</code>实现选中文字样式改变</p>
</li>
</ol>
<h3 id="102-常见用法">10.2 常见用法</h3>
<ol>
<li>重置表单元素样式</li>
<li>设置textarea是否允许调整尺寸</li>
</ol>
<p>css属性resize：</p>
<ul>
<li>both：默认值，两个方向都可以调整尺寸</li>
<li>none：不能调整尺寸</li>
<li>horizontal: 水平方向可以调整尺寸</li>
<li>vertical：垂直方向可以调整尺寸</li>
</ul>
<ol>
<li>文本框边缘到内容的距离<br>
<code>/* 方式1：padding  左边始终会有空隙*/      input {          padding:0 10px;      }       /* 方式2：text-indent 首行缩进 文本超过文本框长度后就会填满空隙 */      input, textarea {          text-indent: 1em;      }</code></li>
<li>控制单选和多选的样式<br>
自己做单选框多选框**重点</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML]]></title>
        <id>https://rowanwang6.github.io/post/web-notes/</id>
        <link href="https://rowanwang6.github.io/post/web-notes/">
        </link>
        <updated>2022-04-16T14:39:29.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="1-semantic-语义化">1. Semantic 语义化</h2>
<ul>
<li>选择什么元素，取决于内容的含义，而不是显示出的效果。</li>
<li>因为所有元素的样式都可以改, h1可以改成正文样式，h5可以改的像h1一样，依据浏览器自带CSS。</li>
</ul>
<h2 id="2-elements-元素">2. Elements 元素</h2>
<p>HTML5 <a href="https://www.xuanfengge.com/funny/html5/element/">元素周期表</a></p>
<p>常用标签：</p>
<ul>
<li><code>h</code> heading 标题  <code>h$*6&gt;{$级标题}</code></li>
<li><code>p</code> paragraph 段落标签</li>
<li><code>span</code> 无语义元素，仅用于设置样式 <code>display: block</code><br>
以前：某些元素在显示时会独占一行（块级元素），而某些元素不会（行级元素）。到了HTML5，已经弃用这种说法。</li>
<li><code>pre</code> 预格式化<br>
<strong>空白折叠</strong>：在源代码中的连续空白字符（空格、换行、制表），在页面显示时，会被折叠为一个空格<br>
在pre元素中的内容<strong>不会</strong>出现空白折叠<br>
在pre元素内部出现的内容，会按照源代码格式显示到页面上。<br>
该元素通常用于在网页中显示一些代码。<br>
pre元素功能的本质：它有一个默认的css属性。<br>
显示代码时，通常外面套code元素，code表示代码区域。</li>
<li><code>video</code> 视频元素  格式mp4 webm<br>
<code>controls=&quot;controls&quot;</code> = <code>controls</code><pre><code>某些属性，只有两种状态：1. 不写   2. 取值为属性名，这种属性叫做布尔属性
布尔属性，在HTML5中，可以不用书写属性值
autoplay: 布尔属性，自动播放。
muted: 布尔属性，静音播放。
loop: 布尔属性，循环播放
</code></pre>
</li>
<li><code>audio</code> 音频元素 与video一致<br>
旧版本的浏览器不支持这两个元素<br>
不同的浏览器支持的音视频格式可能不一致</li>
<li><code>ol/ul</code>列表元素<br>
<strong>有序列表：</strong><br>
<code>ol</code>: ordered list type=1:数字排列 I:罗马数字 a:字母 A大写字母 除非序号非常重要，否则以css控制<br>
<code>li</code>: list item<br>
<strong>无序列表：</strong><br>
<code>ul</code>: unordered list<br>
<strong>定义列表：</strong><br>
<code>dl</code>: defination list<br>
<code>dt</code>: defination title<br>
<code>dd</code>:  defination</li>
</ul>
<blockquote>
<p>lorem 乱数假文  <code>p*6&gt;lorem</code></p>
</blockquote>
<!-- more -->
<p>***<strong><code>a</code> hyperlink 超链接</strong><br>
格式：<code>&lt;a href=&quot;&quot;&gt; aa &lt;/a&gt;</code></p>
<ul>
<li>href属性 hyper reference<br>
<strong>跳转地址：</strong>  <code>&lt;a href=&quot;https://www.baidu.com&quot;&gt;baidu&lt;/a&gt;</code><br>
<strong>跳转锚点 :</strong><br>
ID属性：全局属性，表示元素在文档中的唯一编号 <code>&lt;h2 id=&quot;chapter6&quot;&gt;章节6&lt;/h2&gt;</code><br>
跳转锚点<code>&lt;a href=#chapter6&gt;锚点6&lt;/a&gt;</code><br>
回到顶部<code>&lt;a href=&quot;#&quot;&gt;回到顶部&lt;/a&gt;</code><br>
<strong>功能链接：</strong><br>
执行JS代码 <code>&lt;a href=&quot;javascript:alert('你好')&quot;&gt;弹出：你好&lt;/a&gt;</code><br>
发送邮件<code>&lt;a href=&quot;mailto:234234324324@qq.com&quot;&gt;点击给我发送邮件&lt;/a&gt;</code><br>
打电话<code>&lt;a href=&quot;tel:14354663333&quot;&gt;点击给我拨打电话&lt;/a&gt;</code></li>
<li>Traget属性<br>
<code>&lt;a href=&quot;https://douyu.com&quot; target=&quot;_blank&quot; title=&quot;斗鱼，每个人的直播平台&quot;&gt;斗鱼直播&lt;/a&gt;</code><br>
表示跳转窗口位置。<br>
target的取值：<br>
_self：在当前页面窗口中打开，默认值<br>
_blank: 在新窗口中打开</li>
</ul>
<p>***<strong><code>img</code> image 图片元素（空元素，没有结束标记）</strong><br>
格式：<code>&lt;img src=&quot;&quot;&gt;</code></p>
<ul>
<li>src属性 source</li>
<li>alt属性 当图片资源失效时，将使用该属性的文字替代图片</li>
<li>和a元素联用</li>
<li>和map元素联用<br>
map元素 <code>&lt;map name=&quot;&quot;&gt;&lt;/map&gt;</code><br>
子元素<code>&lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot; alt=&quot;&quot;&gt;</code><br>
circle坐标 x,y,r<br>
rect坐标 x1,y1,x2,y2 左上右下<br>
poly坐标 每个点坐标</li>
<li>和figure元素联用<br>
指代、定义，通常用于把图片、图片标题、描述包裹起来<br>
子元素：figcaption 标题 为了语义化</li>
</ul>
<p>***<strong><code>div</code> division 容器</strong><br>
该元素代表一个块区域，内部用于放置其他元素<br>
<code>header</code> 语义化的头部<br>
<code>footer</code> 语义化的尾部 或者页脚 或文章的尾部<br>
<code>article</code> 语义化的整篇文章<br>
<code>section</code> 语义化的文章章节<br>
<code>aside</code> 附加信息(侧边栏)</p>
<blockquote>
<p>快速生成章节与段落 +号代表兄弟元素 <code>(h2&gt;{章节1})+p&gt;lorem100</code> <code>((h2[id=&quot;chapter$&quot;]&gt;{章节$})+p&gt;{lorem100})*6</code></p>
</blockquote>
<h2 id="3-html-entity-实体">3. HTML Entity 实体</h2>
<p><a href="https://dev.w3.org/html5/html-author/charref">实体字符</a>通常用于在页面中显示一些特殊符号。<br>
使用方法：&amp;单词;</p>
<ul>
<li><code>&amp;lt;</code> &lt; less than</li>
<li><code>&amp;gt;</code> &gt; greater than</li>
<li><code>&amp;nbsp;</code> no-break space</li>
<li><code>&amp;copy;</code> © 版权符号</li>
</ul>
<h2 id="4-路径的写法">4. 路径的写法</h2>
<ol>
<li>站内资源和站外资源</li>
</ol>
<ul>
<li>站内资源：当前网站的资源</li>
<li>站外资源：非当前网站的资源</li>
</ul>
<ol start="2">
<li>绝对路径和相对路径<br>
站外资源：绝对路径<br>
站内资源：相对路径</li>
</ol>
<ul>
<li>绝对路径：<br>
url地址：<pre><code>协议名://主机名:端口号/路径

schema://host:port/path

协议名：http、https、file
主机名：域名：IP地址
端口号：http-默认80，https-默认443
当跳转目标和当前页面的协议相同时，可以省略协议
</code></pre>
</li>
<li>相对路径：<br>
以./开头，./表示当前资源所在的目录<br>
可以书写../表示返回上一级目录<br>
相对路径中：./可以省略</li>
</ul>
<h2 id="5-元素的包含关系">5. 元素的包含关系</h2>
<p>以前：块级元素可以包含行级元素，行级元素不可以包含块级元素，a元素除外。<br>
现在：元素的包含关系由元素的内容类别决定。<br>
查看：例如，h1元素中是否可以包含p元素 百度h1 mdn<br>
总结：</p>
<ol>
<li>容器元素中可以包含任何元素</li>
<li>a元素中几乎可以包含任何元素</li>
<li>某些元素有固定的子元素（ul&gt;li，ol&gt;li，dl&gt;dt+dd）</li>
<li>标题元素和段落元素不能相互嵌套，并且不能包含容器元素</li>
</ol>
<h2 id="6-补充">6. 补充</h2>
<h3 id="iframe-框架页"><code>iframe</code> 框架页</h3>
<p>通常用于在网页中嵌入另一个页面<br>
iframe</p>
<ol>
<li>可替换元素</li>
<li>通常行盒</li>
<li>通常显示的内容取决于元素的属性</li>
<li>CSS不能完全控制其中的样式</li>
<li>具有行快盒的特点</li>
</ol>
<h3 id="flash不再受支持">flash(不再受支持)</h3>
<ul>
<li>object</li>
<li>embed<br>
它们都是可替换元素（行盒）<br>
MIME(Multipurpose Internet Mail Extensions)<br>
多用途互联网邮件类型：<br>
比如，资源是一个jpg图片，MIME：image/jpeg</li>
</ul>
<h3 id="表单元素">表单元素</h3>
<p>一系列元素，主要用于收集用户数据</p>
<h4 id="input元素">input元素</h4>
<p>输入框</p>
<ul>
<li>
<p>type属性：输入框类型<br>
type: text， 普通文本输入框<br>
type: password，密码框（输入会变成点点或星号 仅能防偷窥）<br>
type: date, 日期选择框，兼容性问题<br>
type: search, 搜索框，兼容性问题<br>
type: number，数字输入框<code>&lt;input type=&quot;number&quot; min=&quot;0&quot; max=&quot;100&quot; step=&quot;20&quot;&gt;</code><br>
type: checkbox，多选框<br>
type: radio，单选框 (需要分组<code>name=gender</code>)，默认选中：checked<br>
type: file，选择文件上传</p>
</li>
<li>
<p>value属性：输入框的值(一开始就会在输入框内的文字 类似提示 可以用placeholder实现)</p>
</li>
<li>
<p>placeholder属性：显示提示的文本，文本框没有内容时显示<br>
input元素可以制作按钮<br>
当type值为reset、button、submit时，input表示按钮。</p>
</li>
</ul>
<h4 id="select元素">select元素</h4>
<p>下拉列表选择框<br>
通常和子元素option元素配合使用，默认选中：selected</p>
<h4 id="textarea元素">textarea元素</h4>
<p>文本域，多行文本框<br>
要显示默认文本，在元素内写，没有空白折叠</p>
<h4 id="按钮元素">按钮元素</h4>
<p>button<br>
type属性：reset、submit、button，默认值submit</p>
<h4 id="表单状态">表单状态</h4>
<p>readonly属性：布尔属性，是否只读，不会改变表单显示样式<br>
disabled属性：布尔属性，是否禁用，会改变表单显示样式</p>
<h4 id="配合表单元素的其他元素">配合表单元素的其他元素</h4>
<h4 id="label">label</h4>
<p>普通元素，通常配合单选和多选框使用</p>
<ul>
<li>显示关联<br>
可以通过for属性，让label元素关联某一个表单元素，for属性书写表单元素id的值</li>
<li>隐式关联<br>
label里套一个input元素</li>
</ul>
<h4 id="datalist">datalist</h4>
<p>数据列表<br>
该元素本身不会显示到页面，通常用于和普通文本框配合，id关联到<code>&lt;input list=&gt;</code>，回车填入的是value值<br>
搜索词条推荐<strong>不是</strong>使用的这个元素</p>
<h4 id="form元素">form元素</h4>
<p>通常，会将整个表单元素（文本框、按钮、下拉列表...），放置form元素的内部，作用是当提交表单时，会将form元素内部的表单内容以合适的方式提交到服务器。</p>
<p>form元素对开发静态页面没有什么意义。</p>
<h4 id="fieldset元素">fieldset元素</h4>
<p>表单分组，语义化，改善用户填写体验。</p>
<h3 id="美化表单元素">美化表单元素</h3>
<p>见<a href="http://rowanwang.tech/post/css/">CSS</a>中第10条笔记</p>
<h3 id="表格元素">表格元素</h3>
<h3 id="其他元素">其他元素</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[People Counting and Tracking(DeepSort Improvement)]]></title>
        <id>https://rowanwang6.github.io/post/people-counting-and-trackingdeepsort-improvement/</id>
        <link href="https://rowanwang6.github.io/post/people-counting-and-trackingdeepsort-improvement/">
        </link>
        <updated>2022-03-14T09:48:01.000Z</updated>
        <summary type="html"><![CDATA[<p>A classic tracking-by-detection method.</p>
]]></summary>
        <content type="html"><![CDATA[<p>A classic tracking-by-detection method.</p>
<!-- more -->
<h1 id=""></h1>
<p>First, let's start with DeepSort since my project is based on that.<br>
If you know what DeepSort is, please click <a href="#1-what-is-deepsort">here</a> to jump. ?????under</p>
<h1 id="1-what-is-deepsort">1. What is DeepSort?</h1>
<p>From what I know, DeepSort is used to track the bounding box from the detector.<img src="https://rowanwang6.github.io/post-images/1647252055059.jpg" alt="" loading="lazy"><br>
Look familiar? It's an improvement on SORT. Thank the author of the flowchart Harlek by the way, he is from BJU.<img src="https://rowanwang6.github.io/post-images/1647252077073.jpg" alt="" loading="lazy"><br>
Now, we may all notice the Kalman Predict and Update in both algorithms. That is the core part of the algorithms ——<strong>Kalman Filter</strong>.</p>
<h1 id="2-what-is-kalman-filter">2. What is Kalman Filter?</h1>
<p>Let's say we are trying to calculate Bob's weight <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, but the scale has a little bit of error that we may not get the correct weight. However, we can measure several times and take average to minimize the error. We have n number of measurement <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Z</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>Z</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>Z</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">Z_1, Z_2, ... , Z_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. Then we will have:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>Z</mi><mn>1</mn></msub><mo>+</mo><msub><mi>Z</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>Z</mi><mi>n</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">x=\frac{1}{Z_1+Z_2+...+Z_n}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.1574400000000002em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>To fully understand Kalman Filter, I strongly recommand this <a href="https://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/">article</a>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Resume]]></title>
        <id>https://rowanwang6.github.io/post/about/</id>
        <link href="https://rowanwang6.github.io/post/about/">
        </link>
        <updated>2022-03-14T09:38:22.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="education">EDUCATION</h1>
<p><strong>Wuhan University of Science and Technology</strong><br>
Electrical Engineering and Automation (电气工程及其自动化)<br>
2017/09/01-2021/06/30    Bachelor<br>
<strong>City University of Hongkong</strong><br>
Electronic Information Engineering (电子信息工程)<br>
2021/09/01-2022/10/03    Master</p>
<h1 id="researchproject">RESEARCH/PROJECT</h1>
<p><strong>Android APP: Linke    UI Design   Jan 2022</strong><br>
Responsible for UI design and UI source code development. Get an A on the first report for great UI.</p>
<p><strong>BOC VAT invoice     Intern   Nov 2021</strong><br>
Develop a  VAT invoice reimbursement system.</p>
<h1 id="internships">Internships</h1>
<p>Bank of China Fintech Ltd.   2022/07-Now</p>
<h1 id="contact">Contact</h1>
<p>E-mail: <a href="mailto:xkwang7-c@my.cityu.edu.hk">xkwang7-c@my.cityu.edu.hk</a> / <a href="mailto:RowanWang@foxmail.com">RowanWang@foxmail.com</a><br>
Tel: +852 95012749</p>
]]></content>
    </entry>
</feed>